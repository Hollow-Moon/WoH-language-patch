global.opPatchName = "op";

global.mobileBreakGlyphsFlagName = "mobileBreakGlyphs";
global.mobileBreakGlyphsPatchName = global.devMode? "ImagesPatch" : global.mainPatchName;
global.mobileBreakGlyphsFolderName = "break-mobile";

global.mobileWindowFlagName = "mobileWindow";
global.mobileWindowPatchName = global.devMode? "ImagesPatch" : global.mainPatchName;
global.mobileWindowFolderName = "window-mobile";

global.wideWindowFlagName = "wideWindow";
global.wideWindowPatchName = global.devMode? "ImagesPatch" : global.mainPatchName;
global.wideWindowFolderName = "window-wide";

global.wideMobileWindowPatchName = global.devMode? "ImagesPatch" : global.mainPatchName;
global.wideMobileWindowFolderName = "window-wide-mobile";

global.get_opPatchExists = function() { { return global.patchExists(global.opPatchName); } };
global.get_movieMenuPatch = function(kag=global.kag) { { return global.get_opPatchExists() && typeof(kag) === "Object" && typeof(kag.sflags) === "Object" && typeof(kag.sflags.movieMenuPatch) === "Integer" && kag.sflags.movieMenuPatch; } };
@if(GAME_FATE)
global.get_playRealtaOp = function(kag=global.kag) { { return typeof(kag) === "Object" && typeof(kag.sflags) === "Object" && typeof(kag.sflags.gmovie) === "String" && (kag.sflags.gmovie=="realta"); } };
global.get_playClassicOp = function(kag=global.kag) { { return global.get_opPatchExists() && typeof(kag) === "Object" && typeof(kag.sflags) === "Object" && typeof(kag.sflags.gmovie) === "String" && (kag.sflags.gmovie=="classic"); } };
@endif
@if(GAME_FHAT)
global.get_playRealtaOp = function(kag=global.kag) { { return false; } };
global.get_playClassicOp = function(kag=global.kag) { { return typeof(kag) === "Object" && typeof(kag.sflags) === "Object" && typeof(kag.sflags.gmovie) === "String" && (kag.sflags.gmovie=="classic"); } };
@endif
global.get_playVitaOp = function(kag=global.kag) { { return global.get_opPatchExists() && typeof(kag) === "Object" && typeof(kag.sflags) === "Object" && typeof(kag.sflags.gmovie) === "String" && (kag.sflags.gmovie=="vita"); } };

global.patchMenuIndex = -1;
global.getPatchMenuIndex = function(kag)
{
@if(kirikiriz)
	global.patchMenuIndex = kag.helpMenu.index;
@endif
@if(!kirikiriz)
	global.patchMenuIndex = 4; // No "index" member so we hardcode the number.
@endif
	return global.patchMenuIndex;
};

@if(GAME_FATE||GAME_FHAT)
global.window_scaling_factors = [
	0.25,
	0.50,
	0.80,
	1.00,
	1.28,
	1.60,
	1.80,
];
@endif

@if(GAME_WOHN)
global.window_scaling_factors = [
	0.625,
	0.78125,
	1.0,
	1.25,
	1.40625,
	1.5625,
	1.875,
];
@endif

global.fps_limit_values = [
	-1,
	0,
	"-",
	1000,
	960,
	480,
	240,
	144,
	120,
	100,
	90,
	75,
	60,
	45,
	40,
	30,
	20,
	15,
];

global.fps_limit_shortcuts = %[
	"144" => "1&44",
	"120" => "1&20",
	"90" => "&90",
	"75" => "&75",
	"60" => "&60",
	"45" => "4&5",
	"30" => "&30",
	"15" => "&15",
];

global.thread_limit_values = [
	1,
	0,
	"-",
	2,
	4,
	8,
];

global.thread_limit_shortcuts = %[
	"2" => "&2",
	"4" => "&4",
	"8" => "&8",
];

class GameFlag
{
	var owner;
	var holder;
	var name;
	var reverse;
	var defaultValue;

	property value
	{
		getter
		{
			return (typeof(this.reverse) === "Integer" && this.reverse) ? !this.holder[this.name] : this.holder[this.name];
		}
		setter (v)
		{
			this.holder[this.name] = (typeof(this.reverse) === "Integer" && this.reverse) ? !v : v;
		}
	}

	function GameFlag(owner, holder, name, defaultValue=void, reverse=false)
	{
		this.owner = owner;
		this.holder = holder;
		this.name = name;
		this.reverse = reverse;
		this.defaultValue = defaultValue;

		if (this.defaultValue !== void && typeof(this.holder) === "Object" && typeof(this.holder[name]) === "undefined")
		{
			this.value = this.defaultValue;
		}
	}

	function toggleValue()
	{
		this.value = !this.value;
	}
}

class ComplexGameFlag extends global.GameFlag
{
	function ComplexGameFlag()
	{
		super.GameFlag(...);
	}

	property value
	{
		getter
		{
			// TODO code duplication between getter and setter.
			var path = this.name.split(".");
			var currentHolder = this.holder;
			for (var i = 0, internal_forloop_count = path.count - 1; i < internal_forloop_count; i += 1) {
				currentHolder = currentHolder[path[i]];
			}
			var lastPath = path[path.count-1];

			return (typeof(this.reverse) === "Integer" && this.reverse) ? !currentHolder[lastPath] : currentHolder[lastPath];
		}
		setter (v)
		{
			var path = this.name.split(".");
			var currentHolder = this.holder;
			for (var i = 0, internal_forloop_count = path.count - 1; i < internal_forloop_count; i += 1)
			{
				currentHolder = currentHolder[path[i]];
			}
			var lastPath = path[path.count-1];

			currentHolder[lastPath] = (typeof(this.reverse) === "Integer" && this.reverse) ? !v : v;
		}
	}
}

// For some reason this can't be an instance method...
global.inverseFlag = function(flag)
{
	return new global.GameFlag(flag.owner, flag.holder, flag.name, !flag.defaultValue, !flag.reverse);
};

class CompositeAndFlag
{
	var flags;

	function CompositeAndFlag(flags)
	{
		this.flags = flags;
	}

	property value {
		getter
		{
			for (var i = 0, internal_forloop_count = this.flags.count; i < internal_forloop_count; i += 1) {
				if (!this.flags[i].value) {
					return false;
				}
			}
			return true;
		}
		setter(v)
		{
			for (var i = 0, internal_forloop_count = this.flags.count; i < internal_forloop_count; i += 1) {
				this.flags[i].value = v;
			}
		}
	}

	function toggleValue()
	{
		var current_value = true;
		for (var i = 0, internal_forloop_count = this.flags.count; i < internal_forloop_count; i += 1)
		{
			var flag = this.flags[i];
			if (!flag.value)
			{
				current_value = false;
				break;
			}
		}
		for (var i = 0, internal_forloop_count = this.flags.count; i < internal_forloop_count; i += 1)
		{
			var flag = this.flags[i];
			flag.value = !current_value;
		}
	}
}

class KAGFlagMenuItem extends global.KAGMenuItem
{
	var flag;
	var radioValue;
	var previousFlagValue;
	var restart;

	function KAGFlagMenuItem(window, name, group=0, flag, radioValue=true, restart=false)
	{
		super.KAGMenuItem(window, name, group, this.onFlagMenuItemClick, false);

		this.flag = flag;
		this.radioValue = radioValue;
		this.restart = restart;
		this.initialize();
	}

	function onFlagMenuItemClick(sender)
	{
		this.previousFlagValue = sender.flag.value;

		var allowed = sender.beforeCallback(sender);
		if (!allowed) return;

		var flagValueChanged = true;
		if (sender.radio) {
			if (sender.flag.value === this.radioValue) {
				flagValueChanged = false;
			}
			sender.flag.value = this.radioValue;
		} else {
			sender.flag.toggleValue();
		}

		sender.checked = sender.flag.value === this.radioValue;

		sender.afterCallback(sender);

		if (this.restart && flagValueChanged && this.restartCondition()) {
			{
				var w = this.owner;
				if (typeof(w.extraConductor) === "Object")
				{
					w.extraConductor.clear(); // Fix code for AutoPath
					w.onReloadScenarioMenuItemClick(sender);
				}
			}
		}
	}

	function restartCondition()
	{
		return true;
	}

	function onlyTitleRestartCondition()
	{
		if (typeof this.owner.conductor !== "Object") {
			return false;
		}
		return this.owner.conductor.curStorage === "タイトル.ks" || this.owner.conductor.curStorage === "title.ks";
	}

	function onlyScenarioRestartCondition()
	{
		return !this.onlyTitleRestartCondition();
	}

	function updateChecked()
	{
		this.checked = this.flag.value === this.radioValue;
	}

	function initialize()
	{
		this.updateChecked();
		this.afterCallback(this, true);
	}

	function disableIfPatchDoesntExist(patchName)
	{
		if (patchName !== void && !global.patchExists(patchName)) {
			if (this.flag.value) {
				this.onFlagMenuItemClick(this);
			}
			this.enabled = false;
		}
	}

	function beforeCallback(sender, firstTime=false) { return true; }
	function afterCallback(sender, firstTime=false) { }
}

class KAGFlagFolderMenuItem extends global.KAGFlagMenuItem
{
	var patchNames;
	var folderNames;
	var inverseFolderNames;
	var languageSpecific;

	property patchName
	{
		getter
		{
			if (this.patchNames === void)
			{
				return "";
			}
			if (this.patchNames.count > 1)
			{
				throw new global.Exception("Can't use patchName with more than one patch.");
			}
			if (this.patchNames.count === 0)
			{
				return "";
			}
			return this.patchNames[0];
		}
	}

	function KAGFlagFolderMenuItem(window, name, group=0, flag, patchNames=void, folderNames=void, inverseFolderNames=void, languageSpecific=true, restart=false)
	{
		// In non-dev mode, some patchNames will be empty strings (since global.mainPatchName will be an empty string):
		// mobileBreakGlyphsPatchName, mobileWindowPatchName, wideWindowPatchName, wideMobileWindowPatchName, maturePatchName
		// We can not just set patchNames to void in this case, since in non-dev mode this will prevent subfolders
		// in patch.xp3 from being processed in loadFolders()/unloadFolders().
		/*
		if (patchNames === "")
		{
			patchNames = void;
		}
		*/
		if (folderNames === "")
		{
			folderNames = void;
		}
		if (inverseFolderNames === "")
		{
			inverseFolderNames = void;
		}
		if (typeof(patchNames) === "String")
		{
			patchNames = [patchNames];
		}
		this.patchNames = patchNames;
		if (typeof(folderNames) === "String")
		{
			folderNames = [folderNames];
		}
		if (typeof(inverseFolderNames) === "String")
		{
			inverseFolderNames = [inverseFolderNames];
		}
@if(0)
		if (typeof(patchNames) === "Object")
		{
			var patchNames_count = patchNames.count;
			if (typeof(folderNames) === "Object")
			{
				if (patchNames_count !== folderNames.count)
				{
					throw new global.Exception("The count of patchNames is not the same as folderNames");
				}
			}
			if (typeof(inverseFolderNames) === "Object")
			{
				if (patchNames_count !== inverseFolderNames.count)
				{
					throw new global.Exception("The count of patchNames is not the same as inverseFolderNames");
				}
			}
		}
@endif
		this.folderNames = folderNames;
		this.inverseFolderNames = inverseFolderNames;
		this.languageSpecific = languageSpecific;
		super.KAGFlagMenuItem(window, name, group, flag,, restart);
		if (patchNames !== void)
		{
			for (var i = 0, internal_forloop_count = patchNames.count; i < internal_forloop_count; i += 1)
			{
				this.disableIfPatchDoesntExist(patchNames[i]);
			}
		}
	}

	function defaultEvaluateFlag(sender)
	{
		return sender.flag.value;
	}

	function evaluateFlag(sender)
	{
		return this.defaultEvaluateFlag(sender);
	}

	function defaultAfterCallback(sender, firstTime=false)
	{
		// Radio options that are not of boolean type should implement their own logic.
		// if (sender.radio) return;

		if (this.evaluateFlag(sender)) {
			this.loadAllFolders(firstTime);
		} else {
			this.unloadAllFolders(firstTime); // Don't unload if wasn't ever loaded.
		}
	}

	function afterCallback(sender, firstTime=false)
	{
		this.defaultAfterCallback(sender, firstTime);
	}

	function loadFolders(folderNames)
	{
		var patchNames = this.patchNames;
		if (patchNames !== void)
		{
			var patches_arr = [];
			for (var i = 0, internal_forloop_count = patchNames.count; i < internal_forloop_count; i += 1)
			{
				if (patchNames[i] !== void)
				{
@if(0)
					dm("loading: " + patchNames[i] + ">" + folderNames[i]);
@endif
					patches_arr.add([patchNames[i], folderNames[i]]);
@if(HD_MODE)
					if (this.owner.isHd)
					{
						global.addHdPaths(this.owner, patches_arr, patchNames[i], folderNames[i]);
					}
@endif
				}
				if (this.languageSpecific)
				{
					patches_arr.add([global.languagePatchName(global.japaneseLanguage), folderNames[i]]);
					if (this.owner.sflags.language !== void && this.owner.sflags.language !== global.japaneseLanguage)
					{
						patches_arr.add([global.languagePatchName(this.owner.sflags.language), folderNames[i]]);
					}
				}
			}
			global.load_patches(patches_arr);
			invalidate patches_arr;
			delete patches_arr;
		}
	}

	function unloadFolders(folderNames)
	{
		var patchNames = this.patchNames;
		if (patchNames !== void)
		{
			var patches_arr = [];
			for (var i = 0, internal_forloop_count = patchNames.count; i < internal_forloop_count; i += 1)
			{
				if (this.languageSpecific)
				{
					if (this.owner.sflags.language !== void && this.owner.sflags.language !== global.japaneseLanguage)
					{
						patches_arr.add([global.languagePatchName(this.owner.sflags.language), folderNames[i]]);
					}
					patches_arr.add([global.languagePatchName(global.japaneseLanguage), folderNames[i]]);
				}
				if (patchNames[i] !== void)
				{
@if(0)
					dm("unloading: " + patchNames[i] + ">" + folderNames[i]);
@endif
@if(HD_MODE)
					if (this.owner.isHd)
					{
						global.addHdPaths(this.owner, patches_arr, patchNames[i], folderNames[i]);
					}
@endif
					patches_arr.add([patchNames[i], folderNames[i]]);
				}
			}
			global.unload_patches(patches_arr);
			invalidate patches_arr;
			delete patches_arr;
		}
	}

	function loadAllFolders(firstTime=false)
	{
		this.unloadFolders(this.inverseFolderNames) if this.inverseFolderNames !== void && !firstTime;
		this.loadFolders(this.folderNames) if this.folderNames !== void;
	}

	function unloadAllFolders(firstTime=false)
	{
		this.unloadFolders(this.folderNames) if this.folderNames !== void && !firstTime;
		this.loadFolders(this.inverseFolderNames) if this.inverseFolderNames !== void;
	}
}

class KAGCensorMenuItem extends global.KAGMenuItem
{
	var hCensoredMenuItem;
	var hUncensoredMenuItem;
	var hDecensoredMenuItem;

	var matureMenuItem;

	var currentState;

	var previouslyFullyCensored;


	function KAGCensorMenuItem(window, name, hFlag)
	{
		super.KAGMenuItem(window, name, 0, void, false);
		this.addChildren(hFlag);
	}

	function addChildren(hFlag)
	{
		var matureFlag = new global.GameFlag(this.owner, this.owner.sflags, global.matureFlagName, hFlag.value);
		var ecchitextFlag = new global.GameFlag(this.owner, this.owner.sflags, global.ecchitextFlagname, hFlag.value);
		var ecchiFlag = new global.GameFlag(this.owner, this.owner.sflags, global.ecchiFlagName, hFlag.value);
		var decensorFlag = new global.GameFlag(this.owner, this.owner.sflags, global.decensoredFlagName, false);
		var decensorConfigFlag = new global.GameFlag(this.owner, this.owner.sflags, global.decensorConfigFlagName, "bellandy_anonymous");

		var matureFlagComposite = new global.CompositeAndFlag([matureFlag, ecchitextFlag]);
		var hCensorFlagComposite = new global.CompositeAndFlag([global.inverseFlag(ecchiFlag), global.inverseFlag(hFlag), global.inverseFlag(decensorFlag)]);
		var ecchiAllowFlagComposite = new global.CompositeAndFlag([ecchiFlag, global.inverseFlag(hFlag), global.inverseFlag(decensorFlag)]);
		var hFlagComposite = new global.CompositeAndFlag([ecchiFlag, hFlag, global.inverseFlag(decensorFlag)]);
		var decensorFlagComposite = new global.CompositeAndFlag([ecchiFlag, hFlag, decensorFlag]);

		this.add(this.matureMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("成人向けコンテンツを検閲しない(&M)"),, matureFlagComposite, global.maturePatchName, global.uncensoredMatureFolderName, global.censoredMatureFolderName,,true));
		this.matureMenuItem.restartCondition = this.matureMenuItem.onlyScenarioRestartCondition;
		this.matureMenuItem.beforeCallback = this.beforeCallback;
		this.matureMenuItem.afterCallback = this.afterCallback;

		(this.addSeperationLine incontextof this.owner)(this);

		this.add(this.hCensoredMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("エッチとエロを検閲する(&N)"), 1, hCensorFlagComposite, global.hCensorPatchName, global.censoredHFolderName,,,true));
		this.hCensoredMenuItem.restartCondition = this.hCensoredMenuItem.onlyScenarioRestartCondition;
		this.hCensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hCensoredMenuItem.afterCallback = this.afterCallback;

		this.add(this.ecchiUncensoredMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("エッチを検閲しない(&E)"), 1, ecchiAllowFlagComposite, global.ecchiPatchName, global.uncensoredEcchiFolderName,,,true));
		this.ecchiUncensoredMenuItem.restartCondition = this.ecchiUncensoredMenuItem.onlyScenarioRestartCondition;
		this.ecchiUncensoredMenuItem.beforeCallback = this.beforeCallback;
		this.ecchiUncensoredMenuItem.afterCallback = this.afterCallback;

		this.add(this.hUncensoredMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("エッチとエロを検閲しない(&H)"), 1, hFlagComposite, [global.ecchiPatchName, global.hPatchName], [global.uncensoredEcchiFolderName, global.uncensoredHFolderName],,,true));
		this.hUncensoredMenuItem.restartCondition = this.hUncensoredMenuItem.onlyScenarioRestartCondition;
		this.hUncensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hUncensoredMenuItem.afterCallback = this.afterCallback;

		this.add(this.hDecensoredMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("エッチとエロを強制的に無検閲する(&D)"), 1, decensorFlagComposite,
@if(GAME_FATE)
		[global.ecchiPatchName, global.hPatchName, global.decensoredPatchName], [global.uncensoredEcchiFolderName, global.uncensoredHFolderName, global.decensoredFolderName],,,true));
@endif
@if(GAME_FHAT)
		global.decensoredPatchName, global.decensoredFolderName,,,true));
@endif
@if(!GAME_FATE&&!GAME_FHAT)
		[], []));
@endif
		this.hDecensoredMenuItem.restartCondition = this.hDecensoredMenuItem.onlyScenarioRestartCondition;
		this.hDecensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hDecensoredMenuItem.afterCallback = this.afterCallback;

@if(GAME_FATE)
		(this.addSeperationLine incontextof this.owner)(this);

		this.add(this.decensorConfig = new global.KAGMenuItem(this.owner, __t("規制修正 絵師(&A)"), 0, void, false));

		this.decensorConfig.add(this.decensorConfigBellandyAnonymous = new global.KAGFlagMenuItem(this.owner, "Bellandy + Anonymous", 1, decensorConfigFlag, "bellandy_anonymous", true));
		this.decensorConfigBellandyAnonymous.restartCondition = this.decensorConfigBellandyAnonymous.onlyScenarioRestartCondition;
		this.decensorConfigBellandyAnonymous.afterCallback = function(sender) { global.updateDecensorConfig(this.owner); };

		this.decensorConfig.add(this.decensorConfigBellandy = new global.KAGFlagMenuItem(this.owner, "Bellandy", 1, decensorConfigFlag, "bellandy", true));
		this.decensorConfigBellandy.restartCondition = this.decensorConfigBellandy.onlyScenarioRestartCondition;
		this.decensorConfigBellandy.afterCallback = function(sender) { global.updateDecensorConfig(this.owner); };

		this.decensorConfig.add(this.decensorConfigBishopcruzAnonymous = new global.KAGFlagMenuItem(this.owner, "BishopCruz + Anonymous", 1, decensorConfigFlag, "bishopcruz_anonymous", true));
		this.decensorConfigBishopcruzAnonymous.restartCondition = this.decensorConfigBishopcruzAnonymous.onlyScenarioRestartCondition;
		this.decensorConfigBishopcruzAnonymous.afterCallback = function(sender) { global.updateDecensorConfig(this.owner); };

		this.decensorConfig.add(this.decensorConfigBishopcruz = new global.KAGFlagMenuItem(this.owner, "BishopCruz", 1, decensorConfigFlag, "bishopcruz", true));
		this.decensorConfigBishopcruz.restartCondition = this.decensorConfigBishopcruz.onlyScenarioRestartCondition;
		this.decensorConfigBishopcruz.afterCallback = function(sender) { global.updateDecensorConfig(this.owner); };

		this.decensorConfig.add(this.decensorConfigMixed = new global.KAGFlagMenuItem(this.owner, __t("ミックス(&M)"), 1, decensorConfigFlag, "mixed", true));
		this.decensorConfigMixed.restartCondition = this.decensorConfigMixed.onlyScenarioRestartCondition;
		this.decensorConfigMixed.afterCallback = function(sender) { global.updateDecensorConfig(this.owner); };
@endif
		this.updateCurrentState();
	}

	function addSeperationLine(menu)
	{
		menu.add(new global.MenuItem(this, "-"));
	}

	function updateCurrentState()
	{
		var items = [this.hCensoredMenuItem, this.ecchiUncensoredMenuItem, this.hUncensoredMenuItem, this.hDecensoredMenuItem];
		for (var i = 0, internal_forloop_count = items.count; i < internal_forloop_count; i += 1) {
			if (items[i].checked) {
				this.currentState = items[i];
				break;
			}
		}

		// Protect against invalid state (no item selected)
		if (typeof(this.currentState) !== 'Object')
			this.currentState = this.hCensoredMenuItem;

		this.loadCurrentState();
	}

	function beforeCallback(sender)
	{
		if (sender == this.hCensoredMenuItem && global.isHScene()) {
			global.System.inform(global.__("Hシーン中はHシーンをオフにできません。 シーンの後で、またはメインメニューから設定をもう一度変更してみてください。"));
			return false;
		}

		this.previouslyFullyCensored = global.get_fullyCensored(this.owner);
		return true;
	}

	function afterCallback(sender)
	{
		if (this.previouslyFullyCensored && !global.get_fullyCensored(this.owner)) {
			this.unloadFullyCensored(this.currentState);
		}

		if (sender === this.matureMenuItem) {
			(global.KAGFlagFolderMenuItem.afterCallback incontextof sender)(sender);
		} else {
			this.currentState.unloadAllFolders();
			this.currentState = sender;
			this.loadCurrentState();
		}
	}

	function loadCurrentState()
	{
		this.currentState.loadAllFolders();

		if (!this.previouslyFullyCensored && global.get_fullyCensored(this.owner)) {
			this.loadFullyCensored(this.currentState);
		}

		global.updateDecensorConfig(this.owner);
	}

	function loadFullyCensored(sender)
	{
		var patches_arr = [
			[sender.patchName, global.fullyCensoredFolderName],
			[global.languagePatchName(global.japaneseLanguage), global.fullyCensoredFolderName],
			(this.owner.sflags.language !== void && this.owner.sflags.language !== global.japaneseLanguage) ? [global.languagePatchName(this.owner.sflags.language), global.fullyCensoredFolderName] : void,
		];
		global.load_patches(patches_arr);
	}

	function unloadFullyCensored(sender)
	{
		var patches_arr = [
			(this.owner.sflags.language !== void && this.owner.sflags.language !== global.japaneseLanguage) ? [global.languagePatchName(this.owner.sflags.language), global.fullyCensoredFolderName] : void,
			[global.languagePatchName(global.japaneseLanguage), global.fullyCensoredFolderName],
			[sender.patchName, global.fullyCensoredFolderName],
		];
		global.unload_patches(patches_arr);
	}
}

class KAGMessageWindowMenuItem extends global.KAGMenuItem
{
	var wideMessageWindowMenuItem;
	var mobileMessageWindowMenuItem;
	var mobileBreakGlyphsMenuItem;

	var mobileBreakGlyphsFlag;
	var mobileWindowFlag;
	var wideWindowFlag;

	function KAGMessageWindowMenuItem(window, name)
	{
		super.KAGMenuItem(window, name, 0, void, false);
		this.addChildren();
	}

	function addChildren()
	{
		this.mobileBreakGlyphsFlag = new global.GameFlag(this.owner, this.owner.sflags, global.mobileBreakGlyphsFlagName, false);
		this.add(this.mobileBreakGlyphsMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("携帯端末用カーソル(&B)"),, this.mobileBreakGlyphsFlag, global.mobileBreakGlyphsPatchName, global.mobileBreakGlyphsFolderName,,,true));
		this.mobileBreakGlyphsMenuItem.restartCondition = this.mobileBreakGlyphsMenuItem.onlyScenarioRestartCondition;

		this.mobileWindowFlag = new global.GameFlag(this.owner, this.owner.sflags, global.mobileWindowFlagName, false);
		this.add(this.mobileMessageWindowMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("携帯用テキスト画面(&M)"),, this.mobileWindowFlag, global.mobileWindowPatchName, global.mobileWindowFolderName,,,true));
		this.mobileMessageWindowMenuItem.restartCondition = this.mobileMessageWindowMenuItem.onlyScenarioRestartCondition;
		this.mobileMessageWindowMenuItem.afterCallback = this.afterCallback;

		this.wideWindowFlag = new global.GameFlag(this.owner, this.owner.sflags, global.wideWindowFlagName, true);
		this.add(this.wideMessageWindowMenuItem = new global.KAGFlagFolderMenuItem(this.owner, global.__t("ワイドモードで4:3のメッセージウィンドウ(&W)"),, global.inverseFlag(this.wideWindowFlag), global.wideWindowPatchName,, global.wideWindowFolderName,,true));
		this.wideMessageWindowMenuItem.restartCondition = this.wideMessageWindowMenuItem.onlyScenarioRestartCondition;
		this.wideMessageWindowMenuItem.afterCallback = this.afterCallback;
		this.wideMessageWindowMenuItem.evaluateFlag = function(sender) { return sender.defaultEvaluateFlag(sender) || !this.owner.wideScreen; };
		this.wideMessageWindowMenuItem.initialize(); // need to reinitialize since overriding evaluateFlag

		this.updateMobileWide();
	}

	function updateMobileWide() {
		var patches_arr = [[global.wideMobileWindowPatchName, global.wideMobileWindowFolderName]];
@if(HD_MODE)
		global.addHdPaths(this.owner, patches_arr, global.wideMobileWindowPatchName, global.wideMobileWindowFolderName) if this.owner.isHd;
@endif
		if (this.wideWindowFlag.value && this.mobileWindowFlag.value && this.owner.wideScreen) {
			global.load_patches(patches_arr);
		} else {
			global.unload_patches(patches_arr);
		}
	}

	function afterCallback()
	{
		this.mobileMessageWindowMenuItem.defaultAfterCallback(this.mobileMessageWindowMenuItem);
		this.wideMessageWindowMenuItem.defaultAfterCallback(this.wideMessageWindowMenuItem);
		this.updateMobileWide();
	}
}

class LoadScenarioMenuItem extends global.KAGMenuItem
{
	var scenarioFileName;
	var labelName;

	function LoadScenarioMenuItem(window, name, scenarioFileName, labelName=void)
	{
		super.KAGMenuItem(window, name, 0, this.onLoadScenarioMenuItemClick, false);
		this.scenarioFileName = scenarioFileName;
		this.labelName = labelName === void? labelName : "*" + labelName;
	}

	function onLoadScenarioMenuItemClick(sender)
	{
		if (typeof(global.titlemenu_object) === "Object") {
			global.titlemenu_object.menulayer.goLabel(this.scenarioFileName, this.labelName);
		} else {
			this.owner.processCall(this.scenarioFileName, this.labelName);
		}
	}
}

global.addEnableDisableRestartMenuFunctions = function()
{
	this.restart_menu_state = true;
	this.restart_menu_state_stack = [];
	this.restart_menu_items = [];
	this.pushRestartMenuState = function()
	{
		this.restart_menu_state_stack.add(this.restart_menu_state);
	};

	this.popRestartMenuState = function()
	{
		if (this.restart_menu_state_stack.count > 0)
		{
			this.setRestartMenuState(this.restart_menu_state_stack[this.restart_menu_state_stack.count - 1]);
			this.restart_menu_state_stack.erase(this.restart_menu_state_stack.count - 1);
		}
	};

	this.setRestartMenuState = function(state)
	{
		this.restart_menu_state = state;
		var restart_menu_items = this.restart_menu_items;
		for (var i = 0; i < restart_menu_items.count; i += 1)
		{
			var item = restart_menu_items[i];
			item.enabled = state;
		}
		if (typeof(this.languageMenu) === "Object")
		{
			this.languageMenu.enabled = state;
			// The following will cause a rebuild of the menu
			this.languageMenu.group = this.languageMenu.group;
		}
	};

	this.enableRestartMenus = function()
	{
		this.setRestartMenuState(true);
	};

	this.disableRestartMenus = function()
	{
		this.setRestartMenuState(false);
	};
};

global.prepareRestartMenuFunctions = function()
{
	this.disableRestartMenus();
};

global.addPatchMenu = function()
{
	(global.addEnableDisableRestartMenuFunctions incontextof this)();
	this.menu.insert(this.patchMenu = new global.KAGMenuItem(this, global.__t("パッチ(&P)"), 0, void, false), global.getPatchMenuIndex(this));
	(global.addCensorMenu incontextof this)(this.patchMenu, global.__t("検閲(&C)"));
	(global.addVoiceMenu incontextof this)(this.patchMenu);
	(global.addMovieMenu incontextof this)(this.patchMenu);

	(global.addDevelopmentMenu incontextof this)();
	(global.addConductorVerbosityMenu incontextof this)();
@if(ZOOM_WINDOW)
	(global.addWindowSizeMenu incontextof this)(this.displayMenu);
	if (this.isPseudoMode())
	{
		(global.addFullScreenMenu incontextof this)(this.displayMenu);
	}
@endif
@if(HD_MODE)
	(global.addHdMenu incontextof this)(this.displayMenu);
@endif
	(global.addGraphicUsageMenu incontextof this)(this.displayMenu);

	(global.addOptionsMenu incontextof this)(this.patchMenu);
	(global.addPatchMenuItems incontextof this)(this.patchMenu);
@if(GAME_FATE||GAME_FHAT)
	(global.addMovieContentMenu incontextof this)(this.patchMenu);
@endif
	this.patchMenu.add(new global.MenuItem(this, "-"));
	(global.addActionsMenu incontextof this)(this.patchMenu);
	(global.prepareRestartMenuFunctions incontextof this)();
};

global.addDevelopmentMenu = function()
{
	this.menu.add(this.devMenuItem = new global.KAGMenuItem(this, "&Development", 0, void, false));
	this.devMenuItem.visible = global.devMode || global.devMode2;
	(global.addDevelopmentMenuItems incontextof this)(this.devMenuItem);
	this.devMenuItem.add(this.throwExceptionItem = new global.KAGMenuItem(this, "Throw Exception", 1, function(sender) { throw new global.Exception("This is a test Exception."); }, false));
	this.devMenuItem.add(this.throwConductorExceptionItem = new global.KAGMenuItem(this, "Throw ConductorException", 1, function(sender) { throw new global.ConductorException("This is a test ConductorException."); }, false));
	this.devMenuItem.add(this.accessNullPointerItem = new global.KAGMenuItem(this, "Access null pointer", 1, function(sender) { global.System.nullpo(); }, false));
	global.git_base_path = global.Storages.getFullPath(".");
	if (global.git_base_path.indexOf(">") === -1)
	{
		global.git_base_path = global.Storages.getLocalName(global.git_base_path);
	}
	else
	{
		global.git_base_path = global.System.exePath + "/content-data/";
		global.git_base_path = global.Storages.getLocalName(global.git_base_path);
	}
	this.devMenuItem.add(this.openCommandPromptInProjectDirectory = new global.KAGMenuItem(this, "Open command prompt in project directory", 1, function(sender) { global.System.shellExecute("cmd.exe", "/k cd " + ('"%s"').sprintf(global.git_base_path)); }, false));
	this.devMenuItem.add(this.gitCheckoutDashDashCurrentDirectory = new global.KAGMenuItem(this, "git checkout -- .", 1, function(sender) { global.build_exec_command_line("git.exe", ["-C", global.git_base_path, "checkout", "--", "."], false, false); }, false));
	this.devMenuItem.add(this.gitPullOriginMaster = new global.KAGMenuItem(this, "git pull origin master", 1, function(sender) { global.build_exec_command_line("git.exe", ["-C", global.git_base_path, "pull", "origin", "master"], false, false); }, false));
};

global.addConductorVerbosityMenu = function()
{
	this.debugMenu.add(this.debugLevelNoneMenuItem = new global.KAGMenuItem(this, global.__t("デバッグレベル:なし"), 2,
		this.onDebugLevelNoneMenuItemClick, false));
	this.debugLevelNoneMenuItem.checked = this.debugLevel === global.tkdlNone;

	this.debugMenu.add(this.debugLevelSimpleMenuItem = new global.KAGMenuItem(this, global.__t("デバッグレベル:シンプル"), 2,
		this.onDebugLevelSimpleMenuItemClick, false));
	this.debugLevelSimpleMenuItem.checked = this.debugLevel === global.tkdlSimple;

	this.debugMenu.add(this.debugLevelVerboseMenuItem = new global.KAGMenuItem(this, global.__t("デバッグレベル:詳細"), 2,
		this.onDebugLevelVerboseMenuItemClick, false));
	this.debugLevelVerboseMenuItem.checked = this.debugLevel === global.tkdlVerbose;
};

global.addMovieContentMenu = function(patchMenu)
{
	var flagDefault = "";
	var insertIndex = 0;
@if(GAME_FATE)
	flagDefault = "realta";
	insertIndex = 2;
@endif
@if(GAME_FHAT)
	flagDefault = "classic";
	insertIndex = 1;
@endif

	var movieContentFlag = new global.GameFlag(this, this.sflags, "gmovie", global.get_opPatchExists(this) ? "mixed" : flagDefault);
	// Todo: Set sflags.gmovie and menu state to realta when no OP patch exists
	patchMenu.insert(this.movieContentMenuItem = new global.KAGMenuItem(this, global.__t("ムービーコンテンツ"), 0, void, false), insertIndex);
	this.movieContentMenuItem.add(this.classicMovieContentMenuItem = new global.KAGFlagMenuItem(this,   global.__t("クラシック(&C)"),    1, movieContentFlag, "classic"));
@if(GAME_FATE)
	this.classicMovieContentMenuItem.disableIfPatchDoesntExist(global.opPatchName);
	this.movieContentMenuItem.add(this.ps2MovieContentMenuItem = new global.KAGFlagMenuItem(this, global.__t("レアルタ・ヌア(&R)"), 1, movieContentFlag, "realta"));
@endif
	this.movieContentMenuItem.add(this.vitaMovieContentMenuItem = new global.KAGFlagMenuItem(this, global.__t("&Vita"), 1, movieContentFlag, "vita"));
	this.vitaMovieContentMenuItem.disableIfPatchDoesntExist(global.opPatchName);
	this.movieContentMenuItem.add(this.mixedMovieContentMenuItem = new global.KAGFlagMenuItem(this,   global.__t("ミックス(&M)"),    1, movieContentFlag, "mixed"));
	this.mixedMovieContentMenuItem.disableIfPatchDoesntExist(global.opPatchName);
	this.movieContentMenuItem.add(new global.MenuItem(this, "-"));
	this.movieContentMenuItem.add(this.classicMovieContentMenuItem = new global.KAGFlagMenuItem(this,   global.__t("ゲーム中にムービーをスキップする(&K)"),    1, movieContentFlag, "skip"));
};

global.addVoiceMenu = function(patchMenu)
{
	var unmatchedVoiceFlag = new global.GameFlag(this, this.sflags, "playUnmatchedVoices", true);
	var playUnusedVoicesFlag = new global.GameFlag(this, this.sflags, "unusedVoices", true);
	var customWaitvoiceFlag = new global.GameFlag(this, this.sflags, "customWaitvoice", true);
	var fadeBgmWithVoiceFlag = new global.GameFlag(this, this.scflags, "fadeBgmWithVoice", false);
	var disableStopVoiceWithClickFlag = new global.GameFlag(this, this.scflags, "disableStopVoiceWithClick", false);

	patchMenu.add(this.voiceMenuItem = new global.KAGMenuItem(this, global.__t("ボイス(&V)"), 0, void, false));
	this.voiceMenuItem.add(this.playUnmatchedVoicesMenuItem = new global.KAGFlagMenuItem(this, global.__t("不一緻なボイスを再生する(&M)"),, unmatchedVoiceFlag));
	this.voiceMenuItem.add(this.playUnusedVoicesMenuItem = new global.KAGFlagMenuItem(this, global.__t("未使用ボイスを再生する(&U)"),, playUnusedVoicesFlag));
	this.voiceMenuItem.add(this.customWaitvoiceMenuItem = new global.KAGFlagMenuItem(this, global.__t("あつらえのWait-Voiceタグを使用する(&W)"),, customWaitvoiceFlag));
@if(FADE_BGM_WITH_VOICE==1)
	this.voiceMenuItem.add(this.fadeBgmWithVoiceMenuItem = new global.KAGFlagMenuItem(this, global.__t("ボイス再生中に&BGM音量を下げる"),, fadeBgmWithVoiceFlag));
@endif
	this.voiceMenuItem.add(this.disableStopVoiceWithClickMenuItem = new global.KAGFlagMenuItem(this, global.__t("クリックすると現在のボイスが停止しません(&V)"),, disableStopVoiceWithClickFlag));

	(global.addVoiceMenuItems incontextof this)(this.voiceMenuItem);
};

global.addMovieMenu = function(patchMenu)
{
	var subbedVideosFlag = new global.GameFlag(this, this.sflags, global.subbedVideosFlagName, true);
	var forceMpvPlaybackFlag = new global.GameFlag(this, this.sflags, "forceMpvPlayback", false);

	patchMenu.add(this.movieMenuItem = new global.KAGMenuItem(this, global.__t("ムービー(&M)"), 0, void, false));
	this.movieMenuItem.add(this.subbedVideosMenuItem = new global.KAGFlagFolderMenuItem(this, global.__t("ムービー再生中に字幕を表示する(&S)"),, subbedVideosFlag,,global.videosFolderName));
	this.movieMenuItem.add(this.forceMpvPlaybackMenuItem = new global.KAGFlagMenuItem(this, global.__t("mpvを使用して強制的に動画を再生する"),,forceMpvPlaybackFlag));
	this.forceMpvPlaybackMenuItem.enabled = (typeof(global.playVideoMPV) === "Object");

	var movieQualityFlag = new global.GameFlag(this, this.sflags, "movieQuality", "auto");

	this.movieMenuItem.add(this.movieQualityMenuItem = new global.KAGMenuItem(this, global.__t("ムービーの品質(&Q)"), 0, void, false));
	this.movieQualityMenuItem.add(this.movieQualityAutoMenuItem = new global.KAGFlagMenuItem(this, global.__t("自動(&A)"), 1, movieQualityFlag, "auto"));
	this.movieQualityMenuItem.add(this.movieQualityHighMenuItem = new global.KAGFlagMenuItem(this, global.__t("高い(&H)"), 1, movieQualityFlag, "high"));
	this.movieQualityMenuItem.add(this.movieQualityLowMenuItem = new global.KAGFlagMenuItem(this, global.__t("低い(&L)"), 1, movieQualityFlag, "low"));
};

global.addOptionsMenu = function(patchMenu)
{
	var historyTitleFlag = new global.GameFlag(this, this.sflags, "historyTitle", false);
	var showLogoFlag = new global.GameFlag(this, this.sflags, "showLogo", true);
	var showHoverTipsFlag = new global.GameFlag(this, this.sflags, "showHoverTips", true);
	var customVoiceReplayFlag = new global.GameFlag(this, this.sflags, "customVoiceReplay", false);
	var vitaMovieMenuFlag = new global.GameFlag(this, this.sflags, "movieMenuPatch", global.get_opPatchExists(this));
	var vitaAboutFlag = new global.GameFlag(this, this.sflags, "aboutPatch", global.get_vitaPatchExists(this));
	var moveMouseWithControllerFlag = new global.GameFlag(this, this.sflags, "moveMouseWithController", true);
	var copyLastTextToClipboardFlag = new global.GameFlag(this, this.sflags, "copyLastTextToClipboard", false);
	var reduceFullScreenFlashEffectsFlag = new global.GameFlag(this, this.sflags, "reduceFullScreenFlashEffects", false);

	patchMenu.add(this.patchOptionsMenuItem = new global.KAGMenuItem(this, global.__t("設定(&O)"), 0, void, false));

	(global.addGalleryMenu incontextof this)(this.patchOptionsMenuItem);
	this.patchOptionsMenuItem.add(this.historyTitleMenuItem = new global.KAGFlagMenuItem(this, global.__t("メッセージ歴史でシーンのタイトルを表示する(&H)"),, historyTitleFlag));
	this.patchOptionsMenuItem.add(this.customVoiceReplayIconsMenuItem = new global.KAGFlagMenuItem(this, global.__t("あつらえのボイス再生アイコンを使用する(&R)"),, customVoiceReplayFlag));
	this.patchOptionsMenuItem.add(new global.MenuItem(this, "-"));

@if(HD_MODE)
	(global.addMessageWindowMenu incontextof this)(this.patchOptionsMenuItem);
	this.patchOptionsMenuItem.add(new global.MenuItem(this, "-"));
@endif

	this.patchOptionsMenuItem.add(this.vitaMovieMenuItem = new global.KAGFlagFolderMenuItem(this, global.__t("Vitaのムービーメニュ(&M)"),, vitaMovieMenuFlag, global.opPatchName, "override",, false));
	this.vitaMovieMenuItem.disableIfPatchDoesntExist(global.opPatchName);
	this.patchOptionsMenuItem.add(this.vitaAboutMenuItem = new global.KAGFlagMenuItem(this, global.__t("Vitaの「このスフとについて」ページ(&A)"),, vitaAboutFlag));
	(global.addVitaMenuItems incontextof this)(this.patchOptionsMenuItem);

	this.patchOptionsMenuItem.add(new global.MenuItem(this, "-"));
	this.patchOptionsMenuItem.add(this.showLogoMenuItem = new global.KAGFlagMenuItem(this, global.__t("起動時にTYPE-MOONロゴを表示する"),, showLogoFlag));
	this.patchOptionsMenuItem.add(this.showHoverTipsMenuItem = new global.KAGFlagMenuItem(this, global.__t("ツールチップを表示する"),, showHoverTipsFlag));
	this.patchOptionsMenuItem.add(this.moveMouseWithControllerMenuItem = new global.KAGFlagMenuItem(this, global.__t("コントローラーでマウスを動かす"),, moveMouseWithControllerFlag));
	this.patchOptionsMenuItem.add(this.copyLastTextToClipboardMenuItem = new global.KAGFlagMenuItem(this, global.__t("最後のテキストをクリップボードにコピー"),, copyLastTextToClipboardFlag));
	this.patchOptionsMenuItem.add(this.reduceFullScreenFlashEffectsMenuItem = new global.KAGFlagMenuItem(this, global.__t("全画面フラッシュ効果を減らす"),, reduceFullScreenFlashEffectsFlag));
	(global.addOptionsMenuItems incontextof this)(this.patchOptionsMenuItem);
};

global.addActionsMenu = function(patchMenu)
{
	var savedataRepairFlag = new global.GameFlag(this, this.sflags, "savedataRepair", false);

	patchMenu.add(this.patchActionsMenuItem = new global.KAGMenuItem(this, global.__t("ツール"), 0, void, false));
	this.patchActionsMenuItem.add(this.engineConfigurationItem = new global.KAGMenuItem(this, global.__t("エンジン構成ダイアログを開く"), 1, function() { global.showEngineConfigureDialog(); },false));
	this.patchActionsMenuItem.add(this.openSavedataDirMenuItem = new global.KAGMenuItem(this, global.__t("保存データディレクトリを開く"), 1, function(sender) { global.open_savedata_dir(sender.owner); },false));
	this.patchActionsMenuItem.add(this.saveTroubleshootingDataAndOpenFolderLocationMenuItem = new global.KAGMenuItem(this, global.__t("トラブルシューティングデータを保存する"), 1, function() { global.save_troubleshooting_data_and_open_folder_location(); },false));
	this.patchActionsMenuItem.add(this.savedataRepairMenuItem = new global.KAGFlagMenuItem(this, global.__t("修復保存データモードを有効にする"),, savedataRepairFlag));
};

global.addFullScreenMenu = function(displayMenu)
{
	displayMenu.add(new global.MenuItem(this, "-"));

	displayMenu.add(this.fullscreenMenu = new global.KAGMenuItem(this, global.__t("フルスクリーン時の拡大表示(&M)"), 0, void, false));

		this.fullscreenMenu.add(this.innerMagnifyMenuItem = new global.KAGMenuItem(this, global.__t("モニタ内にフィットさせる(&I)"), 1,
			this.onInnerMagnifyMenuItemClick, false));

		this.fullscreenMenu.add(this.outerMagnifyMenuItem = new global.KAGMenuItem(this, global.__t("モニタいっぱいに拡大する(&O)"), 1,
			this.onOuterMagnifyMenuItemClick, false));

		this.fullscreenMenu.add(this.noneMagnifyMenuItem = new global.KAGMenuItem(this, global.__t("拡大しない(&N)"), 1,
			this.onNoneMagnifyMenuItemClick, false));
};

global.addWindowSizeMenu = function(displayMenu)
{
	displayMenu.add(new global.MenuItem(this, "-"));

		displayMenu.add(this.windowSizeMenu = new global.KAGMenuItem(this, global.__t("ウィンドウ内部のサイズ指定(&S)"), 0, void, false));

			for (var i = 0; i < global.window_scaling_factors.count; i += 1)
			{
				var item = global.window_scaling_factors[i];
				if (typeof(item) !== "Real")
				{
					continue;
				}
				var item_width = (global.originalResWidth * item) | 0;
				var item_height = (global.originalResHeight * item) | 0;
				var windowMenuItemName = "window%dMenuItem".sprintf(item_width);
				var windowMenuItemText = "";
				var windowMenuItemEnabled = true;
				var windowMenuItemCaptionCallback = function(sender)
				{
					var curstr = sender.originalCaption;
					if (sender.window_scale === 1.0)
					{
						curstr += " " + global.__("(デフォルト)");
					}
					return curstr;
				};

@if(HD_MODE)
				windowMenuItemText = "%.2fx".sprintf(item);
@endif
@if(!HD_MODE)
				windowMenuItemText = "%dx%d".sprintf(item_width, item_height);
@endif

				this.windowSizeMenu.add(this[windowMenuItemName] = new global.KAGMenuItem(this, windowMenuItemText, 1, function(sender) { sender.owner.onWindowSizeMenuItemClick(,sender.window_width); }, false));
				this[windowMenuItemName].window_width = item_width;
				this[windowMenuItemName].window_scale = item;
				this[windowMenuItemName].captionArg = windowMenuItemCaptionCallback;
			}

			this.windowSizeMenu.add(new global.MenuItem(this, "-"));

			this.windowSizeMenu.add(this.windowResizeableMenuItem = new global.KAGMenuItem(this, global.__t("サイズを固定する"), 0,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,0); }, false));

			this.windowSizeMenu.add(this.limitWindowSizeMenuItem = new global.KAGMenuItem(this, global.__t("画面サイズに限る"), 0,
				function(sender) { sender.owner.onLimitWindowSizeMenuItemClick(); }, false));
};


global.getRatioName = function(wTemp,hTemp)
{
	var primeList = [29, 23, 19, 17, 13, 11, 7, 5, 3, 2];
	var bFound = true;

	while (bFound == true)
	{
		bFound = false;

		for (var i = 0, internal_forloop_count = primeList.count; i < internal_forloop_count; i += 1)
		{
			var prime = primeList[i];

			if ((wTemp % prime == 0) && (hTemp % prime == 0))
			{
				wTemp = global.Math.round(wTemp/prime) | 0;
				hTemp = global.Math.round(hTemp/prime) | 0;
				bFound = true;
				break;
			}

			if (wTemp == 16)
			{
				break;
			}
		}
	}

	return wTemp+":"+hTemp;
};

global.addHdMenu = function(displayMenu)
{
	var wideResolutions = %[ global.__t("ワイド(16:9)(&W)") => global.standardWideRatio];

	var wideDevResolutions = [];
	if (global.devMode)
	{
		wideDevResolutions = [[1,1], [5,4], [16,10], [20,10], [21,9]];
	}

	displayMenu.add(new global.MenuItem(this, "-"));

	displayMenu.add(this.qualityMenu = new global.KAGMenuItem(this, global.__t("画質(&Q)"), 0, void, false));
	this.restart_menu_items.add(this.qualityMenu);

	for (var i = 0; i < global.scaleFactors.count; i += 1)
	{
		var hqMenuItemName = (global.scaleFactors[i] === 1) ? "lqMenuItem" : ("hq%.1fMenuItem".sprintf(global.scaleFactors[i]).replace(/\./g, "_"));
		var hqMenuItemText = "";
		var hqMenuItemEnabled = true;

		if (global.scaleFactors[i] <= 2.4 || global.System.exeBits == 64)
		{
			if (global.scaleFactors[i] === 1)
			{
				hqMenuItemText = global.__t("低い(&L)");
			}
			else if (global.patchExists(global.hdPatchesNames[i]))
			{
				hqMenuItemText = global.__t("高いx%.1f(&H)");
			}
			else
			{
				hqMenuItemText = global.__t("高いx%.1f(&H) — パッチ欠落");
				hqMenuItemEnabled = false;
			}
		}
		else
		{
			hqMenuItemText = global.__t("高いx%.1f(&H) — x64のみ");
			hqMenuItemEnabled = false;
		}

		this.qualityMenu.add(this[hqMenuItemName] = new global.KAGMenuItem(this, hqMenuItemText, 1, function(sender) { global.onQualityMenuItemClick(sender); }, false));
		this[hqMenuItemName].enabled = hqMenuItemEnabled;
		this[hqMenuItemName].hdAssetScaleFactor = global.scaleFactors[i];
		this[hqMenuItemName].captionArg = this[hqMenuItemName].hdAssetScaleFactor;
		this[hqMenuItemName].checked = this.hdAssetScaleFactor === global.scaleFactors[i];
	}

	displayMenu.add(this.renderScaleMenu = new global.KAGMenuItem(this, global.__t("レンダリングスケール(&R)"), 0, void, false));
	this.restart_menu_items.add(this.renderScaleMenu);

	for (var i = 0; i < global.renderScaleFactors.count; i += 1)
	{
		var renderScaleMenuItemName = "renderScale%.1fMenuItem".sprintf(global.renderScaleFactors[i]).replace(/\./g, "_");
		var renderScaleMenuItemText = "";
		var renderScaleMenuItemEnabled = true;

		if (global.renderScaleFactors[i] === 1)
		{
			renderScaleMenuItemText = global.__t("低い(&L)");
		}
		else
		{
			renderScaleMenuItemText = global.__t("高いx%.1f(&H)");
		}

		this.renderScaleMenu.add(this[renderScaleMenuItemName] = new global.KAGMenuItem(this, renderScaleMenuItemText, 1, function(sender) { global.onQualityMenuItemClick(sender); }, false));
		this[renderScaleMenuItemName].enabled = renderScaleMenuItemEnabled;
		this[renderScaleMenuItemName].hdRenderScaleFactor = global.renderScaleFactors[i];
		this[renderScaleMenuItemName].captionArg = this[renderScaleMenuItemName].hdRenderScaleFactor;
		this[renderScaleMenuItemName].checked = this.hdRenderScaleFactor === global.renderScaleFactors[i];
	}

	displayMenu.add(this.wideMenu = new global.KAGMenuItem(this, global.__t("アスペクト比(&A)"), 0, void, false));
	this.restart_menu_items.add(this.wideMenu);

	this.wideMenu.add(this.notWideMenuItem = new global.KAGMenuItem(this, global.__t("基準(4:3)(&S)"), 1,
		function(sender) { global.onWideMenuItemClick(sender,'standard'); }, false));
	this.notWideMenuItem.checked = !this.wideScreen;

	if (global.get_systemRatio() > global.cubicRatio && global.get_systemRatio() != global.standardWideRatio) {
		this.wideMenu.add(this.wideMenuItem = new global.KAGMenuItem(this, global.__t("デスクトップと同じ(&M) (%s)"), 1,
			function(sender) { global.onWideMenuItemClick(sender,'wide'); }, false));
		this.wideMenuItem.captionArg = [global.getRatioName(global.System.screenWidth, global.System.screenHeight)];
		this.wideMenuItem.checked = this.wideScreen && this.isAutoWide;
	}

	var keys = [];
	keys.assign(wideResolutions);
	for (var i = 0, internal_forloop_count = keys.count; i < internal_forloop_count; i += 2) {
		var key = keys[i];
		var ratio = wideResolutions[key];
		var wideMenuItemName = "wideRatio"+key.replace(/[:&\() ]/g, "")+"MenuItem";
		this.wideMenu.add(this[wideMenuItemName] = new global.KAGMenuItem(this, key, 1, function(sender) { global.onWideMenuItemClick(sender, sender.ratio); }));
		this[wideMenuItemName].ratio = ratio;
		if (global.floatEquals(this.wideRatio, ratio)) {
			this[wideMenuItemName].checked = true;
		}
	}
	invalidate keys;

@if(CROP_MODE)
	this.wideMenu.add(this.wideCroppedMenuItem = new global.KAGMenuItem(this, "Wide (&cropped)", 1,
		function(sender) { global.onWideMenuItemClick(sender,'standard',true); }, false));
@endif

	if (global.devMode) {
		this.wideMenu.add(new global.MenuItem(this, "-"));

		for (var i = 0, internal_forloop_count = wideDevResolutions.count; i < internal_forloop_count; i += 1) {
			var wMarker = wideDevResolutions[i][0];
			var hMarker = wideDevResolutions[i][1];
			var wideMenuItemName = "wideRatio" + wMarker + hMarker + "MenuItem";

			this.wideMenu.add(this[wideMenuItemName] = new global.KAGMenuItem(this, global.__t("デバッグ (%d:%d)"), 1, function(sender) { global.onWideMenuItemClick(sender, sender.ratio); }));
			this[wideMenuItemName].captionArg = [wMarker, hMarker];
			this[wideMenuItemName].ratio = wMarker/hMarker;
			if (global.floatEquals(this.wideRatio, wMarker/hMarker)) {
				this[wideMenuItemName].checked = true;
			}
		}
	}

	if (typeof(global.scale_types_list) === "Object")
	{
		var upscaleMethodDefault = "stCubic";

		var upscaleMethodFlag = new global.GameFlag(this, this.sflags, "upscalemethod", upscaleMethodDefault);

		if (!global.has_scale_type(upscaleMethodFlag.value))
		{
			upscaleMethodFlag.value = upscaleMethodDefault;
		}

		var upscaleMethodCallback = function(sender)
		{
			global.set_scale_type(sender.flag.value);
		};

		displayMenu.add(this.upscaleMethodMenu = new global.KAGMenuItem(this, global.__t("拡大メソッド(&U)"), 0, void, false));
		var upscaleMethodMenu = this.upscaleMethodMenu;
		var scale_types_list = global.scale_types_list;
		for (var i = 0; i < scale_types_list.count; i += 1)
		{
			var scale_type = scale_types_list[i];
			if (scale_type === void)
			{
				continue;
			}
			if (scale_type === "-")
			{
				this.upscaleMethodMenu.add(new global.MenuItem(this, "-"));
				continue;
			}
			var upscaleMethodMenuItemName = "upscaleMethod_%s_MenuItem".sprintf(scale_type[0]);
			upscaleMethodMenu.add(this[upscaleMethodMenuItemName] = new global.KAGFlagMenuItem(this, scale_type[3], 1, upscaleMethodFlag, scale_type[0]));
			this[upscaleMethodMenuItemName].afterCallback = upscaleMethodCallback;
		}
		if (typeof(this.upscaleMethod_stCubic_MenuItem) === "Object")
		{
			upscaleMethodCallback(this.upscaleMethod_stCubic_MenuItem);
		}
	}

};

global.addGraphicUsageMenu = function(displayMenu)
{
	var fpsLimitDefault = "60";
	var multiThreadDefault = 0;

	var fpsLimitFlag = new global.GameFlag(this, this.sflags, "contfreq", fpsLimitDefault);
	var multiThreadDrawFlag = new global.GameFlag(this, this.sflags, "drawthread", multiThreadDefault);

	var fpsLimitCallback = function(sender)
	{
		if (sender.flag.value === "-1")
		{
			{
				sender.owner.waitVSync = true;
			}
			global.System.setArgument("-contfreq", "0");
		}
		else
		{
			{
				sender.owner.waitVSync = false;
			}
			global.System.setArgument("-contfreq", sender.flag.value);
		}
	};

	displayMenu.add(new global.MenuItem(this, "-"));

	displayMenu.add(this.fpsLimitMenuItem = new global.KAGMenuItem(this, global.__t("最大フレームレート(&M)"), 0, void, false));
	var fps_limit_values = global.fps_limit_values;
	var fps_limit_shortcuts = global.fps_limit_shortcuts;
	for (var i = 0; i < fps_limit_values.count; i += 1)
	{
		var fps_limit_value = fps_limit_values[i];
		if (fps_limit_value === void)
		{
			continue;
		}
		fps_limit_value += "";
		if (fps_limit_value === "-")
		{
			this.fpsLimitMenuItem.add(new global.MenuItem(this, "-"));
			continue;
		}
		var fps_limit_shortcut = fps_limit_shortcuts[fps_limit_value];
		if (fps_limit_shortcut === void)
		{
			fps_limit_shortcut = fps_limit_value;
		}
		var fps_limit_text = global.__t("%sフレーム/秒");
		var fpsLimitMenuItemName = "fpsLimit%sMenuItem".sprintf(fps_limit_value);
		if (fps_limit_value === "-1")
		{
			fps_limit_text = global.__t("垂直同期待ち(&V)");
			fpsLimitMenuItemName = "fpsLimitVsyncMenuItem";
		}
		else if (fps_limit_value === "0")
		{
			fps_limit_text = global.__t("制限なし(&N)");
			fpsLimitMenuItemName = "fpsLimit00MenuItem";
		}
		this.fpsLimitMenuItem.add(this[fpsLimitMenuItemName] = new global.KAGFlagMenuItem(this, fps_limit_text, 1, fpsLimitFlag, fps_limit_value));
		if (fps_limit_text.indexOf("%") !== -1)
		{
			this[fpsLimitMenuItemName].captionArg = fps_limit_shortcut;
		}
		this[fpsLimitMenuItemName].afterCallback = fpsLimitCallback;
	}
	if (typeof(this.fpsLimitVsyncMenuItem) === "Object")
	{
		fpsLimitCallback(this.fpsLimitVsyncMenuItem);
	}

	if (typeof(global.System.drawThreadNum) === "Integer")
	{
		var multiThreadDrawCallback = function(sender)
		{
			global.System.drawThreadNum = sender.flag.value;
		};

		displayMenu.add(this.multiThreadDrawMenuItem = new global.KAGMenuItem(this, global.__t("描画スレッド分割数(&N)"), 0, void, false));
		var thread_limit_values = global.thread_limit_values;
		var thread_limit_shortcuts = global.thread_limit_shortcuts;
		for (var i = 0; i < thread_limit_values.count; i += 1)
		{
			var thread_limit_value = thread_limit_values[i];
			if (thread_limit_value === void)
			{
				continue;
			}
			if (thread_limit_value === "-")
			{
				this.multiThreadDrawMenuItem.add(new global.MenuItem(this, "-"));
				continue;
			}
			var x = "" + thread_limit_value;
			var thread_limit_shortcut = thread_limit_shortcuts[x];
			if (thread_limit_shortcut === void)
			{
				thread_limit_shortcut = x;
			}
			var thread_limit_text = global.__t("%sスレッド");
			var threadLimitMenuItemName = "multiThreadDraw%dMenuItem".sprintf(thread_limit_value);
			if (thread_limit_value === 1)
			{
				thread_limit_text = global.__t("無効：スレッド分割しない(&D)");
			}
			else if (thread_limit_value === 0)
			{
				thread_limit_text = global.__t("自動：プロセッサ数で分割(&A)");
			}
			this.multiThreadDrawMenuItem.add(this[threadLimitMenuItemName] = new global.KAGFlagMenuItem(this, thread_limit_text, 1, multiThreadDrawFlag, thread_limit_value));
			if (thread_limit_text.indexOf("%") !== -1)
			{
				this[threadLimitMenuItemName].captionArg = thread_limit_shortcut;
			}
			this[threadLimitMenuItemName].afterCallback = multiThreadDrawCallback;
		}
		if (typeof(this.multiThreadDraw1MenuItem) === "Object")
		{
			multiThreadDrawCallback(this.multiThreadDraw1MenuItem);
		}
	}
};

global.addMessageWindowMenu = function(patchMenu)
{
	patchMenu.add(this.messageWindowMenuItem = new global.KAGMessageWindowMenuItem(this, global.__t("メッセージウィンドウ(&M)"), 0, void, false));
};
