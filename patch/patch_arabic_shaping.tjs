// Mostly based on icu4j sources

class ArabicShapingException extends global.Exception
{
    function ArabicShapingException(msg)
    {
        super.Exception(...);
    }
}

class IllegalArgumentException extends global.Exception
{
    function IllegalArgumentException(msg)
    {
        super.Exception(...);
    }
}

/**
 * Shape Arabic text on a character basis.
 *
 * <p>ArabicShaping performs basic operations for "shaping" Arabic text. It is most
 * useful for use with legacy data formats and legacy display technology
 * (simple terminals). All operations are performed on Unicode characters.</p>
 *
 * <p>Text-based shaping means that some character code points in the text are
 * replaced by others depending on the context. It transforms one kind of text
 * into another. In comparison, modern displays for Arabic text select
 * appropriate, context-dependent font glyphs for each text element, which means
 * that they transform text into a glyph vector.</p>
 *
 * <p>Text transformations are necessary when modern display technology is not
 * available or when text needs to be transformed to or from legacy formats that
 * use "shaped" characters. Since the Arabic script is cursive, connecting
 * adjacent letters to each other, computers select images for each letter based
 * on the surrounding letters. This usually results in four images per Arabic
 * letter: initial, middle, final, and isolated forms. In Unicode, on the other
 * hand, letters are normally stored abstract, and a display system is expected
 * to select the necessary glyphs. (This makes searching and other text
 * processing easier because the same letter has only one code.) It is possible
 * to mimic this with text transformations because there are characters in
 * Unicode that are rendered as letters with a specific shape
 * (or cursive connectivity). They were included for interoperability with
 * legacy systems and codepages, and for unsophisticated display systems.</p>
 *
 * <p>A second kind of text transformations is supported for Arabic digits:
 * For compatibility with legacy codepages that only include European digits,
 * it is possible to replace one set of digits by another, changing the
 * character code points. These operations can be performed for either
 * Arabic-Indic Digits (U+0660...U+0669) or Eastern (Extended) Arabic-Indic
 * digits (U+06f0...U+06f9).</p>
 *
 * <p>Some replacements may result in more or fewer characters (code points).
 * By default, this means that the destination buffer may receive text with a
 * length different from the source length. Some legacy systems rely on the
 * length of the text to be constant. They expect extra spaces to be added
 * or consumed either next to the affected character or at the end of the
 * text.</p>
 * @stable ICU 2.0
 */

class ArabicShaping
{
    var /* private int */ options;
    var /* private boolean */ isLogical;
    var /* private boolean */ spacesRelativeToTextBeginEnd;
    var /* private char */ tailChar;


    /**
     * Convert a range of text in the source array, putting the result
     * into a range of text in the destination array, and return the number
     * of characters written.
     *
     * @param source If string, the input text. The rest of the parameters don't need to be set
     *   Otherwise: An array containing the input text
     * @param sourceStart The start of the range of text to convert
     * @param sourceLength The length of the range of text to convert
     * @param dest The destination array that will receive the result.
     *   It may be <code>NULL</code> only if  <code>destSize</code> is 0.
     *   If this is the same as source, it can only be used if the Length
     *   option does not grow or shrink the text.
     *   If this is void, it will be set the same as source.
     * @param destStart The start of the range of the destination buffer to use.
     *   If this is void, it will be set the same as sourceStart.
     * @param destSize The size (capacity) of the destination buffer.
     *   If <code>destSize</code> is 0, then no output is produced,
     *   but the necessary buffer size is returned ("preflighting").  This
     *   does not validate the text against the options, for example,
     *   if letters are being unshaped, and spaces are being consumed
     *   following lamalef, this will not detect a lamalef without a
     *   corresponding space.  An error will be thrown when the actual
     *   conversion is attempted.
     *   If this is void, it will be set the same as destSize.
     * @return If source is String: the converted string
     *   If source is not String: The number of chars written to the destination buffer.
     *   If an error occurs, then no output was written, or it may be
     *   incomplete.
     * @throws ArabicShapingException if the text cannot be converted according to the options.
     * @stable ICU 2.0
     */

    function shape(source, sourceStart, sourceLength, dest, destStart, destSize) { // throws ArabicShapingException
        var text = void;
        if (typeof(source) === "String")
        {
            text = source;
            source = [];
            for (var i = 0; i < text.length; i += 1)
            {
                source.add(#(text[i]));
            }
            dest = source;
            if (((this.options & this.LAMALEF_MASK) == this.LAMALEF_RESIZE) ||
                ((this.options & this.LETTERS_MASK) == this.LETTERS_UNSHAPE)) {

                dest = []; // max
                for (var i = 0; i < source.count * 2; i += 1) {
                    dest.add(0x0000);
                }
            }
            sourceStart = 0;
            destStart = 0;
            sourceLength = source.count;
            destSize = dest.count;
        }
        if (dest === void)
        {
            dest = source;
        }
        if (destStart === void)
        {
            destStart = sourceStart;
        }
        if (destSize === void)
        {
            destSize = sourceLength;
        }
        if (source === dest)
        {
            if ((this.options & this.LAMALEF_MASK) == this.LAMALEF_RESIZE) {
                throw new global.ArabicShapingException("Cannot shape in place with length option resize.");
            }
        }
        if (source == null) {
            throw new global.IllegalArgumentException("source can not be null");
        }
        if (sourceStart < 0 || sourceLength < 0 || sourceStart + sourceLength > source.length) {
            throw new global.IllegalArgumentException("bad source start (" + sourceStart +
                                               ") or length (" + sourceLength +
                                               ") for buffer of length " + source.length);
        }
        if (dest == null && destSize != 0) {
            throw new global.IllegalArgumentException("null dest requires destSize == 0");
        }
        if ((destSize != 0) &&
            (destStart < 0 || destSize < 0 || destStart + destSize > dest.length)) {
            throw new global.IllegalArgumentException("bad dest start (" + destStart +
                                               ") or size (" + destSize +
                                               ") for buffer of length " + dest.length);
        }
        /* Validate input options */
        if ( ((this.options&this.TASHKEEL_MASK) != 0) &&
             !(((this.options & this.TASHKEEL_MASK)==this.TASHKEEL_BEGIN)  ||
               ((this.options & this.TASHKEEL_MASK)==this.TASHKEEL_END)    ||
               ((this.options & this.TASHKEEL_MASK)==this.TASHKEEL_RESIZE) ||
               ((this.options & this.TASHKEEL_MASK)==this.TASHKEEL_REPLACE_BY_TATWEEL))) {
            throw new global.IllegalArgumentException("Wrong Tashkeel argument");
        }

        ///CLOVER:OFF
        //According to Steven Loomis, the code is unreachable when you OR all the constants within the if statements
        if(((this.options&this.LAMALEF_MASK) != 0) &&
               !(((this.options & this.LAMALEF_MASK)==this.LAMALEF_BEGIN)  ||
                 ((this.options & this.LAMALEF_MASK)==this.LAMALEF_END)    ||
                 ((this.options & this.LAMALEF_MASK)==this.LAMALEF_RESIZE) ||
                 ((this.options & this.LAMALEF_MASK)==this.LAMALEF_AUTO)   ||
                 ((this.options & this.LAMALEF_MASK)==this.LAMALEF_NEAR))) {
            throw new global.IllegalArgumentException("Wrong Lam Alef argument");
        }
        ///CLOVER:ON

        /* Validate Tashkeel (Tashkeel replacement options should be enabled in shaping mode only)*/
        if(((this.options&this.TASHKEEL_MASK) != 0) && (this.options&this.LETTERS_MASK) == this.LETTERS_UNSHAPE) {
            throw new global.IllegalArgumentException("Tashkeel replacement should not be enabled in deshaping mode ");
        }
        var len = this.internalShape(source, sourceStart, sourceLength, dest, destStart, destSize);
        if (text !== void)
        {
            for (var i = 0; i < dest.count; i += 1)
            {
                if (dest[i] !== 0x0000)
                {
                    dest[i] = $(dest[i]);
                }
                else
                {
                    dest[i] = "";
                }
            }
            return dest.join("").substring(0, len);
        }
        return len;
    }

    /**
     * Construct ArabicShaping using the options flags.
     * The flags are as follows:<br>
     * 'LENGTH' flags control whether the text can change size, and if not,
     * how to maintain the size of the text when LamAlef ligatures are
     * formed or broken.<br>
     * 'TEXT_DIRECTION' flags control whether the text is read and written
     * in visual order or in logical order.<br>
     * 'this.LETTERS_SHAPE' flags control whether conversion is to or from
     * presentation forms.<br>
     * 'DIGITS' flags control whether digits are shaped, and whether from
     * European to Arabic-Indic or vice-versa.<br>
     * 'DIGIT_TYPE' flags control whether standard or extended Arabic-Indic
     * digits are used when performing digit conversion.
     * @stable ICU 2.0
     */
    function /* public */ ArabicShaping(/* int */ options) {
        this.options = options;
        if ((this.options & this.DIGITS_MASK) > 0x80) {
            throw new global.IllegalArgumentException("bad DIGITS options");
        }

        this.isLogical = ( (this.options & this.TEXT_DIRECTION_MASK) == this.TEXT_DIRECTION_LOGICAL );
        /* Validate options */
        this.spacesRelativeToTextBeginEnd = ( (this.options & this.SPACES_RELATIVE_TO_TEXT_MASK) == this.SPACES_RELATIVE_TO_TEXT_BEGIN_END );
        if ( (this.options&this.SHAPE_TAIL_TYPE_MASK) == this.SHAPE_TAIL_NEW_UNICODE){
            this.tailChar = this.NEW_TAIL_CHAR;
        } else {
            this.tailChar = this.OLD_TAIL_CHAR;
        }
    }


    /* Seen Tail options */
    /**
     * Memory option: the result must have the same length as the source.
     * Shaping mode: The SEEN family character will expand into two characters using space near
     *               the SEEN family character(i.e. the space after the character).
     *               if there are no spaces found, ArabicShapingException will be thrown
     *
     * De-shaping mode: Any Seen character followed by Tail character will be
     *                  replaced by one cell Seen and a space will replace the Tail.
     * Affects: Seen options
     * @stable ICU 4.2
     */
    var /* public static final int */ SEEN_TWOCELL_NEAR = 0x200000;

    /** Bit mask for Seen memory options.
     * @stable ICU 4.2
     */
    var /* public static final int */ SEEN_MASK = 0x700000;

    /* YehHamza options */
    /**
     * Memory option: the result must have the same length as the source.
     * Shaping mode: The YEHHAMZA character will expand into two characters using space near it
     *              (i.e. the space after the character)
     *               if there are no spaces found, ArabicShapingException will be thrown
     *
     * De-shaping mode: Any Yeh (final or isolated) character followed by Hamza character will be
     *                  replaced by one cell YehHamza and space will replace the Hamza.
     * Affects: YehHamza options
     * @stable ICU 4.2
     */
    var /* public static final int */ YEHHAMZA_TWOCELL_NEAR  = 0x1000000;


    /** Bit mask for YehHamza memory options.
     * @stable ICU 4.2
     */
    var /* public static final int */ YEHHAMZA_MASK = 0x3800000;

    /* New Tashkeel options */
    /**
     * Memory option: the result must have the same length as the source.
     * Shaping mode: Tashkeel characters will be replaced by spaces.
     *               Spaces will be placed at beginning of the buffer
     *
     * De-shaping mode: N/A
     * Affects: Tashkeel options
     * @stable ICU 4.2
     */
    var /* public static final int */ TASHKEEL_BEGIN = 0x40000;

    /**
     * Memory option: the result must have the same length as the source.
     * Shaping mode: Tashkeel characters will be replaced by spaces.
     *               Spaces will be placed at end of the buffer
     *
     * De-shaping mode: N/A
     * Affects: Tashkeel options
     * @stable ICU 4.2
     */
    var /* public static final int */ TASHKEEL_END = 0x60000;

    /**
     * Memory option: allow the result to have a different length than the source.
     * Shaping mode: Tashkeel characters will be removed, buffer length will shrink.
     * De-shaping mode: N/A
     *
     * Affects: Tashkeel options
     * @stable ICU 4.2
     */
    var /* public static final int */ TASHKEEL_RESIZE = 0x80000;

    /**
     * Memory option: the result must have the same length as the source.
     * Shaping mode: Tashkeel characters will be replaced by Tatweel if it is connected to adjacent
     *               characters (i.e. shaped on Tatweel) or replaced by space if it is not connected.
     *
     * De-shaping mode: N/A
     * Affects: YehHamza options
     * @stable ICU 4.2
     */
    var /* public static final int */ TASHKEEL_REPLACE_BY_TATWEEL = 0xC0000;

    /** Bit mask for Tashkeel replacement with Space or Tatweel memory options.
     *  @stable ICU 4.2
     */
    var /* public static final int */ TASHKEEL_MASK  = 0xE0000;

    /* Space location Control options */
    /**
     * This option effects the meaning of BEGIN and END options. if this option is not used the default
     * for BEGIN and END will be as following:
     * The Default (for both Visual LTR, Visual RTL and Logical Text)
     *           1. BEGIN always refers to the start address of physical memory.
     *           2. END always refers to the end address of physical memory.
     *
     * If this option is used it will swap the meaning of BEGIN and END only for Visual LTR text.
     *
     * The affect on BEGIN and END Memory Options will be as following:
     *    A. BEGIN For Visual LTR text: This will be the beginning (right side) of the visual text
     *       (corresponding to the physical memory address end, same as END in default behavior)
     *    B. BEGIN For Logical text: Same as BEGIN in default behavior.
     *    C. END For Visual LTR text: This will be the end (left side) of the visual text. (corresponding to
     *      the physical memory address beginning, same as BEGIN in default behavior)
     *    D. END For Logical text: Same as END in default behavior.
     * Affects: All LamAlef BEGIN, END and AUTO options.
     * @stable ICU 4.2
     */
    var /* public static final int */ SPACES_RELATIVE_TO_TEXT_BEGIN_END = 0x4000000;

    /** Bit mask for swapping BEGIN and END for Visual LTR text
     * @stable ICU 4.2
     */
    var /* public static final int */ SPACES_RELATIVE_TO_TEXT_MASK = 0x4000000;

    /**
     * If this option is used, shaping will use the new Unicode code point for TAIL (i.e. 0xFE73).
     * If this option is not specified (Default), old unofficial Unicode TAIL code point is used (i.e. 0x200B)
     * De-shaping will not use this option as it will always search for both the new Unicode code point for the
     * TAIL (i.e. 0xFE73) or the old unofficial Unicode TAIL code point (i.e. 0x200B) and de-shape the
     * Seen-Family letter accordingly.
     *
     * Shaping Mode: Only shaping.
     * De-shaping Mode: N/A.
     * Affects: All Seen options
     * @stable ICU 4.2
     */
    var /* public static final int */ SHAPE_TAIL_NEW_UNICODE = 0x8000000;

    /** Bit mask for new Unicode Tail option
     * @stable ICU 4.2
     */
    var /* public static final int */ SHAPE_TAIL_TYPE_MASK = 0x8000000;

    /**
     * Memory option: allow the result to have a different length than the source.
     * @stable ICU 2.0
     */
    var /* public static final int */ LENGTH_GROW_SHRINK = 0;

    /**
     * Memory option: allow the result to have a different length than the source.
     * Affects: LamAlef options
     * This option is an alias to LENGTH_GROW_SHRINK
     * @stable ICU 4.2
     */
    var /* public static final int */ LAMALEF_RESIZE   = 0;

    /**
     * Memory option: the result must have the same length as the source.
     * If more room is necessary, then try to consume spaces next to modified characters.
     * @stable ICU 2.0
     */
    var /* public static final int */ LENGTH_FIXED_SPACES_NEAR = 1;

    /**
     * Memory option: the result must have the same length as the source.
     * If more room is necessary, then try to consume spaces next to modified characters.
     * Affects: LamAlef options
     * This option is an alias to LENGTH_FIXED_SPACES_NEAR
     * @stable ICU 4.2
     */
    var /* public static final int */ LAMALEF_NEAR = 1 ;

    /**
     * Memory option: the result must have the same length as the source.
     * If more room is necessary, then try to consume spaces at the end of the text.
     * @stable ICU 2.0
     */
    var /* public static final int */ LENGTH_FIXED_SPACES_AT_END = 2;


    /**
     * Memory option: the result must have the same length as the source.
     * If more room is necessary, then try to consume spaces at the end of the text.
     * Affects: LamAlef options
     * This option is an alias to LENGTH_FIXED_SPACES_AT_END
     * @stable ICU 4.2
     */
    var /* public static final int */ LAMALEF_END = 2;

    /**
     * Memory option: the result must have the same length as the source.
     * If more room is necessary, then try to consume spaces at the beginning of the text.
     * @stable ICU 2.0
     */
    var /* public static final int */ LENGTH_FIXED_SPACES_AT_BEGINNING = 3;

    /**
     * Memory option: the result must have the same length as the source.
     * If more room is necessary, then try to consume spaces at the beginning of the text.
     * Affects: LamAlef options
     * This option is an alias to LENGTH_FIXED_SPACES_AT_BEGINNING
     * @stable ICU 4.2
     */
    var /* public static final int */ LAMALEF_BEGIN = 3;

    /**
     * Memory option: the result must have the same length as the source.
     * Shaping Mode: For each LAMALEF character found, expand LAMALEF using space at end.
     *               If there is no space at end, use spaces at beginning of the buffer. If there
     *               is no space at beginning of the buffer, use spaces at the near (i.e. the space
     *               after the LAMALEF character).
     *
     * Deshaping Mode: Perform the same function as the flag equals LAMALEF_END.
     * Affects: LamAlef options
     * @stable ICU 4.2
     */
    var /* public static final int */ LAMALEF_AUTO  = 0x10000;

    /**
     * Bit mask for memory options.
     * @stable ICU 2.0
     */
    var /* public static final int */ LENGTH_MASK = 0x10003;

    /** Bit mask for LamAlef memory options.
     * @stable ICU 4.2
     */

    var /* public static final int */ LAMALEF_MASK  = 0x10003;

    /**
     * Direction indicator: the source is in logical (keyboard) order.
     * @stable ICU 2.0
     */
    var /* public static final int */ TEXT_DIRECTION_LOGICAL = 0;

    /**
     * Direction indicator:the source is in visual RTL order,
     * the rightmost displayed character stored first.
     * This option is an alias to U_SHAPE_TEXT_DIRECTION_LOGICAL
     * @stable ICU 4.2
     */
    var /* public static final int */ TEXT_DIRECTION_VISUAL_RTL = 0;

    /**
     * Direction indicator: the source is in visual (display) order, that is,
     * the leftmost displayed character is stored first.
     * @stable ICU 2.0
     */
    var /* public static final int */ TEXT_DIRECTION_VISUAL_LTR = 4;

    /**
     * Bit mask for direction indicators.
     * @stable ICU 2.0
     */
    var /* public static final int */ TEXT_DIRECTION_MASK = 4;


    /**
     * Letter shaping option: do not perform letter shaping.
     * @stable ICU 2.0
     */
    var /* public static final int */ LETTERS_NOOP = 0;

    /**
     * Letter shaping option: replace normative letter characters in the U+0600 (Arabic) block,
     * by shaped ones in the U+FE70 (Presentation Forms B) block. Performs Lam-Alef ligature
     * substitution.
     * @stable ICU 2.0
     */
    var /* public static final int */ LETTERS_SHAPE = 8;

    /**
     * Letter shaping option: replace shaped letter characters in the U+FE70 (Presentation Forms B) block
     * by normative ones in the U+0600 (Arabic) block.  Converts Lam-Alef ligatures to pairs of Lam and
     * Alef characters, consuming spaces if required.
     * @stable ICU 2.0
     */
    var /* public static final int */ LETTERS_UNSHAPE = 0x10;

    /**
     * Letter shaping option: replace normative letter characters in the U+0600 (Arabic) block,
     * except for the TASHKEEL characters at U+064B...U+0652, by shaped ones in the U+Fe70
     * (Presentation Forms B) block.  The TASHKEEL characters will always be converted to
     * the isolated forms rather than to their correct shape.
     * @stable ICU 2.0
     */
    var /* public static final int */ LETTERS_SHAPE_TASHKEEL_ISOLATED = 0x18;

    /**
     * Bit mask for letter shaping options.
     * @stable ICU 2.0
     */
    var /* public static final int */ LETTERS_MASK = 0x18;


    /**
     * Digit shaping option: do not perform digit shaping.
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGITS_NOOP = 0;

    /**
     * Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGITS_EN2AN = 0x20;

    /**
     * Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGITS_AN2EN = 0x40;

    /**
     * Digit shaping option:
     * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
     * if the most recent strongly directional character
     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
     * The initial state at the start of the text is assumed to be not an Arabic,
     * letter, so European digits at the start of the text will not change.
     * Compare to DIGITS_ALEN2AN_INIT_AL.
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGITS_EN2AN_INIT_LR = 0x60;

    /**
     * Digit shaping option:
     * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
     * if the most recent strongly directional character
     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
     * The initial state at the start of the text is assumed to be an Arabic,
     * letter, so European digits at the start of the text will change.
     * Compare to DIGITS_ALEN2AN_INT_LR.
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGITS_EN2AN_INIT_AL = 0x80;

    /** Not a valid option value. */
    //private static final int DIGITS_RESERVED = 0xa0;

    /**
     * Bit mask for digit shaping options.
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGITS_MASK = 0xe0;

    /**
     * Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGIT_TYPE_AN = 0;

    /**
     * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGIT_TYPE_AN_EXTENDED = 0x100;

    /**
     * Bit mask for digit type options.
     * @stable ICU 2.0
     */
    var /* public static final int */ DIGIT_TYPE_MASK = 0x0100; // 0x3f00?

    /**
     * some constants
     */
    var /* private static final char */ HAMZAFE_CHAR       = 0xfe80;
    var /* private static final char */ HAMZA06_CHAR       = 0x0621;
    var /* private static final char */ YEH_HAMZA_CHAR     = 0x0626;
    var /* private static final char */ YEH_HAMZAFE_CHAR   = 0xFE89;
    var /* private static final char */ LAMALEF_SPACE_SUB  = 0xffff;
    var /* private static final char */ TASHKEEL_SPACE_SUB = 0xfffe;
    var /* private static final char */ LAM_CHAR      = 0x0644;
    var /* private static final char */ SPACE_CHAR    = 0x0020;
    var /* private static final char */ SHADDA_CHAR   = 0xFE7C;
    var /* private static final char */ SHADDA06_CHAR = 0x0651;
    var /* private static final char */ TATWEEL_CHAR  = 0x0640;
    var /* private static final char */ SHADDA_TATWEEL_CHAR = 0xFE7D;
    var /* private static final char */ NEW_TAIL_CHAR = 0xFE73;
    var /* private static final char */ OLD_TAIL_CHAR = 0x200B;
    var /* private static final int */ SHAPE_MODE      = 0;
    var /* private static final int */ DESHAPE_MODE    = 1;


    /**
     * @stable ICU 2.0
     */
    /* @Override */
    function /* public boolean */ equals(/* Object */ rhs) {
        return rhs != null &&
            (rhs instanceof "ArabicShaping") &&
            /* rhs.getClass() == ArabicShaping.class && */
            this.options == (/*(ArabicShaping)*/rhs).options;
    }

    /**
     * @stable ICU 2.0
     */
     ///CLOVER:OFF
    /* @Override */
    function /* public int */ hashCode() {
        return this.options;
    }

    /**
     * @stable ICU 2.0
     */
    /* @Override */
    function /* public String */ toString() {
        var /* StringBuilder */ buf = [];
        buf.add("[");

        switch (this.options & this.LAMALEF_MASK) {
        case this.LAMALEF_RESIZE: buf.add("LamAlef resize"); break;
        case this.LAMALEF_NEAR: buf.add("LamAlef spaces at near"); break;
        case this.LAMALEF_BEGIN: buf.add("LamAlef spaces at begin"); break;
        case this.LAMALEF_END: buf.add("LamAlef spaces at end"); break;
        case this.LAMALEF_AUTO: buf.add("lamAlef auto"); break;
        }
        switch (this.options & this.TEXT_DIRECTION_MASK) {
        case this.TEXT_DIRECTION_LOGICAL: buf.add(", logical"); break;
        case this.TEXT_DIRECTION_VISUAL_LTR: buf.add(", visual"); break;
        }
        switch (this.options & this.LETTERS_MASK) {
        case this.LETTERS_NOOP: buf.add(", no letter shaping"); break;
        case this.LETTERS_SHAPE: buf.add(", shape letters"); break;
        case this.LETTERS_SHAPE_TASHKEEL_ISOLATED: buf.add(", shape letters tashkeel isolated"); break;
        case this.LETTERS_UNSHAPE: buf.add(", unshape letters"); break;
        }
        switch (this.options & this.SEEN_MASK) {
        case this.SEEN_TWOCELL_NEAR: buf.add(", Seen at near"); break;
        }
        switch (this.options & this.YEHHAMZA_MASK) {
        case this.YEHHAMZA_TWOCELL_NEAR: buf.add(", Yeh Hamza at near"); break;
        }
        switch (this.options & this.TASHKEEL_MASK) {
        case this.TASHKEEL_BEGIN: buf.add(", Tashkeel at begin"); break;
        case this.TASHKEEL_END: buf.add(", Tashkeel at end"); break;
        case this.TASHKEEL_REPLACE_BY_TATWEEL: buf.add(", Tashkeel replace with tatweel"); break;
        case this.TASHKEEL_RESIZE: buf.add(", Tashkeel resize"); break;
        }

        switch (this.options & this.DIGITS_MASK) {
        case this.DIGITS_NOOP: buf.add(", no digit shaping"); break;
        case this.DIGITS_EN2AN: buf.add(", shape digits to AN"); break;
        case this.DIGITS_AN2EN: buf.add(", shape digits to EN"); break;
        case this.DIGITS_EN2AN_INIT_LR: buf.add(", shape digits to AN contextually: default EN"); break;
        case this.DIGITS_EN2AN_INIT_AL: buf.add(", shape digits to AN contextually: default AL"); break;
        }
        switch (this.options & this.DIGIT_TYPE_MASK) {
        case this.DIGIT_TYPE_AN: buf.add(", standard Arabic-Indic digits"); break;
        case this.DIGIT_TYPE_AN_EXTENDED: buf.add(", extended Arabic-Indic digits"); break;
        }
        buf.add("]");

        return buf.join("");
    }
    ///CLOVER:ON

    //
    // ported api
    //

    var /* private static final int */ IRRELEVANT = 4;
    var /* private static final int */ LAMTYPE = 16;
    var /* private static final int */ ALEFTYPE = 32;

    var /* private static final int */ LINKR = 1;
    var /* private static final int */ LINKL = 2;
    var /* private static final int */ LINK_MASK = 3;

    var /* private static final int */ irrelevantPos /* [] */ = [
        0x0, 0x2, 0x4, 0x6, 0x8, 0xA, 0xC, 0xE
    ];

    var /* private static final char */ convertLamAlef /* [] */ =  [
        0x0622, // FEF5
        0x0622, // FEF6
        0x0623, // FEF7
        0x0623, // FEF8
        0x0625, // FEF9
        0x0625, // FEFA
        0x0627, // FEFB
        0x0627  // FEFC
    ];

    var /* private static final int */ tailFamilyIsolatedFinal /* [] */ = [
        /* FEB1 */ 1,
        /* FEB2 */ 1,
        /* FEB3 */ 0,
        /* FEB4 */ 0,
        /* FEB5 */ 1,
        /* FEB6 */ 1,
        /* FEB7 */ 0,
        /* FEB8 */ 0,
        /* FEB9 */ 1,
        /* FEBA */ 1,
        /* FEBB */ 0,
        /* FEBC */ 0,
        /* FEBD */ 1,
        /* FEBE */ 1
    ];

    var /* private static final int */ tashkeelMedial /* [] */ = [
        /* FE70 */ 0,
        /* FE71 */ 1,
        /* FE72 */ 0,
        /* FE73 */ 0,
        /* FE74 */ 0,
        /* FE75 */ 0,
        /* FE76 */ 0,
        /* FE77 */ 1,
        /* FE78 */ 0,
        /* FE79 */ 1,
        /* FE7A */ 0,
        /* FE7B */ 1,
        /* FE7C */ 0,
        /* FE7D */ 1,
        /* FE7E */ 0,
        /* FE7F */ 1
    ];

    var /* private static final char */ yehHamzaToYeh /* [] */ =
    [
    /* isolated*/ 0xFEEF,
    /* final   */ 0xFEF0
    ];

    var /* private static final char */ convertNormalizedLamAlef /* [] */ = [
        0x0622, // 065C
        0x0623, // 065D
        0x0625, // 065E
        0x0627, // 065F
    ];

    var /* private static final int[] */ araLink = [
        1           + 32 + 256 * 0x11,  /*0x0622*/
        1           + 32 + 256 * 0x13,  /*0x0623*/
        1                + 256 * 0x15,  /*0x0624*/
        1           + 32 + 256 * 0x17,  /*0x0625*/
        1 + 2            + 256 * 0x19,  /*0x0626*/
        1           + 32 + 256 * 0x1D,  /*0x0627*/
        1 + 2            + 256 * 0x1F,  /*0x0628*/
        1                + 256 * 0x23,  /*0x0629*/
        1 + 2            + 256 * 0x25,  /*0x062A*/
        1 + 2            + 256 * 0x29,  /*0x062B*/
        1 + 2            + 256 * 0x2D,  /*0x062C*/
        1 + 2            + 256 * 0x31,  /*0x062D*/
        1 + 2            + 256 * 0x35,  /*0x062E*/
        1                + 256 * 0x39,  /*0x062F*/
        1                + 256 * 0x3B,  /*0x0630*/
        1                + 256 * 0x3D,  /*0x0631*/
        1                + 256 * 0x3F,  /*0x0632*/
        1 + 2            + 256 * 0x41,  /*0x0633*/
        1 + 2            + 256 * 0x45,  /*0x0634*/
        1 + 2            + 256 * 0x49,  /*0x0635*/
        1 + 2            + 256 * 0x4D,  /*0x0636*/
        1 + 2            + 256 * 0x51,  /*0x0637*/
        1 + 2            + 256 * 0x55,  /*0x0638*/
        1 + 2            + 256 * 0x59,  /*0x0639*/
        1 + 2            + 256 * 0x5D,  /*0x063A*/
        0, 0, 0, 0, 0,                  /*0x063B-0x063F*/
        1 + 2,                          /*0x0640*/
        1 + 2            + 256 * 0x61,  /*0x0641*/
        1 + 2            + 256 * 0x65,  /*0x0642*/
        1 + 2            + 256 * 0x69,  /*0x0643*/
        1 + 2       + 16 + 256 * 0x6D,  /*0x0644*/
        1 + 2            + 256 * 0x71,  /*0x0645*/
        1 + 2            + 256 * 0x75,  /*0x0646*/
        1 + 2            + 256 * 0x79,  /*0x0647*/
        1                + 256 * 0x7D,  /*0x0648*/
        1                + 256 * 0x7F,  /*0x0649*/
        1 + 2            + 256 * 0x81,  /*0x064A*/
        4, 4, 4, 4,                     /*0x064B-0x064E*/
        4, 4, 4, 4,                     /*0x064F-0x0652*/
        4, 4, 4, 0, 0,                  /*0x0653-0x0657*/
        0, 0, 0, 0,                     /*0x0658-0x065B*/
        1                + 256 * 0x85,  /*0x065C*/
        1                + 256 * 0x87,  /*0x065D*/
        1                + 256 * 0x89,  /*0x065E*/
        1                + 256 * 0x8B,  /*0x065F*/
        0, 0, 0, 0, 0,                  /*0x0660-0x0664*/
        0, 0, 0, 0, 0,                  /*0x0665-0x0669*/
        0, 0, 0, 0, 0, 0,               /*0x066A-0x066F*/
        4,                              /*0x0670*/
        0,                              /*0x0671*/
        1           + 32,               /*0x0672*/
        1           + 32,               /*0x0673*/
        0,                              /*0x0674*/
        1           + 32,               /*0x0675*/
        1, 1,                           /*0x0676-0x0677*/
        1+2, 1+2, 1+2, 1+2, 1+2, 1+2,   /*0x0678-0x067D*/
        1+2, 1+2, 1+2, 1+2, 1+2, 1+2,   /*0x067E-0x0683*/
        1+2, 1+2, 1+2, 1+2,             /*0x0684-0x0687*/
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,   /*0x0688-0x0691*/
        1, 1, 1, 1, 1, 1, 1, 1,         /*0x0692-0x0699*/
        1+2, 1+2, 1+2, 1+2, 1+2, 1+2,   /*0x069A-0x06A3*/
        1+2, 1+2, 1+2, 1+2,             /*0x069A-0x06A3*/
        1+2, 1+2, 1+2, 1+2, 1+2, 1+2,   /*0x06A4-0x06AD*/
        1+2, 1+2, 1+2, 1+2,             /*0x06A4-0x06AD*/
        1+2, 1+2, 1+2, 1+2, 1+2, 1+2,   /*0x06AE-0x06B7*/
        1+2, 1+2, 1+2, 1+2,             /*0x06AE-0x06B7*/
        1+2, 1+2, 1+2, 1+2, 1+2, 1+2,   /*0x06B8-0x06BF*/
        1+2, 1+2,                       /*0x06B8-0x06BF*/
        1,                              /*0x06C0*/
        1+2,                            /*0x06C1*/
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,   /*0x06C2-0x06CB*/
        1+2,                            /*0x06CC*/
        1,                              /*0x06CD*/
        1+2, 1+2, 1+2, 1+2,             /*0x06CE-0x06D1*/
        1, 1                            /*0x06D2-0x06D3*/
    ];

    var /* private static final int[] */ presLink = [
        1 + 2,                        /*0xFE70*/
        1 + 2,                        /*0xFE71*/
        1 + 2, 0, 1+ 2, 0, 1+ 2,      /*0xFE72-0xFE76*/
        1 + 2,                        /*0xFE77*/
        1+ 2, 1 + 2, 1+2, 1 + 2,      /*0xFE78-0xFE81*/
        1+ 2, 1 + 2, 1+2, 1 + 2,      /*0xFE82-0xFE85*/
        0, 0 + 32, 1 + 32, 0 + 32,    /*0xFE86-0xFE89*/
        1 + 32, 0, 1,  0 + 32,        /*0xFE8A-0xFE8D*/
        1 + 32, 0, 2,  1 + 2,         /*0xFE8E-0xFE91*/
        1, 0 + 32, 1 + 32, 0,         /*0xFE92-0xFE95*/
        2, 1 + 2, 1, 0,               /*0xFE96-0xFE99*/
        1, 0, 2, 1 + 2,               /*0xFE9A-0xFE9D*/
        1, 0, 2, 1 + 2,               /*0xFE9E-0xFEA1*/
        1, 0, 2, 1 + 2,               /*0xFEA2-0xFEA5*/
        1, 0, 2, 1 + 2,               /*0xFEA6-0xFEA9*/
        1, 0, 2, 1 + 2,               /*0xFEAA-0xFEAD*/
        1, 0, 1, 0,                   /*0xFEAE-0xFEB1*/
        1, 0, 1, 0,                   /*0xFEB2-0xFEB5*/
        1, 0, 2, 1+2,                 /*0xFEB6-0xFEB9*/
        1, 0, 2, 1+2,                 /*0xFEBA-0xFEBD*/
        1, 0, 2, 1+2,                 /*0xFEBE-0xFEC1*/
        1, 0, 2, 1+2,                 /*0xFEC2-0xFEC5*/
        1, 0, 2, 1+2,                 /*0xFEC6-0xFEC9*/
        1, 0, 2, 1+2,                 /*0xFECA-0xFECD*/
        1, 0, 2, 1+2,                 /*0xFECE-0xFED1*/
        1, 0, 2, 1+2,                 /*0xFED2-0xFED5*/
        1, 0, 2, 1+2,                 /*0xFED6-0xFED9*/
        1, 0, 2, 1+2,                 /*0xFEDA-0xFEDD*/
        1, 0, 2, 1+2,                 /*0xFEDE-0xFEE1*/
        1, 0 + 16, 2 + 16, 1 + 2 +16, /*0xFEE2-0xFEE5*/
        1 + 16, 0, 2, 1+2,            /*0xFEE6-0xFEE9*/
        1, 0, 2, 1+2,                 /*0xFEEA-0xFEED*/
        1, 0, 2, 1+2,                 /*0xFEEE-0xFEF1*/
        1, 0, 1, 0,                   /*0xFEF2-0xFEF5*/
        1, 0, 2, 1+2,                 /*0xFEF6-0xFEF9*/
        1, 0, 1, 0,                   /*0xFEFA-0xFEFD*/
        1, 0, 1, 0,
        1
    ];

    var /* private static int[] */ convertFEto06 = [
        /***********0******1******2******3******4******5******6******7******8******9******A******B******C******D******E******F***/
        /*FE7*/   0x64B, 0x64B, 0x64C, 0x64C, 0x64D, 0x64D, 0x64E, 0x64E, 0x64F, 0x64F, 0x650, 0x650, 0x651, 0x651, 0x652, 0x652,
        /*FE8*/   0x621, 0x622, 0x622, 0x623, 0x623, 0x624, 0x624, 0x625, 0x625, 0x626, 0x626, 0x626, 0x626, 0x627, 0x627, 0x628,
        /*FE9*/   0x628, 0x628, 0x628, 0x629, 0x629, 0x62A, 0x62A, 0x62A, 0x62A, 0x62B, 0x62B, 0x62B, 0x62B, 0x62C, 0x62C, 0x62C,
        /*FEA*/   0x62C, 0x62D, 0x62D, 0x62D, 0x62D, 0x62E, 0x62E, 0x62E, 0x62E, 0x62F, 0x62F, 0x630, 0x630, 0x631, 0x631, 0x632,
        /*FEB*/   0x632, 0x633, 0x633, 0x633, 0x633, 0x634, 0x634, 0x634, 0x634, 0x635, 0x635, 0x635, 0x635, 0x636, 0x636, 0x636,
        /*FEC*/   0x636, 0x637, 0x637, 0x637, 0x637, 0x638, 0x638, 0x638, 0x638, 0x639, 0x639, 0x639, 0x639, 0x63A, 0x63A, 0x63A,
        /*FED*/   0x63A, 0x641, 0x641, 0x641, 0x641, 0x642, 0x642, 0x642, 0x642, 0x643, 0x643, 0x643, 0x643, 0x644, 0x644, 0x644,
        /*FEE*/   0x644, 0x645, 0x645, 0x645, 0x645, 0x646, 0x646, 0x646, 0x646, 0x647, 0x647, 0x647, 0x647, 0x648, 0x648, 0x649,
        /*FEF*/   0x649, 0x64A, 0x64A, 0x64A, 0x64A, 0x65C, 0x65C, 0x65D, 0x65D, 0x65E, 0x65E, 0x65F, 0x65F
    ];

    var /* private static final int */ shapeTable /* [][][] */ = [
        [ [0,0,0,0], [0,0,0,0], [0,1,0,3], [0,1,0,1] ],
        [ [0,0,2,2], [0,0,1,2], [0,1,1,2], [0,1,1,3] ],
        [ [0,0,0,0], [0,0,0,0], [0,1,0,3], [0,1,0,3] ],
        [ [0,0,1,2], [0,0,1,2], [0,1,1,2], [0,1,1,3] ]
    ];

    /*
     * This function shapes European digits to Arabic-Indic digits
     * in-place, writing over the input characters.  Data is in visual
     * order.
     */
    function /* private void */ shapeToArabicDigitsWithContext(/* char[] */ dest,
                                                /* int */ start,
                                                /* int */ length,
                                                /* char */ digitBase,
                                                /* boolean */ lastStrongWasAL) {
/*
        UBiDiProps bdp=UBiDiProps.INSTANCE;
        digitBase -= '0'; // move common adjustment out of loop

        for(int i = start + length; --i >= start;) {
            char ch = dest[i];
            switch (bdp.getClass(ch)) {
            case UCharacterDirection.LEFT_TO_RIGHT:
            case UCharacterDirection.RIGHT_TO_LEFT:
                lastStrongWasAL = false;
                break;
            case UCharacterDirection.RIGHT_TO_LEFT_ARABIC:
                lastStrongWasAL = true;
                break;
            case UCharacterDirection.EUROPEAN_NUMBER:
                if (lastStrongWasAL && ch <= 0x0039) {
                    dest[i] = (char)(ch + digitBase);
                }
                break;
            default:
                break;
            }
        }
*/
        var bdp = global.Bidi;
        digitBase -= #"0"; // move common adjustment out of loop

        for(var /* int */ i = start + length; --i >= start;) {
            var /* char */ ch = dest[i];
            switch (bdp.bidi_class_for(ch)) {
            case /* UCharacterDirection.LEFT_TO_RIGHT */ "L":
            case /* UCharacterDirection.RIGHT_TO_LEFT */ "R":
                lastStrongWasAL = false;
                break;
            case /* UCharacterDirection.RIGHT_TO_LEFT_ARABIC */ "AL":
                lastStrongWasAL = true;
                break;
            case /* UCharacterDirection.EUROPEAN_NUMBER */ "EN":
                if (lastStrongWasAL && ch <= 0x0039) {
                    dest[i] = ch + digitBase;
                }
                break;
            default:
                break;
            }
        }
    }

    /*
     * Name    : invertBuffer
     * Function: This function inverts the buffer, it's used
     *           in case the user specifies the buffer to be
     *           this.TEXT_DIRECTION_LOGICAL
     */
    function /* private static void */ invertBuffer(/* char[] */ buffer,
                                     /* int */ start,
                                     /* int */ length) {

        for(var /* int */ i = start, j = start + length - 1; i < j; i++, --j) {
            var /* char */ temp = buffer[i];
            buffer[i] = buffer[j];
            buffer[j] = temp;
        }
    }


    /*
     * Name    : changeLamAlef
     * Function: Converts the Alef characters into an equivalent
     *           LamAlef location in the 0x06xx Range, this is an
     *           intermediate stage in the operation of the program
     *           later it'll be converted into the 0xFExx LamAlefs
     *           in the shaping function.
     */
    function /* private static char */ changeLamAlef(/* char */ ch) {
        switch(ch) {
        case 0x0622: return 0x065C;
        case 0x0623: return 0x065D;
        case 0x0625: return 0x065E;
        case 0x0627: return 0x065F;
        default:  return 0x0000; // not a lamalef
        }
    }


    /*
     * Name    : specialChar
     * Function: Special Arabic characters need special handling in the shapeUnicode
     *           function, this function returns 1 or 2 for these special characters
     */
    function /* private static int */ specialChar(/* char */ ch) {
        if ((ch > 0x0621 && ch < 0x0626) ||
            (ch == 0x0627) ||
            (ch > 0x062E && ch < 0x0633) ||
            (ch > 0x0647 && ch < 0x064A) ||
            (ch == 0x0629)) {
            return 1;
        } else if (ch >= 0x064B && ch<= 0x0652) {
            return 2;
        } else if (ch >= 0x0653 && ch <= 0x0655 ||
                   ch == 0x0670 ||
                   ch >= 0xFE70 && ch <= 0xFE7F) {
            return 3;
        } else {
            return 0;
        }
    }

    /*
     * Name    : getLink
     * Function: Resolves the link between the characters as
     *           Arabic characters have four forms :
     *           Isolated, Initial, Middle and Final Form
     */
    function /* private static int */ getLink(/* char */ ch) {
        if (ch >= 0x0622 && ch <= 0x06D3) {
            return this.araLink[ch - 0x0622];
        } else if (ch == 0x200D) {
            return 3;
        } else if (ch >= 0x206D && ch <= 0x206F) {
            return 4;
        } else if (ch >= 0xFE70 && ch <= 0xFEFC) {
            return this.presLink[ch - 0xFE70];
        } else {
            return 0;
        }
    }

    /*
     * Name    : countSpaces
     * Function: Counts the number of spaces
     *           at each end of the logical buffer
     */
    function /* private static int */ countSpacesLeft(/* char[] */ dest,
                                       /* int */ start,
                                       /* int */ count) {
        for (var /* int */ i = start, e = start + count; i < e; ++i) {
            if (dest[i] != this.SPACE_CHAR) {
                return i - start;
            }
        }
        return count;
    }

    function /* private static int */ countSpacesRight(/* char[] */ dest,
                                        /* int */ start,
                                        /* int */ count) {

        for (var /* int */ i = start + count; --i >= start;) {
            if (dest[i] != this.SPACE_CHAR) {
                return start + count - 1 - i;
            }
        }
        return count;
    }

    /*
     * Name    : isTashkeelChar
     * Function: Returns true for Tashkeel characters else return false
     */
    function /* private static boolean */ isTashkeelChar(/* char */ ch) {
        return ( ch >=0x064B && ch <= 0x0652 );
    }

    /*
     *Name     : isSeenTailFamilyChar
     *Function : returns 1 if the character is a seen family isolated character
     *           in the FE range otherwise returns 0
     */

    function /* private static int */ isSeenTailFamilyChar(/* char */ ch) {
        if (ch >= 0xfeb1 && ch < 0xfebf){
             return this.tailFamilyIsolatedFinal [ch - 0xFEB1];
        } else {
             return 0;
        }
    }


     /* Name     : isSeenFamilyChar
      * Function : returns 1 if the character is a seen family character in the Unicode
      *            06 range otherwise returns 0
     */

    function /* private static int */ isSeenFamilyChar(/* char */  ch){
        if (ch >= 0x0633 && ch <= 0x0636){
            return 1;
        }else {
            return 0;
        }
    }

    /*
     *Name     : isTailChar
     *Function : returns true if the character matches one of the tail characters
     *           (0xfe73 or 0x200b) otherwise returns false
     */

    function /* private static boolean */ isTailChar(/* char */ ch) {
        if(ch == this.OLD_TAIL_CHAR || ch == this.NEW_TAIL_CHAR){
                return true;
        }else{
                return false;
        }
    }

    /*
     *Name     : isAlefMaksouraChar
     *Function : returns true if the character is a Alef Maksoura Final or isolated
     *           otherwise returns false
     */
    function /* private static boolean */ isAlefMaksouraChar(/* char */ ch) {
        return ( (ch == 0xFEEF) || ( ch == 0xFEF0) || (ch == 0x0649));
    }

    /*
     * Name     : isYehHamzaChar
     * Function : returns true if the character is a yehHamza isolated or yehhamza
     *            final is found otherwise returns false
     */
    function /* private static boolean */ isYehHamzaChar(/* char */ ch) {
        if((ch==0xFE89)||(ch==0xFE8A)){
            return true;
        }else{
            return false;
        }
    }

    /*
     *Name     : isTashkeelCharFE
     *Function : Returns true for Tashkeel characters in FE range else return false
     */

    function /* private static boolean */ isTashkeelCharFE(/* char */ ch) {
        return ( ch!=0xFE75 &&(ch>=0xFE70 && ch<= 0xFE7F) );
    }

    /*
     * Name: isTashkeelOnTatweelChar
     * Function: Checks if the Tashkeel Character is on Tatweel or not,if the
     *           Tashkeel on tatweel (FE range), it returns 1 else if the
     *           Tashkeel with shadda on tatweel (FC range)return 2 otherwise
     *           returns 0
     */
    function /* private static int */ isTashkeelOnTatweelChar(/* char */ ch){
        if (ch >= 0xfe70 && ch <= 0xfe7f && ch != this.NEW_TAIL_CHAR && ch != 0xFE75 && ch != this.SHADDA_TATWEEL_CHAR)
        {
            return this.tashkeelMedial [ch - 0xFE70];
        } else if( (ch >= 0xfcf2 && ch <= 0xfcf4) || (ch == this.SHADDA_TATWEEL_CHAR)) {
            return 2;
        } else {
            return 0;
        }
    }

    /*
     * Name: isIsolatedTashkeelChar
     * Function: Checks if the Tashkeel Character is in the isolated form
     *           (i.e. Unicode FE range) returns 1 else if the Tashkeel
     *           with shadda is in the isolated form (i.e. Unicode FC range)
     *           returns 1 otherwise returns 0
     */
    function /* private static int */ isIsolatedTashkeelChar(/* char */ ch){
        if (ch >= 0xfe70 && ch <= 0xfe7f && ch != this.NEW_TAIL_CHAR && ch != 0xFE75){
            return (1 - this.tashkeelMedial [ch - 0xFE70]);
        } else if(ch >= 0xfc5e && ch <= 0xfc63){
            return 1;
        } else{
            return 0;
        }
    }

    /*
     * Name    : isAlefChar
     * Function: Returns 1 for Alef characters else return 0
     */
    function /* private static boolean */ isAlefChar(/* char */ ch) {
        return ch == 0x0622 || ch == 0x0623 || ch == 0x0625 || ch == 0x0627;
    }

    /*
     * Name    : isLamAlefChar
     * Function: Returns true for LamAlef characters else return false
     */
    function /* private static boolean */ isLamAlefChar(/* char */ ch) {
        return ch >= 0xFEF5 && ch <= 0xFEFC;
    }

    function /* private static boolean */ isNormalizedLamAlefChar(/* char */ ch) {
        return ch >= 0x065C && ch <= 0x065F;
    }

    /*
     * Name    : calculateSize
     * Function: This function calculates the destSize to be used in preflighting
     *           when the destSize is equal to 0
     */
    function /* private int */ calculateSize(/* char[] */ source,
                              /* int */ sourceStart,
                              /* int */ sourceLength) {

        var /* int */ destSize = sourceLength;

        switch (this.options & this.LETTERS_MASK) {
        case this.LETTERS_SHAPE:
        case this.LETTERS_SHAPE_TASHKEEL_ISOLATED:
            if (this.isLogical) {
                for (var /* int */ i = sourceStart, e = sourceStart + sourceLength - 1; i < e; ++i) {
                    if ((source[i] == this.LAM_CHAR && this.isAlefChar(source[i+1])) || this.isTashkeelCharFE(source[i])){
                        --destSize;
                    }
                }
            } else { // visual
                for(var /* int */ i = sourceStart + 1, e = sourceStart + sourceLength; i < e; ++i) {
                    if ((source[i] == this.LAM_CHAR && this.isAlefChar(source[i-1])) || this.isTashkeelCharFE(source[i])) {
                        --destSize;
                    }
                }
            }
            break;

        case this.LETTERS_UNSHAPE:
            for(var /* int */ i = sourceStart, e = sourceStart + sourceLength; i < e; ++i) {
                if (this.isLamAlefChar(source[i])) {
                    destSize++;
                }
            }
            break;

        default:
            break;
        }

        return destSize;
    }


    /*
     * Name    : countSpaceSub
     * Function: Counts number of times the subChar appears in the array
     */
    function /* private static int */ countSpaceSub(/* char [] */ dest, /* int */ length, /* char */ subChar){
        var /* int */ i = 0;
        var /* int */ count = 0;
        while (i < length) {
            if (dest[i] == subChar) {
                count++;
            }
            i++;
        }
        return count;
    }

    /*
     * Name    : copyArray
     * Function: Copies array to other array
     */
    function /* private static void */ copyArray(/* char [] */ source, /* int */ sourceStart, /* char [] */ dest, /* int */ destStart, /* int */ length)
    {
        for (var i = 0; i < length; i += 1)
        {
            dest[destStart + i] = source[sourceStart + i];
        }
    }

    /*
     * Name    : shiftArray
     * Function: Shifts characters to replace space sub characters
     */
    function /* private static void */ shiftArray(/* char [] */ dest, /* int */ start, /* int */ e, /* char */ subChar){
        var /* int */ w = e;
        var /* int */ r = e;
        while (--r >= start) {
            var /* char */ ch = dest[r];
            if (ch != subChar) {
                --w;
                if (w != r) {
                    dest[w] = ch;
                }
            }
        }
   }

    /*
     * Name    : flipArray
     * Function: inverts array, so that start becomes end and vice versa
     */
    function /* private static int */ flipArray(/* char [] */ dest, /* int */ start, /* int */ e, /* int */ w){
        var /* int */ r;
        if (w > start) {
            // shift, assume small buffer size so don't use arraycopy
            r = w;
            w = start;
            while (r < e) {
                dest[w++] = dest[r++];
            }
        } else {
            w = e;
        }
        return w;
      }


    /*
     * Name     : handleTashkeelWithTatweel
     * Function : Replaces Tashkeel as following:
     *            Case 1 :if the Tashkeel on tatweel, replace it with Tatweel.
     *            Case 2 :if the Tashkeel aggregated with Shadda on Tatweel, replace
     *                   it with Shadda on Tatweel.
     *            Case 3: if the Tashkeel is isolated replace it with Space.
     *
     */
    function /* private static int */ handleTashkeelWithTatweel(/* char[] */ dest, /* int */ sourceLength) {
        var /* int */ i;
        for(i = 0; i < sourceLength; i++){
            if((this.isTashkeelOnTatweelChar(dest[i]) == 1)){
                dest[i] = this.TATWEEL_CHAR;
            }else if((this.isTashkeelOnTatweelChar(dest[i]) == 2)){
                dest[i] = this.SHADDA_TATWEEL_CHAR;
            }else if((this.isIsolatedTashkeelChar(dest[i])==1) && dest[i] != this.SHADDA_CHAR){
                dest[i] = this.SPACE_CHAR;
            }
        }
        return sourceLength;
    }


    /*
     *Name     : handleGeneratedSpaces
     *Function : The shapeUnicode function converts Lam + Alef into LamAlef + space,
     *           and Tashkeel to space.
     *           handleGeneratedSpaces function puts these generated spaces
     *           according to the options the user specifies. LamAlef and Tashkeel
     *           spaces can be replaced at begin, at end, at near or decrease the
     *           buffer size.
     *
     *           There is also Auto option for LamAlef and tashkeel, which will put
     *           the spaces at end of the buffer (or end of text if the user used
     *           the option this.SPACES_RELATIVE_TO_TEXT_BEGIN_END).
     *
     *           If the text type was visual_LTR and the option
     *           this.SPACES_RELATIVE_TO_TEXT_BEGIN_END was selected the END
     *           option will place the space at the beginning of the buffer and
     *           BEGIN will place the space at the end of the buffer.
     */
    function /* private int */ handleGeneratedSpaces(/* char[] */ dest,
            /* int */ start,
            /* int */ length) {

        var /* int */ lenOptionsLamAlef = this.options & this.LAMALEF_MASK;
        var /* int */ lenOptionsTashkeel = this.options & this.TASHKEEL_MASK;
        var /* boolean */ lamAlefOn = false;
        var /* boolean */ tashkeelOn = false;
    
        if (!this.isLogical & !this.spacesRelativeToTextBeginEnd) {
            switch (lenOptionsLamAlef) {
                case this.LAMALEF_BEGIN: lenOptionsLamAlef = this.LAMALEF_END; break;
                case this.LAMALEF_END: lenOptionsLamAlef = this.LAMALEF_BEGIN; break;
                default: break;
            }
            switch (lenOptionsTashkeel){
                case this.TASHKEEL_BEGIN: lenOptionsTashkeel = this.TASHKEEL_END; break;
                case this.TASHKEEL_END: lenOptionsTashkeel = this.TASHKEEL_BEGIN; break;
                default: break;
            }
        }
    
    
        if (lenOptionsLamAlef == this.LAMALEF_NEAR) {
            for (var /* int */ i = start, e = i + length; i < e; ++i) {
                if (dest[i] == this.LAMALEF_SPACE_SUB) {
                    dest[i] = this.SPACE_CHAR;
                }
            }
    
        } else {
    
            var /* final int */ e = start + length;
            var /* int */ wL = this.countSpaceSub(dest, length, this.LAMALEF_SPACE_SUB);
            var /* int */ wT = this.countSpaceSub(dest, length, this.TASHKEEL_SPACE_SUB);
    
            if (lenOptionsLamAlef == this.LAMALEF_END){
                lamAlefOn = true;
            }
            if (lenOptionsTashkeel == this.TASHKEEL_END){
                tashkeelOn = true;
            }
    
    
            if (lamAlefOn && (lenOptionsLamAlef == this.LAMALEF_END)) {
                this.shiftArray(dest, start, e, this.LAMALEF_SPACE_SUB);
                while (wL > start) {
                    dest[--wL] = this.SPACE_CHAR;
                }
            }
    
            if (tashkeelOn && (lenOptionsTashkeel == this.TASHKEEL_END)){
                this.shiftArray(dest, start, e, this.TASHKEEL_SPACE_SUB);
                while (wT > start) {
                     dest[--wT] = this.SPACE_CHAR;
                }
            }
    
            lamAlefOn = false;
            tashkeelOn = false;
    
            if (lenOptionsLamAlef == this.LAMALEF_RESIZE){
                lamAlefOn = true;
            }
            if (lenOptionsTashkeel == this.TASHKEEL_RESIZE){
                tashkeelOn = true;
            }
    
            if (lamAlefOn && (lenOptionsLamAlef == this.LAMALEF_RESIZE)){
                this.shiftArray(dest, start, e, this.LAMALEF_SPACE_SUB);
                wL = this.flipArray(dest,start,e, wL);
                length = wL - start;
            }
            if (tashkeelOn && (lenOptionsTashkeel == this.TASHKEEL_RESIZE)) {
                this.shiftArray(dest, start, e, this.TASHKEEL_SPACE_SUB);
                wT = this.flipArray(dest,start,e, wT);
                length = wT - start;
            }
    
            lamAlefOn = false;
            tashkeelOn = false;
    
            if ((lenOptionsLamAlef == this.LAMALEF_BEGIN) ||
                (lenOptionsLamAlef == this.LAMALEF_AUTO)){
                lamAlefOn = true;
            }
            if (lenOptionsTashkeel == this.TASHKEEL_BEGIN){
                tashkeelOn = true;
            }
    
            if (lamAlefOn && ((lenOptionsLamAlef == this.LAMALEF_BEGIN)||
                            (lenOptionsLamAlef == this.LAMALEF_AUTO))) { // spaces at beginning
                this.shiftArray(dest, start, e, this.LAMALEF_SPACE_SUB);
                wL = this.flipArray(dest,start,e, wL);
                while (wL < e) {
                    dest[wL++] = this.SPACE_CHAR;
                }
            }
            if(tashkeelOn && (lenOptionsTashkeel == this.TASHKEEL_BEGIN)){
                this.shiftArray(dest, start, e, this.TASHKEEL_SPACE_SUB);
                wT = this.flipArray(dest,start,e, wT);
                while (wT < e) {
                    dest[wT++] = this.SPACE_CHAR;
                }
            }
        }
    
        return length;
    }

  /*
   *Name     :expandCompositCharAtBegin
   *Function :Expands the LamAlef character to Lam and Alef consuming the required
   *         space from beginning of the buffer. If the text type was visual_LTR
   *         and the option this.SPACES_RELATIVE_TO_TEXT_BEGIN_END was selected
   *         the spaces will be located at end of buffer.
   *         If there are no spaces to expand the LamAlef, an exception is thrown.
   */
    function /* private boolean */ expandCompositCharAtBegin(/* char[] */ dest, /* int */ start, /* int */ length,
                            /* int */ lacount) {
        var /* boolean */ spaceNotFound = false;

        if (lacount > this.countSpacesRight(dest, start, length)) {
            spaceNotFound = true;
            return spaceNotFound;
        }
        for (var /* int */ r = start + length - lacount, w = start + length; --r >= start;) {
            var /* char */ ch = dest[r];
            if (this.isNormalizedLamAlefChar(ch)) {
                dest[--w] = this.LAM_CHAR;
                dest[--w] = this.convertNormalizedLamAlef[ch - 0x065C];
            } else {
                dest[--w] = ch;
            }
        }
        return spaceNotFound;

    }

  /*
   *Name     : expandCompositCharAtEnd
   *Function : Expands the LamAlef character to Lam and Alef consuming the
   *           required space from end of the buffer. If the text type was
   *           Visual LTR and the option this.SPACES_RELATIVE_TO_TEXT_BEGIN_END
   *           was used, the spaces will be consumed from begin of buffer. If
   *           there are no spaces to expand the LamAlef, an exception is thrown.
   */

    function /* private boolean */  expandCompositCharAtEnd(/* char[] */ dest, /* int */ start, /* int */ length,
                          /* int */ lacount){
        var /*boolean*/ spaceNotFound = false;

        if (lacount > this.countSpacesLeft(dest, start, length)) {
            spaceNotFound = true;
            return spaceNotFound;
        }
        for (var /* int */ r = start + lacount, w = start, e = start + length; r < e; ++r) {
            var /* char */ ch = dest[r];
            if (this.isNormalizedLamAlefChar(ch)) {
                dest[w++] = this.convertNormalizedLamAlef[ch - 0x065C];
                dest[w++] = this.LAM_CHAR;
            } else {
                dest[w++] = ch;
            }
        }
        return spaceNotFound;
    }

  /*
   *Name     : expandCompositCharAtNear
   *Function : Expands the LamAlef character into Lam + Alef, YehHamza character
   *           into Yeh + Hamza, SeenFamily character into SeenFamily character
   *           + Tail, while consuming the space next to the character.
   */

    function /* private boolean */ expandCompositCharAtNear(/* char[] */ dest, /* int */ start, /* int */ length,
                                       /* int */ yehHamzaOption, /* int */ seenTailOption, /* int */ lamAlefOption){

        var /* boolean */ spaceNotFound = false;



        if (this.isNormalizedLamAlefChar(dest[start])) {
            spaceNotFound = true;
            return spaceNotFound;
        }
        for (var /* int */ i = start + length; --i >=start;) {
            var /* char */ ch = dest[i];
            if (lamAlefOption == 1 && this.isNormalizedLamAlefChar(ch)) {
                if (i>start &&dest[i-1] == this.SPACE_CHAR) {
                    dest[i] = this.LAM_CHAR;
                    dest[--i] = this.convertNormalizedLamAlef[ch - 0x065C];
                } else {
                    spaceNotFound = true;
                    return spaceNotFound;
                }
            }else if(seenTailOption == 1 && this.isSeenTailFamilyChar(ch) == 1){
                if(i>start &&dest[i-1] == this.SPACE_CHAR){
                    dest[i-1] = this.tailChar;
                } else{
                    spaceNotFound = true;
                    return spaceNotFound;
                }
            }else if(yehHamzaOption == 1 && this.isYehHamzaChar(ch)){
  
                if(i>start &&dest[i-1] == this.SPACE_CHAR){
                    dest[i] = this.yehHamzaToYeh[ch - this.YEH_HAMZAFE_CHAR];
                    dest[i-1] = this.HAMZAFE_CHAR;
                }else{
                    spaceNotFound = true;
                    return spaceNotFound;
                }
  
  
            }
        }
        return false;

    }

    /*
     * Name    : expandCompositChar
     * Function: LamAlef needs special handling as the LamAlef is
     *           one character while expanding it will give two
     *           characters Lam + Alef, so we need to expand the LamAlef
     *           in near or far spaces according to the options the user
     *           specifies or increase the buffer size.
     *           Dest has enough room for the expansion if we are growing.
     *           lamalef are normalized to the 'special characters'
     */
    function /* private int */ expandCompositChar(/* char[] */ dest,
                              /* int */ start,
                              /* int */ length,
                              /* int */ lacount,
                              /* int */ shapingMode) /* throws ArabicShapingException */ {

        var /* int */ lenOptionsLamAlef = this.options & this.LAMALEF_MASK;
        var /* int */ lenOptionsSeen = this.options & this.SEEN_MASK;
        var /* int */ lenOptionsYehHamza = this.options & this.YEHHAMZA_MASK;
        var /* boolean */ spaceNotFound = false;

        if (!this.isLogical && !this.spacesRelativeToTextBeginEnd) {
            switch (lenOptionsLamAlef) {
                case this.LAMALEF_BEGIN: lenOptionsLamAlef = this.LAMALEF_END; break;
                case this.LAMALEF_END: lenOptionsLamAlef = this.LAMALEF_BEGIN; break;
                default: break;
            }
        }

        if(shapingMode == 1){
            if(lenOptionsLamAlef == this.LAMALEF_AUTO){
                if(this.isLogical){
                    spaceNotFound = this.expandCompositCharAtEnd(dest, start, length, lacount);
                    if(spaceNotFound){
                        spaceNotFound = this.expandCompositCharAtBegin(dest, start, length, lacount);
                    }
                    if(spaceNotFound){
                        spaceNotFound = this.expandCompositCharAtNear(dest, start, length,0,0,1);
                    }
                    if(spaceNotFound){
                        throw new global.ArabicShapingException("No spacefor lamalef");
                    }
                }else{
                    spaceNotFound = this.expandCompositCharAtBegin(dest, start, length, lacount);
                    if(spaceNotFound){
                        spaceNotFound = this.expandCompositCharAtEnd(dest, start, length, lacount);
                    }
                    if(spaceNotFound){
                        spaceNotFound = this.expandCompositCharAtNear(dest, start, length,0,0,1);
                    }
                    if(spaceNotFound){
                        throw new global.ArabicShapingException("No spacefor lamalef");
                    }
                }
            }else if(lenOptionsLamAlef == this.LAMALEF_END){
                spaceNotFound = this.expandCompositCharAtEnd(dest, start, length, lacount);
                if(spaceNotFound){
                    throw new global.ArabicShapingException("No spacefor lamalef");
                }
            }else if(lenOptionsLamAlef == this.LAMALEF_BEGIN){
                spaceNotFound = this.expandCompositCharAtBegin(dest, start, length, lacount);
                if(spaceNotFound){
                    throw new global.ArabicShapingException("No spacefor lamalef");
                }
            }else if(lenOptionsLamAlef == this.LAMALEF_NEAR){
                spaceNotFound = this.expandCompositCharAtNear(dest, start, length,0,0,1);
                if(spaceNotFound){
                    throw new global.ArabicShapingException("No spacefor lamalef");
            }
            }else if(lenOptionsLamAlef == this.LAMALEF_RESIZE){
                for (var /* int */ r = start + length, w = r + lacount; --r >= start;) {
                    var /* char */ ch = dest[r];
                    if (this.isNormalizedLamAlefChar(ch)) {
                        dest[--w] = 0x0644;
                        dest[--w] = this.convertNormalizedLamAlef[ch - 0x065C];
                    } else {
                        dest[--w] = ch;
                    }
                }
                length += lacount;
            }
            }else{
                if(lenOptionsSeen == this.SEEN_TWOCELL_NEAR){
                spaceNotFound = this.expandCompositCharAtNear(dest, start, length,0,1,0);
                if(spaceNotFound){
                    throw new global.ArabicShapingException("No space for Seen tail expansion");
                }
            }
            if(lenOptionsYehHamza == this.YEHHAMZA_TWOCELL_NEAR){
                spaceNotFound = this.expandCompositCharAtNear(dest, start, length,1,0,0);
                if(spaceNotFound){
                    throw new global.ArabicShapingException("No space for YehHamza expansion");
                }
            }
        }
        return length;
    }


    /* Convert the input buffer from FExx Range into 06xx Range
     * to put all characters into the 06xx range
     * even the lamalef is converted to the special region in
     * the 06xx range.  Return the number of lamalef chars found.
     */
    function /* private int */ normalize(/* char[] */ dest, /* int */ start, /* int */ length) {
        var /* int */ lacount = 0;
        for (var /* int */ i = start, e = i + length; i < e; ++i) {
            var /* char */ ch = dest[i];
            if (ch >= 0xFE70 && ch <= 0xFEFC) {
                if (this.isLamAlefChar(ch)) {
                    ++lacount;
                }
                dest[i] = /* (char) */ this.convertFEto06[ch - 0xFE70];
            }
        }
        return lacount;
    }


    /*
     * Name    : deshapeNormalize
     * Function: Convert the input buffer from FExx Range into 06xx Range
     *           even the lamalef is converted to the special region in the 06xx range.
     *           According to the options the user enters, all seen family characters
     *           followed by a tail character are merged to seen tail family character and
     *           any yeh followed by a hamza character are merged to yehhamza character.
     *           Method returns the number of lamalef chars found.
     */
    function /* private int */ deshapeNormalize(/* char[] */ dest, /* int */ start, /* int */ length) {
        var /* int */ lacount = 0;
        var /* int */ yehHamzaComposeEnabled = 0;
        var /* int */ seenComposeEnabled = 0;

        yehHamzaComposeEnabled = ((this.options&this.YEHHAMZA_MASK) == this.YEHHAMZA_TWOCELL_NEAR) ? 1 : 0;
        seenComposeEnabled = ((this.options&this.SEEN_MASK) == this.SEEN_TWOCELL_NEAR) ? 1 : 0;

        for (var /* int */ i = start, e = i + length; i < e; ++i) {
            var /* char */ ch = dest[i];

            if( (yehHamzaComposeEnabled == 1) && ((ch == this.HAMZA06_CHAR) || (ch == this.HAMZAFE_CHAR))
               && (i < (length - 1)) && this.isAlefMaksouraChar(dest[i+1] )) {
                dest[i] = this.SPACE_CHAR;
                dest[i+1] = this.YEH_HAMZA_CHAR;
            } else if ( (seenComposeEnabled == 1) && (this.isTailChar(ch)) && (i< (length - 1))
                       && (this.isSeenTailFamilyChar(dest[i+1])==1) ) {
                 dest[i] = this.SPACE_CHAR;
            }
            else if (ch >= 0xFE70 && ch <= 0xFEFC) {
                if (this.isLamAlefChar(ch)) {
                    ++lacount;
                }
                dest[i] = /* (char) */ this.convertFEto06[ch - 0xFE70];
            }
        }
        return lacount;
    }


    /*
     * Name    : shapeUnicode
     * Function: Converts an Arabic Unicode buffer in 06xx Range into a shaped
     *           arabic Unicode buffer in FExx Range
     */
    function /* private int */ shapeUnicode(/* char[] */ dest,
                             /* int */ start,
                             /* int */ length,
                             /* int */ destSize,
                             /* int */ tashkeelFlag) /* throws ArabicShapingException */ {

        var /* int */ lamalef_count = this.normalize(dest, start, length);

        // resolve the link between the characters.
        // Arabic characters have four forms: Isolated, Initial, Medial and Final.
        // Tashkeel characters have two, isolated or medial, and sometimes only isolated.
        // tashkeelFlag == 0: shape normally, 1: shape isolated, 2: don't shape

        var /* boolean */ lamalef_found = false, seenfam_found = false;
        var /* boolean */ yehhamza_found = false, tashkeel_found = false;
        var /* int */ i = start + length - 1;
        var /* int */ currLink = this.getLink(dest[i]);
        var /* int */ nextLink = 0;
        var /* int */ prevLink = 0;
        var /* int */ lastLink = 0;
        // var /* int */ prevPos = i;
        var /* int */ lastPos = i;
        var /* int */ nx = -2;
        var /* int */ nw = 0;

        while (i >= 0) {
            // If high byte of currLink != 0 then there might be more than one shape
            if ((currLink & 0xFF00) != 0 || this.isTashkeelChar(dest[i])) {
                nw = i - 1;
                nx = -2;
                while (nx < 0) { // we need to know about next char
                    if (nw == -1) {
                        nextLink = 0;
                        nx = 0x7fffffff /* Integer.MAX_VALUE */;
                    } else {
                        nextLink = this.getLink(dest[nw]);
                        if ((nextLink & this.IRRELEVANT) == 0) {
                            nx = nw;
                        } else {
                            --nw;
                        }
                    }
                }

                if (((currLink & this.ALEFTYPE) > 0) && ((lastLink & this.LAMTYPE) > 0)) {
                    lamalef_found = true;
                    var /* char */ wLamalef = this.changeLamAlef(dest[i]); // get from 0x065C-0x065f
                    if (wLamalef != 0x0000) {
                        // replace alef by marker, it will be removed later
                        dest[i] = 0xffff;
                        dest[lastPos] = wLamalef;
                        i = lastPos;
                    }

                    lastLink = prevLink;
                    currLink = this.getLink(wLamalef); // requires 0x0000, unfortunately
                }
                if ((i > 0) && (dest[i-1] == this.SPACE_CHAR))
                {
                    if ( this.isSeenFamilyChar(dest[i]) == 1){
                        seenfam_found = true;
                    } else if (dest[i] == this.YEH_HAMZA_CHAR) {
                        yehhamza_found = true;
                    }
                }
                else if(i==0){
                    if ( this.isSeenFamilyChar(dest[i]) == 1){
                        seenfam_found = true;
                    } else if (dest[i] == this.YEH_HAMZA_CHAR) {
                        yehhamza_found = true;
                    }
                }


                // get the proper shape according to link ability of neighbors
                // and of character; depends on the order of the shapes
                // (isolated, initial, middle, final) in the compatibility area

                var /* int */ flag = this.specialChar(dest[i]);

                var /* int */ shape = this.shapeTable[nextLink & this.LINK_MASK]
                    [lastLink & this.LINK_MASK]
                    [currLink & this.LINK_MASK];

                if (flag == 1) {
                    shape &= 0x1;
                } else if (flag == 2) {
                    if (tashkeelFlag == 0 &&
                        ((lastLink & this.LINKL) != 0) &&
                        ((nextLink & this.LINKR) != 0) &&
                        dest[i] != 0x064C &&
                        dest[i] != 0x064D &&
                        !((nextLink & this.ALEFTYPE) == this.ALEFTYPE &&
                          (lastLink & this.LAMTYPE) == this.LAMTYPE)) {

                        shape = 1;

                    } else if(tashkeelFlag == 2 && dest[i] == this.SHADDA06_CHAR){
                        shape = 1;

                    } else {
                        shape = 0;
                    }
                }
                if (flag == 2) {
                    if (tashkeelFlag == 2 && dest[i] != this.SHADDA06_CHAR) {
                        dest[i] = this.TASHKEEL_SPACE_SUB;
                        tashkeel_found = true;
                    }
                    else{
                        dest[i] = /* (char) */ (0xFE70 + this.irrelevantPos[dest[i] - 0x064B] + shape);
                    }
                    // else leave tashkeel alone
                } else {
                    dest[i] = /* (char) */ (0xFE70 + (currLink >> 8) + shape);
                }
            }

            // move one notch forward
            if ((currLink & this.IRRELEVANT) == 0) {
                prevLink = lastLink;
                lastLink = currLink;
                // prevPos = lastPos;
                lastPos = i;
            }

            --i;
            if (i == nx) {
                currLink = nextLink;
                nx = -2;
            } else if (i != -1) {
                currLink = this.getLink(dest[i]);
            }
        }

        // If we found a lam/alef pair in the buffer
        // call handleGeneratedSpaces to remove the spaces that were added

        destSize = length;
        if (lamalef_found || tashkeel_found) {
            destSize = this.handleGeneratedSpaces(dest, start, length);
        }
        if (seenfam_found || yehhamza_found){
            destSize = this.expandCompositChar(dest, start, destSize, lamalef_count, this.SHAPE_MODE);
        }
        return destSize;
    }


    /*
     * Name    : deShapeUnicode
     * Function: Converts an Arabic Unicode buffer in FExx Range into unshaped
     *           arabic Unicode buffer in 06xx Range
     */
    function /* private int */ deShapeUnicode(/* char[] */ dest,
                               /* int */ start,
                               /* int */ length,
                               /* int */ destSize) /* throws ArabicShapingException */ {

        var /* int */ lamalef_count = this.deshapeNormalize(dest, start, length);

        // If there was a lamalef in the buffer call expandLamAlef
        if (lamalef_count != 0) {
            // need to adjust dest to fit expanded buffer... !!!
            destSize = this.expandCompositChar(dest, start, length, lamalef_count,this.DESHAPE_MODE);
        } else {
            destSize = length;
        }

        return destSize;
    }


    function /* private int */ internalShape(/* char[] */ source,
                              /* int */ sourceStart,
                              /* int */ sourceLength,
                              /* char[] */ dest,
                              /* int */ destStart,
                              /* int */ destSize) /* throws ArabicShapingException */ {

        if (sourceLength == 0) {
            return 0;
        }

        if (destSize == 0) {
            if (((this.options & this.LETTERS_MASK) != this.LETTERS_NOOP) &&
                ((this.options & this.LAMALEF_MASK) == this.LAMALEF_RESIZE)) {

                return this.calculateSize(source, sourceStart, sourceLength);
            } else {
                return sourceLength; // by definition
            }
        }

        // always use temp buffer
        var /* char[] */ temp = [] /* new char[sourceLength * 2] */; // all lamalefs requiring expansion
        for (var i = 0; i < sourceLength * 2; i += 1) {
            temp.add(0x0000);
        }
        this.copyArray(source, sourceStart, temp, 0, sourceLength);

        if (this.isLogical) {
            this.invertBuffer(temp, 0, sourceLength);
        }

        var /* int */ outputSize = sourceLength;

        switch (this.options & this.LETTERS_MASK) {
        case this.LETTERS_SHAPE_TASHKEEL_ISOLATED:
            outputSize = this.shapeUnicode(temp, 0, sourceLength, destSize, 1);
            break;

        case this.LETTERS_SHAPE:
            if( ((this.options&this.TASHKEEL_MASK) != 0) &&
                ((this.options&this.TASHKEEL_MASK) !=this.TASHKEEL_REPLACE_BY_TATWEEL)) {
                   /* Call the shaping function with tashkeel flag == 2 for removal of tashkeel */
                    outputSize = this.shapeUnicode(temp, 0, sourceLength, destSize, 2);
                }else {
                    //default Call the shaping function with tashkeel flag == 1 */
                    outputSize = this.shapeUnicode(temp, 0, sourceLength, destSize, 0);

                    /*After shaping text check if user wants to remove tashkeel and replace it with tatweel*/
                    if( (this.options&this.TASHKEEL_MASK) == this.TASHKEEL_REPLACE_BY_TATWEEL){
                        outputSize = this.handleTashkeelWithTatweel(temp,sourceLength);
                    }
               }
            break;

        case this.LETTERS_UNSHAPE:
            outputSize = this.deShapeUnicode(temp, 0, sourceLength, destSize);
            break;

        default:
            break;
        }

        if (outputSize > destSize) {
            throw new global.ArabicShapingException("not enough room for result data");
        }

        if ((this.options & this.DIGITS_MASK) != this.DIGITS_NOOP) {
            var /* char */ digitBase = 0x0030; // European digits
            switch (this.options & this.DIGIT_TYPE_MASK) {
            case this.DIGIT_TYPE_AN:
                digitBase = 0x0660;  // Arabic-Indic digits
                break;

            case this.DIGIT_TYPE_AN_EXTENDED:
                digitBase = 0x06f0;  // Eastern Arabic-Indic digits (Persian and Urdu)
                break;

            default:
                break;
            }

            switch (this.options & this.DIGITS_MASK) {
            case this.DIGITS_EN2AN:
                {
                    var /* int */ digitDelta = digitBase - 0x0030;
                    for (var /* int */ i = 0; i < outputSize; ++i) {
                        var /* char */ ch = temp[i];
                        if (ch <= 0x0039 && ch >= 0x0030) {
                            temp[i] += digitDelta;
                        }
                    }
                }
                break;

            case this.DIGITS_AN2EN:
                {
                    var /* char */ digitTop = /* (char) */ (digitBase + 9);
                    var /* int */ digitDelta = 0x0030 - digitBase;
                    for (var /* int */ i = 0; i < outputSize; ++i) {
                        var /* char */ ch = temp[i];
                        if (ch <= digitTop && ch >= digitBase) {
                            temp[i] += digitDelta;
                        }
                    }
                }
                break;

            case this.DIGITS_EN2AN_INIT_LR:
                this.shapeToArabicDigitsWithContext(temp, 0, outputSize, digitBase, false);
                break;

            case this.DIGITS_EN2AN_INIT_AL:
                this.shapeToArabicDigitsWithContext(temp, 0, outputSize, digitBase, true);
                break;

            default:
                break;
            }
        }

        if (this.isLogical) {
            this.invertBuffer(temp, 0, outputSize);
        }

        
        this.copyArray(temp, 0, dest, destStart, outputSize);

        return outputSize;
    }



}

@if(0)
// Tests
{
    var err = global.Debug.message;
    var errln = global.Debug.message;
    var assertEquals = function(msg, lval, rval)
    {
        if (lval !== rval)
        {
            global.Debug.message(msg);
        }
    };
    var assertTrue = function(msg, lval, rval)
    {
        if (lval !== true)
        {
            global.Debug.message(msg);
        }
    };

    /* constants copied from ArabicShaping for convenience */

    var LENGTH_GROW_SHRINK = 0;
    var LENGTH_FIXED_SPACES_NEAR = 1;
    var LENGTH_FIXED_SPACES_AT_END = 2;
    var LENGTH_FIXED_SPACES_AT_BEGINNING = 3;

    var TEXT_DIRECTION_LOGICAL = 0;
    var TEXT_DIRECTION_VISUAL_LTR = 4;

    var LETTERS_NOOP = 0;
    var LETTERS_SHAPE = 8;
    var LETTERS_SHAPE_TASHKEEL_ISOLATED = 0x18;
    var LETTERS_UNSHAPE = 0x10;

    var DIGITS_NOOP = 0;
    var DIGITS_EN2AN = 0x20;
    var DIGITS_AN2EN = 0x40;
    var DIGITS_EN2AN_INIT_LR = 0x60;
    var DIGITS_EN2AN_INIT_AL = 0x80;
    var DIGITS_RESERVED = 0xa0;

    var DIGIT_TYPE_AN = 0;
    var DIGIT_TYPE_AN_EXTENDED = 0x100;

    // Some extra constants copied
    var TEXT_DIRECTION_VISUAL_RTL = 0;
    var TASHKEEL_BEGIN = 0x40000;
    var TASHKEEL_END = 0x60000;
    var TASHKEEL_RESIZE = 0x80000;
    var TASHKEEL_REPLACE_BY_TATWEEL = 0xC0000;

    // $$ ArabicShapingRegTest

    // TestEquals
    var /* ArabicShaping */ as1 = new global.ArabicShaping(LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_NEAR);
    var /* ArabicShaping */ as2 = new global.ArabicShaping(LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_NEAR);
    var /* ArabicShaping */ as3 = new global.ArabicShaping(LETTERS_UNSHAPE | TEXT_DIRECTION_LOGICAL | LENGTH_FIXED_SPACES_AT_BEGINNING);

    if (! as1.equals(as1)) {
        err("as1: " + as1 + " does not equal itself!\n");
    }

    if (! as1.equals(as2)) {
        err("as1: " + as1 + ", as2: " + as2 + " are not equal, but should be.\n");
    }

    if (as1.equals(as3)) {
        err("as1: " + as1 + ", as3: " + as3 + " are equal but should not be.\n");
    }

    // TestShape
    // Tests when
    //      if (sourceStart < 0 || sourceLength < 0 || sourceStart + sourceLength > source.length)
    // Is true
    var /* ArabicShaping */ as = new global.ArabicShaping(0);
    var /* char[] */ source = [#'d',#'u',#'m',#'m',#'y'];
    var /* char[] */ dest = [#'d',#'u',#'m',#'m',#'y'];
    var /* int[] */ negNum = [-1,-2,-5,-10,-100];


    for(var /*int*/ i=0; i<negNum.count; i++){
        try{
            // Checks when "sourceStart < 0"
            as.shape(source, negNum[i], 0, dest, 0, 0);
            errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                    "suppose to return an exception when 'sourceStart < 0'.");
        } catch(/* Exception */ e){}

        try{
            // Checks when "sourceLength < 0"
            as.shape(source, 0, negNum[i], dest, 0, 0);
            errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                    "suppose to return an exception when 'sourceLength < 0'.");
        } catch(/* Exception */ e){}
    }

    // Checks when "sourceStart + sourceLength > source.length"
    try{
        as.shape(source, 3, 3, dest, 0, 0);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when 'sourceStart + sourceLength > source.length'.");
    } catch(/* Exception */ e){}
    try{
        as.shape(source, 2, 4, dest, 0, 0);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when 'sourceStart + sourceLength > source.length'.");
    } catch(/* Exception */ e){}
    try{
        as.shape(source, 1, 5, dest, 0, 0);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when 'sourceStart + sourceLength > source.length'.");
    } catch(/* Exception */ e){}
    try{
        as.shape(source, 0, 6, dest, 0, 0);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when 'sourceStart + sourceLength > source.length'.");
    } catch(/* Exception */ e){}

    // Checks when "if (dest == null && destSize != 0)" is true
    try{
        as.shape(source, 2, 2, null, 0, 1);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when 'dest == null && destSize != 0'.");
    } catch(/* Exception */ e){}

    // Checks when
    // if ((destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length))
    for(var /* int */ i=0; i<negNum.length; i++){
        try{
            as.shape(source, 2, 2, dest, negNum[i], 1);
            errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                    "suppose to return an exception when " +
                    "(destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length).");
        } catch(/* Exception */ e){}

        try{
            as.shape(source, 2, 2, dest, 0, negNum[i]);
            errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                    "suppose to return an exception when " +
                    "(destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length).");
        } catch(/* Exception */ e){}
    }

    // Checks when "destStart + destSize > dest.length"
    try{
        as.shape(source, 2, 2, dest, 3, 3);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when " +
                "(destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length).");
    } catch(/* Exception */ e){}
    try{
        as.shape(source, 2, 2, dest, 2, 4);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when " +
                "(destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length).");
    } catch(/* Exception */ e){}
    try{
        as.shape(source, 2, 2, dest, 1, 5);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when " +
                "(destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length).");
    } catch(/* Exception */ e){}
    try{
        as.shape(source, 2, 2, dest, 0, 6);
        errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                "suppose to return an exception when " +
                "(destSize != 0) && (destStart < 0 || destSize < 0 || destStart + destSize > dest.length).");
    } catch(/* Exception */ e){}

    // Tests when "throw new IllegalArgumentException("Wrong Tashkeel argument")"
    var /* int[] */ invalid_Tashkeel = [-1000, -500, -100];
    for(var /* int */ i=0; i < invalid_Tashkeel.count; i++){
        var /* ArabicShaping */ arabicShape = new global.ArabicShaping(invalid_Tashkeel[i]);
        try {
            arabicShape.shape(source,0,0,dest,0,1);
            errln("ArabicShaping.shape(char[],int,int,char[],int,int) was " +
                    "suppose to return an exception for 'Wrong Tashkeel argument' for " +
                    "an option value of " + invalid_Tashkeel[i]);
        } catch (/* Exception */ e) {}
    }

    // TestCoverage
    var /* ArabicShaping */ shp = new global.ArabicShaping(LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_NEAR);

    // Test ArabicShaping#toString();
    assertEquals("ArabicShaping#toString() failed.",
            shp.toString(),
            "[LamAlef spaces at near, visual, shape letters," +
                    " no digit shaping, standard Arabic-Indic digits]");

    // Test ArabicShaping#hashCode()
    assertEquals("ArabicShaping#hashCode() failed.", shp.hashCode(), 13);

    // TestHelperFunctions
    // Test private static helper functions that are used internally:

    // ArabicShaping.isSeenTailFamilyChar(char)
    assertTrue("ArabicShaping.isSeenTailFamilyChar(char) failed.",
            as.isSeenTailFamilyChar(0xfeb1));

    // ArabicShaping.isAlefMaksouraChar(char)
    assertTrue("ArabicShaping.isAlefMaksouraChar(char) failed.",
            as.isAlefMaksouraChar(0xfeef));

    // ArabicShaping.isTailChar(char)
    assertTrue("ArabicShaping.isTailChar(char) failed.",
            as.isTailChar(0x200B));

    // ArabicShaping.isYehHamzaChar(char)
    assertTrue("ArabicShaping.isYehHamzaChar(char) failed.",
            as.isYehHamzaChar(0xfe89));

    // $$DataDrivenArabicShapingRegTest

    // TestStandard
    {
        var testData = void;
        {
            var /* String */ lamAlefSpecialVLTR =
                "\x0020\x0646\x0622\x0644\x0627\x0020\x0646\x0623\x064E\x0644\x0627\x0020" +
                "\x0646\x0627\x0670\x0644\x0627\x0020\x0646\x0622\x0653\x0644\x0627\x0020" +
                "\x0646\x0625\x0655\x0644\x0627\x0020\x0646\x0622\x0654\x0644\x0627\x0020" +
                "\xFEFC\x0639";
            var /* String */ tashkeelSpecialVLTR =
                "\x064A\x0628\x0631\x0639\x0020\x064A\x0628\x0651\x0631\x064E\x0639\x0020" +
                "\x064C\x064A\x0628\x0631\x064F\x0639\x0020\x0628\x0670\x0631\x0670\x0639" +
                "\x0020\x0628\x0653\x0631\x0653\x0639\x0020\x0628\x0654\x0631\x0654\x0639" +
                "\x0020\x0628\x0655\x0631\x0655\x0639\x0020";
            var /* String */ tashkeelShaddaRTL=
                "\x0634\x0651\x0645\x0652\x0633";
            var /* String */ tashkeelShaddaLTR=
                "\x0633\x0652\x0645\x0651\x0634";
            var /* String */ ArMathSym =
                "\xD83B\xDE00\xD83B\xDE01\xD83B\xDE02\xD83B\xDE03\x0020\xD83B\xDE24\xD83B" +
                "\xDE05\xD83B\xDE06\x0020\xD83B\xDE07\xD83B\xDE08\xD83B\xDE09\x0020\xD83B" +
                "\xDE0A\xD83B\xDE0B\xD83B\xDE0C\xD83B\xDE0D\x0020\xD83B\xDE0E\xD83B\xDE0F" +
                "\xD83B\xDE10\xD83B\xDE11\x0020\xD83B\xDE12\xD83B\xDE13\xD83B\xDE14\xD83B" +
                "\xDE15\x0020\xD83B\xDE16\xD83B\xDE17\xD83B\xDE18\x0020\xD83B\xDE19\xD83B" +
                "\xDE1A\xD83B\xDE1B";
            var /* String */ ArMathSymLooped =
                "\xD83B\xDE80\xD83B\xDE81\xD83B\xDE82\xD83B\xDE83\x0020\xD83B\xDE84\xD83B" +
                "\xDE85\xD83B\xDE86\x0020\xD83B\xDE87\xD83B\xDE88\xD83B\xDE89\x0020\xD83B" +
                "\xDE8B\xD83B\xDE8C\xD83B\xDE8D\x0020\xD83B\xDE8E\xD83B\xDE8F\xD83B\xDE90" +
                "\xD83B\xDE91\x0020\xD83B\xDE92\xD83B\xDE93\xD83B\xDE94\xD83B\xDE95\x0020" +
                "\xD83B\xDE96\xD83B\xDE97\xD83B\xDE98\x0020\xD83B\xDE99\xD83B\xDE9A\xD83B" +
                "\xDE9B";
            var /* String */ ArMathSymDoubleStruck =
                "\xD83B\xDEA1\xD83B\xDEA2\xD83B\xDEA3\x0020\xD83B\xDEA5\xD83B\xDEA6\x0020" +
                "\xD83B\xDEA7\xD83B\xDEA8\xD83B\xDEA9\x0020\xD83B\xDEAB\xD83B\xDEAC\xD83B" +
                "\xDEAD\x0020\xD83B\xDEAE\xD83B\xDEAF\xD83B\xDEB0\xD83B\xDEB1\x0020\xD83B" +
                "\xDEB2\xD83B\xDEB3\xD83B\xDEB4\xD83B\xDEB5\x0020\xD83B\xDEB6\xD83B\xDEB7" +
                "\xD83B\xDEB8\x0020\xD83B\xDEB9\xD83B\xDEBA\xD83B\xDEBB";
            var /* String */ ArMathSymInitial =
                "\xD83B\xDE21\xD83B\xDE22\x0020\xD83B\xDE27\xD83B\xDE29\x0020\xD83B\xDE2A" +
                "\xD83B\xDE2B\xD83B\xDE2C\xD83B\xDE2D\x0020\xD83B\xDE2E\xD83B\xDE2F\xD83B" +
                "\xDE30\xD83B\xDE31\x0020\xD83B\xDE32\xD83B\xDE34\xD83B\xDE35\x0020\xD83B" +
                "\xDE36\xD83B\xDE37\x0020\xD83B\xDE39\xD83B\xDE3B";
            var /* String */ ArMathSymTailed =
                "\xD83B\xDE42\xD83B\xDE47\xD83B\xDE49\xD83B\xDE4B\x0020\xD83B\xDE4D\xD83B" +
                "\xDE4E\xD83B\xDE4F\x0020\xD83B\xDE51\xD83B\xDE52\xD83B\xDE54\xD83B\xDE57" +
                "\x0020\xD83B\xDE59\xD83B\xDE5B\xD83B\xDE5D\xD83B\xDE5F";
            var /* String */ ArMathSymStretched =
                "\xD83B\xDE21\x0633\xD83B\xDE62\x0647";
            var /* String */ logicalUnshape =
                "\x0020\x0020\x0020\xFE8D\xFEF5\x0020\xFEE5\x0020\xFE8D\xFEF7\x0020\xFED7" +
                "\xFEFC\x0020\xFEE1\x0020\xFE8D\xFEDF\xFECC\xFEAE\xFE91\xFEF4\xFE94\x0020" +
                "\xFE8D\xFEDF\xFEA4\xFEAE\xFE93\x0020\x0020\x0020\x0020";
            var /* String */ numSource =
                "\x0031" +  /* en:1 */
                "\x0627" +  /* arabic:alef */
                "\x0032" +  /* en:2 */
                "\x06f3" +  /* an:3 */
                "\x0061" +  /* latin:a */
                "\x0034";   /* en:4 */
            testData = [
                /* lam alef special visual ltr */
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_NEAR,
                 "\x0020\xfee5\x0020\xfef5\xfe8d\x0020\xfee5\x0020\xfe76\xfef7\xfe8d\x0020" +
                 "\xfee5\x0020\x0670\xfefb\xfe8d\x0020\xfee5\x0020\x0653\xfef5\xfe8d\x0020" +
                 "\xfee5\x0020\x0655\xfef9\xfe8d\x0020\xfee5\x0020\x0654\xfef5\xfe8d\x0020" +
                 "\xfefc\xfecb"],
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_AT_END,
                 "\x0020\xfee5\xfef5\xfe8d\x0020\xfee5\xfe76\xfef7\xfe8d\x0020\xfee5\x0670" +
                 "\xfefb\xfe8d\x0020\xfee5\x0653\xfef5\xfe8d\x0020\xfee5\x0655\xfef9\xfe8d" +
                 "\x0020\xfee5\x0654\xfef5\xfe8d\x0020\xfefc\xfecb\x0020\x0020\x0020\x0020" +
                 "\x0020\x0020"],
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_AT_BEGINNING,
                 "\x0020\x0020\x0020\x0020\x0020\x0020\x0020\xfee5\xfef5\xfe8d\x0020\xfee5" +
                 "\xfe76\xfef7\xfe8d\x0020\xfee5\x0670\xfefb\xfe8d\x0020\xfee5\x0653\xfef5" +
                 "\xfe8d\x0020\xfee5\x0655\xfef9\xfe8d\x0020\xfee5\x0654\xfef5\xfe8d\x0020" +
                 "\xfefc\xfecb"],
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_GROW_SHRINK,
                 "\x0020\xfee5\xfef5\xfe8d\x0020\xfee5\xfe76\xfef7\xfe8d\x0020\xfee5\x0670" +
                 "\xfefb\xfe8d\x0020\xfee5\x0653\xfef5\xfe8d\x0020\xfee5\x0655\xfef9\xfe8d" +
                 "\x0020\xfee5\x0654\xfef5\xfe8d\x0020\xfefc\xfecb"],
                /* TASHKEEL */
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE_TASHKEEL_ISOLATED | TEXT_DIRECTION_VISUAL_LTR |
                 LENGTH_FIXED_SPACES_NEAR,
                 "\x0020\xfee5\x0020\xfef5\xfe8d\x0020\xfee5\x0020\xfe76\xfef7\xfe8d\x0020" +
                 "\xfee5\x0020\x0670\xfefb\xfe8d\x0020\xfee5\x0020\x0653\xfef5\xfe8d\x0020" +
                 "\xfee5\x0020\x0655\xfef9\xfe8d\x0020\xfee5\x0020\x0654\xfef5\xfe8d\x0020" +
                 "\xfefc\xfecb"],
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE_TASHKEEL_ISOLATED | TEXT_DIRECTION_VISUAL_LTR |
                 LENGTH_FIXED_SPACES_AT_END,
                 "\x0020\xfee5\xfef5\xfe8d\x0020\xfee5\xfe76\xfef7\xfe8d\x0020\xfee5\x0670" +
                 "\xfefb\xfe8d\x0020\xfee5\x0653\xfef5\xfe8d\x0020\xfee5\x0655\xfef9\xfe8d" +
                 "\x0020\xfee5\x0654\xfef5\xfe8d\x0020\xfefc\xfecb\x0020\x0020\x0020\x0020" +
                 "\x0020\x0020"],
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE_TASHKEEL_ISOLATED | TEXT_DIRECTION_VISUAL_LTR |
                 LENGTH_FIXED_SPACES_AT_BEGINNING,
                 "\x0020\x0020\x0020\x0020\x0020\x0020\x0020\xfee5\xfef5\xfe8d\x0020\xfee5" +
                 "\xfe76\xfef7\xfe8d\x0020\xfee5\x0670\xfefb\xfe8d\x0020\xfee5\x0653\xfef5" +
                 "\xfe8d\x0020\xfee5\x0655\xfef9\xfe8d\x0020\xfee5\x0654\xfef5\xfe8d\x0020" +
                 "\xfefc\xfecb"],
                [lamAlefSpecialVLTR,
                 LETTERS_SHAPE_TASHKEEL_ISOLATED | TEXT_DIRECTION_VISUAL_LTR |
                 LENGTH_GROW_SHRINK,
                 "\x0020\xfee5\xfef5\xfe8d\x0020\xfee5\xfe76\xfef7\xfe8d\x0020\xfee5\x0670" +
                 "\xfefb\xfe8d\x0020\xfee5\x0653\xfef5\xfe8d\x0020\xfee5\x0655\xfef9\xfe8d" +
                 "\x0020\xfee5\x0654\xfef5\xfe8d\x0020\xfefc\xfecb"],
                /* tashkeel special visual ltr */
                [tashkeelSpecialVLTR,
                 LETTERS_SHAPE | TEXT_DIRECTION_VISUAL_LTR | LENGTH_FIXED_SPACES_NEAR,
                 "\xfef2\xfe91\xfeae\xfecb\x0020\xfef2\xfe91\xfe7c\xfeae\xfe77\xfecb\x0020" +
                 "\xfe72\xfef2\xfe91\xfeae\xfe79\xfecb\x0020\xfe8f\x0670\xfeae\x0670\xfecb" +
                 "\x0020\xfe8f\x0653\xfeae\x0653\xfecb\x0020\xfe8f\x0654\xfeae\x0654\xfecb" +
                 "\x0020\xfe8f\x0655\xfeae\x0655\xfecb\x0020"],
                [tashkeelSpecialVLTR,
                 LETTERS_SHAPE_TASHKEEL_ISOLATED | TEXT_DIRECTION_VISUAL_LTR |
                 LENGTH_FIXED_SPACES_NEAR,
                 "\xfef2\xfe91\xfeae\xfecb\x0020\xfef2\xfe91\xfe7c\xfeae\xfe76\xfecb\x0020" +
                 "\xfe72\xfef2\xfe91\xfeae\xfe78\xfecb\x0020\xfe8f\x0670\xfeae\x0670\xfecb" +
                 "\x0020\xfe8f\x0653\xfeae\x0653\xfecb\x0020\xfe8f\x0654\xfeae\x0654\xfecb" +
                 "\x0020\xfe8f\x0655\xfeae\x0655\xfecb\x0020"],
                [tashkeelShaddaRTL,
                 LETTERS_SHAPE | TASHKEEL_BEGIN |
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\x0020\xfeb7\xfe7d\xfee4\xfeb2"],
                [tashkeelShaddaRTL,
                 LETTERS_SHAPE | TASHKEEL_END |
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\xfeb7\xfe7d\xfee4\xfeb2\x0020"],
                [tashkeelShaddaRTL,
                 LETTERS_SHAPE | TASHKEEL_RESIZE |
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\xfeb7\xfe7d\xfee4\xfeb2"],
                [tashkeelShaddaRTL,
                 LETTERS_SHAPE | TASHKEEL_REPLACE_BY_TATWEEL |
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\xfeb7\xfe7d\xfee4\x0640\xfeb2"],
                [tashkeelShaddaLTR,
                 LETTERS_SHAPE | TASHKEEL_BEGIN |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\x0020\xfeb2\xfee4\xfe7d\xfeb7"],
                [tashkeelShaddaLTR,
                 LETTERS_SHAPE | TASHKEEL_END |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\xfeb2\xfee4\xfe7d\xfeb7\x0020"],
                [tashkeelShaddaLTR,
                 LETTERS_SHAPE | TASHKEEL_RESIZE |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\xfeb2\xfee4\xfe7d\xfeb7"],
                [tashkeelShaddaLTR,
                 LETTERS_SHAPE | TASHKEEL_REPLACE_BY_TATWEEL |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\xfeb2\x0640\xfee4\xfe7d\xfeb7"],
                [ArMathSym,
                 LETTERS_SHAPE | TASHKEEL_BEGIN |
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\xD83B\xDE00\xD83B\xDE01\xD83B\xDE02\xD83B\xDE03\x0020\xD83B\xDE24\xD83B" +
                 "\xDE05\xD83B\xDE06\x0020\xD83B\xDE07\xD83B\xDE08\xD83B\xDE09\x0020\xD83B" +
                 "\xDE0A\xD83B\xDE0B\xD83B\xDE0C\xD83B\xDE0D\x0020\xD83B\xDE0E\xD83B\xDE0F" +
                 "\xD83B\xDE10\xD83B\xDE11\x0020\xD83B\xDE12\xD83B\xDE13\xD83B\xDE14\xD83B" +
                 "\xDE15\x0020\xD83B\xDE16\xD83B\xDE17\xD83B\xDE18\x0020\xD83B\xDE19\xD83B" +
                 "\xDE1A\xD83B\xDE1B"],
                [ArMathSymLooped,
                 LETTERS_SHAPE | TASHKEEL_END |
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\xD83B\xDE80\xD83B\xDE81\xD83B\xDE82\xD83B\xDE83\x0020\xD83B\xDE84\xD83B" +
                 "\xDE85\xD83B\xDE86\x0020\xD83B\xDE87\xD83B\xDE88\xD83B\xDE89\x0020\xD83B" +
                 "\xDE8B\xD83B\xDE8C\xD83B\xDE8D\x0020\xD83B\xDE8E\xD83B\xDE8F\xD83B\xDE90" +
                 "\xD83B\xDE91\x0020\xD83B\xDE92\xD83B\xDE93\xD83B\xDE94\xD83B\xDE95\x0020" +
                 "\xD83B\xDE96\xD83B\xDE97\xD83B\xDE98\x0020\xD83B\xDE99\xD83B\xDE9A\xD83B" +
                 "\xDE9B"],
                [ArMathSymDoubleStruck,
                 LETTERS_SHAPE | TASHKEEL_RESIZE|
                 TEXT_DIRECTION_VISUAL_RTL,
                 "\xD83B\xDEA1\xD83B\xDEA2\xD83B\xDEA3\x0020\xD83B\xDEA5\xD83B\xDEA6\x0020" +
                 "\xD83B\xDEA7\xD83B\xDEA8\xD83B\xDEA9\x0020\xD83B\xDEAB\xD83B\xDEAC\xD83B" +
                 "\xDEAD\x0020\xD83B\xDEAE\xD83B\xDEAF\xD83B\xDEB0\xD83B\xDEB1\x0020\xD83B" +
                 "\xDEB2\xD83B\xDEB3\xD83B\xDEB4\xD83B\xDEB5\x0020\xD83B\xDEB6\xD83B\xDEB7" +
                 "\xD83B\xDEB8\x0020\xD83B\xDEB9\xD83B\xDEBA\xD83B\xDEBB"],
                [ArMathSymInitial,
                 LETTERS_SHAPE | TASHKEEL_BEGIN |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\xD83B\xDE21\xD83B\xDE22\x0020\xD83B\xDE27\xD83B\xDE29\x0020\xD83B\xDE2A" +
                 "\xD83B\xDE2B\xD83B\xDE2C\xD83B\xDE2D\x0020\xD83B\xDE2E\xD83B\xDE2F\xD83B" +
                 "\xDE30\xD83B\xDE31\x0020\xD83B\xDE32\xD83B\xDE34\xD83B\xDE35\x0020\xD83B" +
                 "\xDE36\xD83B\xDE37\x0020\xD83B\xDE39\xD83B\xDE3B"],
                [ArMathSymTailed,
                 LETTERS_SHAPE | TASHKEEL_END |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\xD83B\xDE42\xD83B\xDE47\xD83B\xDE49\xD83B\xDE4B\x0020\xD83B\xDE4D\xD83B" +
                 "\xDE4E\xD83B\xDE4F\x0020\xD83B\xDE51\xD83B\xDE52\xD83B\xDE54\xD83B\xDE57" +
                 "\x0020\xD83B\xDE59\xD83B\xDE5B\xD83B\xDE5D\xD83B\xDE5F"],
                [ArMathSymStretched,
                 LETTERS_SHAPE|TASHKEEL_RESIZE |
                 TEXT_DIRECTION_VISUAL_LTR,
                 "\xD83B\xDE21\xFEB1\xD83B\xDE62\xFEE9"],
                 /* logical unshape */
                [logicalUnshape,
                 LETTERS_UNSHAPE | TEXT_DIRECTION_LOGICAL | LENGTH_FIXED_SPACES_NEAR,
                 "\x0020\x0020\x0020\x0627\x0644\x0622\x0646\x0020\x0627\x0644\x0623\x0642" +
                 "\x0644\x0627\x0645\x0020\x0627\x0644\x0639\x0631\x0628\x064a\x0629\x0020" +
                 "\x0627\x0644\x062d\x0631\x0629\x0020\x0020\x0020\x0020"],
                [logicalUnshape,
                 LETTERS_UNSHAPE | TEXT_DIRECTION_LOGICAL | LENGTH_FIXED_SPACES_AT_END,
                 "\x0020\x0020\x0020\x0627\x0644\x0622\x0020\x0646\x0020\x0627\x0644\x0623" +
                 "\x0020\x0642\x0644\x0627\x0020\x0645\x0020\x0627\x0644\x0639\x0631\x0628" +
                 "\x064a\x0629\x0020\x0627\x0644\x062d\x0631\x0629\x0020"],
                [logicalUnshape,
                 LETTERS_UNSHAPE | TEXT_DIRECTION_LOGICAL | LENGTH_FIXED_SPACES_AT_BEGINNING,
                 "\x0627\x0644\x0622\x0020\x0646\x0020\x0627\x0644\x0623\x0020\x0642\x0644" +
                 "\x0627\x0020\x0645\x0020\x0627\x0644\x0639\x0631\x0628\x064a\x0629\x0020" +
                 "\x0627\x0644\x062d\x0631\x0629\x0020\x0020\x0020\x0020"],
                [logicalUnshape,
                 LETTERS_UNSHAPE | TEXT_DIRECTION_LOGICAL | LENGTH_GROW_SHRINK,
                 "\x0020\x0020\x0020\x0627\x0644\x0622\x0020\x0646\x0020\x0627\x0644\x0623" +
                 "\x0020\x0642\x0644\x0627\x0020\x0645\x0020\x0627\x0644\x0639\x0631\x0628" +
                 "\x064a\x0629\x0020\x0627\x0644\x062d\x0631\x0629\x0020\x0020\x0020\x0020"],
                /* numbers */
                [numSource,
                 DIGITS_EN2AN | DIGIT_TYPE_AN,
                 "\x0661\x0627\x0662\x06f3\x0061\x0664"],
                [numSource,
                 DIGITS_AN2EN | DIGIT_TYPE_AN_EXTENDED,
                "\x0031\x0627\x0032\x0033\x0061\x0034"],
                [numSource,
                 DIGITS_EN2AN_INIT_LR | DIGIT_TYPE_AN,
                 "\x0031\x0627\x0662\x06f3\x0061\x0034" ],
                [numSource,
                 DIGITS_EN2AN_INIT_AL | DIGIT_TYPE_AN_EXTENDED,
                 "\x06f1\x0627\x06f2\x06f3\x0061\x0034"],
                [numSource,
                 DIGITS_EN2AN_INIT_LR | DIGIT_TYPE_AN | TEXT_DIRECTION_VISUAL_LTR,
                 "\x0661\x0627\x0032\x06f3\x0061\x0034"],
                [numSource,
                 DIGITS_EN2AN_INIT_AL | DIGIT_TYPE_AN_EXTENDED | TEXT_DIRECTION_VISUAL_LTR,
                 "\x06f1\x0627\x0032\x06f3\x0061\x06f4"],
                /* no-op */
                [numSource, 0, numSource]
            ];
        }

        var escapedString = function(str)
        {
            if (str == null) {
                return null;
            }

            var /* StringBuffer */ buf = [];
            for (var /* int */ i = 0; i < str.length; ++i) {
                var /* char */ ch = #(str.charAt(i));
                buf.add("\\x%04x".sprintf(ch));
            }
            return buf.join("");
        };

        for (var i = 0; i < testData.count; i += 1)
        {
            var item = testData[i];
            var source = item[0];
            var flags = item[1];
            var expected = item[2];

            var /* Exception */ ex = null;
            var /* String */ actual = null;
            var /* ArabicShaping */ shaper = null;

            try {
                shaper = new global.ArabicShaping(flags);
                actual = shaper.shape(source);
            }
            /*
            catch(MissingResourceException e){
                throw e;
            }
            catch (IllegalStateException ie){
                warnln("IllegalStateException: "+ ie.toString());
                return;
            }
            */
            catch (/* Exception */ e) {
                ex = e;
            }

            if (ex != null) {
                var exmsg = "";
                if (typeof(ex) === "Object" && typeof(ex.message) === "String")
                {
                    exmsg = ex.message;
                }
                var extrace = "";
                if (typeof(ex) === "Object" && typeof(ex.trace) === "String")
                {
                    extrace = ex.trace;
                }
                err("TestStandard Error: Shaper " + shaper.toString() + "\n throws exception '" + ex + "'\n with message '" + exmsg + "'\n with traceback '" + extrace + "'\n for input '" + source);
            } else if (expected !== actual) {
                var /* StringBuffer */ buf = []/* new StringBuffer() */;
                buf.add("TestStandard Error: Shaper: " + shaper.toString() + "\n Input: " + source + "\n Actual: " + actual +
                           "\n Expected: " + expected + "\n");

                for (var /* int */ i = 0; i < global.Math.max(expected.length, actual.length); ++i) {
                    var /* String */ temp = "" + i;
                    if (temp.length < 2) {
                        temp = " " + temp;
                    }
                    var /* char */ trg = (i < expected.length) ? expected.charAt(i) : '\xffff';
                    var /* char */ res = (i < actual.length) ? actual.charAt(i) : '\xffff';

                    buf.add("[" + temp + "] ");
                    buf.add(escapedString("" + trg) + " ");
                    buf.add(escapedString("" + res) + " ");
                    if (trg != res) {
                        buf.add("***");
                    }
                    buf.add("\n");
                }

                buf.add("Index: " + i + "\n");
                err(buf.join(""));
            }

        }

    }

    // PreflightDataTest
    {
        var testData = [
            ["\x0644\x0627", LETTERS_SHAPE | LENGTH_GROW_SHRINK, 1],
            ["\x0644\x0627\x0031",
             DIGITS_EN2AN | DIGIT_TYPE_AN_EXTENDED | LENGTH_GROW_SHRINK, 3],
            ["\x0644\x0644", LETTERS_SHAPE | LENGTH_GROW_SHRINK, 2],
            ["\xfef7", LETTERS_UNSHAPE | LENGTH_GROW_SHRINK, 2]
        ];

        for (var i = 0; i < testData.count; i += 1)
        {
            var item = testData[i];
            var source = item[0];
            var flags = item[1];
            var length = item[2];

            var /* Exception */ ex = null;
            var /* char */ src /* [] */ = null;
            var /* int */ len = 0;
            var /* ArabicShaping */ shaper = null;

            if (source != null) {
                src = [];
                for (var i = 0; i < source.length; i += 1)
                {
                    src.add(#(source[i]));
                }
            }

            try {
                shaper = new global.ArabicShaping(flags);
                len = shaper.shape(src, 0, src.length, null, 0, 0);
            }
            catch (/* Exception */ e) {
                ex = e;
            }

            if (ex != null) {
                err("PreflightDataTest Error: Shaper " + shaper.toString() + "\n throws exception '" + ex + "'\n for input '" + source);
            } else if (length != len) {
                err("PreflightDataTest Error: Shaper " + shaper.toString() + "\n returns " + len + " characters for input '" +
                    source + "'\n Expected were " + length + " characters");
            }

        }
    }

    // ErrorDataTest
    {
        var testData = [
            /* bad data */
            ["\x0020\xfef7\x0644\x0020", LETTERS_UNSHAPE | LENGTH_FIXED_SPACES_NEAR,
             "ArabicShapingException"],
            ["\x0020\xfef7", LETTERS_UNSHAPE | LENGTH_FIXED_SPACES_AT_END,
             "ArabicShapingException"],
            ["\xfef7\x0020", LETTERS_UNSHAPE | LENGTH_FIXED_SPACES_AT_BEGINNING,
             "ArabicShapingException"],
            /* bad options */
            ["\xfef7", 0xffffffff, "IllegalArgumentException"],
            ["\xfef7", LETTERS_UNSHAPE | LENGTH_GROW_SHRINK, "ArabicShapingException"],
            [null, LETTERS_UNSHAPE | LENGTH_FIXED_SPACES_AT_END,
             "IllegalArgumentException"]
        ];

        for (var i = 0; i < testData.count; i += 1)
        {
            var item = testData[i];
            var source = item[0];
            var flags = item[1];
            var error = item[2];

            var /* Exception */ ex = null;
            var /* char */ src /* [] */ = null;
            var /* int */ len = 0;
            var /* ArabicShaping */ shaper = null;

            if (source != null) {
                src = [];
                for (var i = 0; i < source.length; i += 1)
                {
                    src.add(#(source[i]));
                }
                len = src.length;
            }

            try {
                shaper = new global.ArabicShaping(flags);
                shaper.shape(src, 0, len);
            }
            catch (/* Exception */ e) {
                ex = e;
            }

            if ((ex === null) || !(ex instanceof error)) {
                err("ErrorDataTest Error: Shaper " + shaper.toString() + "\n throws exception '" + ex + "'\n for input '" +
                    source + "'\n Expected exception: " + error);
            }

        }
    }
}
@endif
