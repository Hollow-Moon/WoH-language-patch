
@set(TAG_QUEUE_DEBUG=0)

global.BaseConductor_patch_conductor_original = global.BaseConductor;
class BaseConductor_patch_conductor_override extends global.BaseConductor_patch_conductor_original
{
	function BaseConductor_patch_conductor_override()
	{
		super.BaseConductor(...);
	}
	function BaseConductor()
	{
		this.BaseConductor_patch_conductor_override(...);
	}

	var lines = [];
	function onScenarioLoad(name)
	{
		// Use Array.load for loading scenario
		this.lines.clear();
		this.lines.load(name);
		return this.lines.join("\n");
	}
}
global.BaseConductor = global.BaseConductor_patch_conductor_override;

global.patch_conductor_regex_1 = /\[line(?: len=)?([0-9]*?)\]/g;
global.patch_conductor_regex_2 = /\[block(?: len=)?([0-9]*?)\]/g;
global.patch_conductor_regex_3 = /(?:\[ruby char="(.*?)" text="(?:.*?)"]|\[ruby char=(.*?) text="(?:.*?)"]|\[ruby char="(.*?)" text=(?:.*?)]|\[ruby char=(.*?) text=(?:.*?)]|\[ruby text="(?:.*?)" char="(.*?)"]|\[ruby text="(?:.*?)" char=(.*?)]|\[ruby text=(?:.*?) char="(.*?)"]|\[ruby text=(?:.*?) char=(.*?)])/g;
global.patch_conductor_regex_4 = /(?:\["[a-zA-Z0-9_-]*"]|\['[a-zA-Z0-9_-]*']|\[[0-9]*]|\[\+?\w+\.\w+]|\[[^]]*])/g;

global.patch_conductor_regex_5 = /(?:(?<=^)|(?<=\n))(?:@|;|\*).*?(?=$|\n)/g;
global.patch_conductor_regex_6 = /(?s)(?:(?:^|\n)\[iscript\]|(?:^|\n)\[iscript\]\\(?:\n)|(?:^|\n)@iscript(?:\n)).*?(?:(?:^|\n)\[endscript\]|(?:^|\n)\[endscript\]\\(?:\n)|(?:^|\n)@endscript(?:\n))/g;

global.Conductor_patch_conductor_original = global.Conductor;

class Conductor_patch_conductor_override extends global.Conductor_patch_conductor_original
{
	function Conductor_patch_conductor_override()
	{
		super.Conductor(...);
	}

	function Conductor()
	{
		this.Conductor_patch_conductor_override(...);
	}

	var dash_character = "―";
	var block_character = "■";
	var lines = [];
	var cleaned_lines = [];

	function replaceLine(text, reg, character=this.dash_character)
	{
		var results = reg.match(text);
		while(results.count == 2) {
			var count;
			if (results[1] == "") {
				count = 1;
			} else {
				count = results[1];
			}
			text = text.replace(reg, character.repeat(count));
			results = reg.match(text);
		}
		return text;
	}

	function replaceRubyChar(matcharr)
	{
		matcharr.erase(0);
		var x = matcharr.join("");
		if (+x != x)
		{
			return x;
		}
		return "";
	}

	function cleanLine(line=this.curLineStr)
	{
		if (this.isInQuiz())
		{
			return global.quizdata.question;
		}
		if (line.length === 0)
		{
			return "";
		}
		if (line[0] === "@" || line[0] === ";")
		{
			return "";
		}

		line = this.replaceLine(line, global.patch_conductor_regex_1);
		// Replace line-tags with dashes
		// Replace slightly-different-line-tags with dashes
		line = this.replaceLine(line, global.patch_conductor_regex_2, this.block_character);
		line = line.replace(global.patch_conductor_regex_3, this.replaceRubyChar);
		// Replace ruby tag containing text in char argument
		line = line.replace(global.patch_conductor_regex_4, "");
		// Remove arrays with string quotes indexes (not sure if possible but just in case)
		// Remove arrays with string apostrophes indexes (not sure if possible but just in case)
		// Remove arrays with number indexes (required or it will break when there is nested []s)
		// Remove arrays with variable index (i.e. [+mp.pos])
		// Remove tags
		return line;
	}

	function iscriptReplace(matcharr)
	{
		var newline_arrtmp = [];
		var matchstr = matcharr[0];
		var old_length = matchstr.length;
		matchstr = matchstr.replace(/\n/g, "");
		var diff_length = old_length - matchstr.length;
		newline_arrtmp.count = diff_length + 1;
		return newline_arrtmp.join("\n");
	}

	function cleanMultiLine(line)
	{
		line = line.replace(global.patch_conductor_regex_6, this.iscriptReplace);
		// Replace iscript/endscript tags
		line = line.replace(global.patch_conductor_regex_5, "");
		// Replace comments, labels, and command lines
		line = this.replaceLine(line, global.patch_conductor_regex_1);
		// Replace line-tags with dashes
		// Replace slightly-different-line-tags with dashes
		line = this.replaceLine(line, global.patch_conductor_regex_2, this.block_character);
		line = line.replace(global.patch_conductor_regex_3, this.replaceRubyChar);
		// Replace ruby tag containing text in char argument
		line = line.replace(global.patch_conductor_regex_4, "");
		// Remove arrays with string quotes indexes (not sure if possible but just in case)
		// Remove arrays with string apostrophes indexes (not sure if possible but just in case)
		// Remove arrays with number indexes (required or it will break when there is nested []s)
		// Remove arrays with variable index (i.e. [+mp.pos])
		// Remove tags
		return line;
	}

	function isInQuiz()
	{
		return this.curStorage == 'QuizSystem.ks' && this.owner.currentLabel == '*quiz_question';
	}

	var conductorPrevStorage;
	var conductorPrevLine;
	var lastQuizdataQuestion;
	var hasNewLineSinceLastCall = false;
	function isNewLine()
	{
		if (this.hasNewLineSinceLastCall)
		{
			this.hasNewLineSinceLastCall = false;
			return true;
		}

		return false;
	}

	var patch_conductor_temp_array = [];
	var patch_conductor_temp_array2 = [];
	var patch_conductor_messagelayer_tags = [
		"font",
		"deffont",
		"resetfont",
		"italic",
		"i",
		"/i",
		"rf",
		"l",
		"lr",
		"r",
@if(1)
		"align",
		"locatealign",
		"line",
		"block",
		"indent",
@endif
@if(1)
		"setdefaultmessageaction",
		"resetdefaultmessageaction",
		"setmessageappearaction",
		"resetmessageappearaction",
@endif
@if(0)
		"p",
		"pg",
		"cm",
@endif
@if(1)
		"graph",
		"ruby",
@endif
@if(1)
		"nowait",
		"endnowait",
		"locate",
@endif
@if(0)
		"hch",
		"style",
		"defstyle",
		"resetstyle",
		"link",
		"endlink",
		"button",
		"edit",
		"checkbox",
		"commit",
		"timeout",
		"ctimeout",
		"wheel",
		"cwheel",
		"click",
		"cclick",
		"current",
		"ct",
		"er",
		"indent",
		"endindent",
		"glyph",
		"s",
		"laycount",
		"mappfont",
@endif
	];

	var patch_conductor_messagelayer_proconly_tags = [
		"wait",
	];

	function getNextTag()
	{
		var ret = super.getNextTag(...);
		var patch_conductor_messagelayer_tags = this.patch_conductor_messagelayer_tags;
		var patch_conductor_messagelayer_proconly_tags = this.patch_conductor_messagelayer_proconly_tags;
		if (this.processSpecialTags)
		{
			var conductor_split_tags = [];
			while (ret !== void)
			{
				var temp_text = this.patch_conductor_temp_array2;
				temp_text.clear();
				var save_curStorage = this.curStorage;
				var save_curLine = this.curLine;
				var messagelayer_tag_prepend = [];
				var messagelayer_tag_append = [];
				while (ret !== void)
				{
					this.patch_conductor_temp_array.assign(ret);
					if (patch_conductor_messagelayer_tags.find(ret.tagname) !== -1 || (messagelayer_tag_prepend.count > 0 && patch_conductor_messagelayer_proconly_tags.find(ret.tagname) !== -1))
					{
						{
							var messagelayer_tag_container = %[];
							(global.Dictionary.assignStruct incontextof messagelayer_tag_container)(ret);
							ret = super.getNextTag(...);
							messagelayer_tag_prepend.add(messagelayer_tag_container);
							continue;
						}
					}
					break;
				}
				while (ret !== void)
				{
					this.patch_conductor_temp_array.assign(ret);
					if (patch_conductor_messagelayer_tags.find(ret.tagname) !== -1 || patch_conductor_messagelayer_proconly_tags.find(ret.tagname) !== -1)
					{
						break;
					}
					{
						if (ret.tagname === "ch")
						{
							if (this.patch_conductor_temp_array.count === 4)
							{
								temp_text.add(ret.text);
								ret = super.getNextTag(...);
								continue;
							}
						}
						else if (ret.tagname === "r")
						{
							// tagname only
							if (this.patch_conductor_temp_array.count === 2)
							{
								temp_text.add("\n");
								ret = super.getNextTag(...);
								continue;
							}
						}
					}
					break;
				}
				// continue to search for appended MessageLayer related tags
				while (ret !== void)
				{
					this.patch_conductor_temp_array.assign(ret);
					if (patch_conductor_messagelayer_tags.find(ret.tagname) !== -1 || (messagelayer_tag_prepend.count > 0 && patch_conductor_messagelayer_proconly_tags.find(ret.tagname) !== -1))
					{
						{
							var messagelayer_tag_container = %[];
							(global.Dictionary.assignStruct incontextof messagelayer_tag_container)(ret);
							ret = super.getNextTag(...);
							messagelayer_tag_append.add(messagelayer_tag_container);
							continue;
						}
					}
					break;
				}
				if (temp_text.count > 0)
				{
					var ret2 = %[];
					ret2.__patch_conductor_storage = save_curStorage;
					ret2.__patch_conductor_line = save_curLine;
					ret2.tagname = "ch_patch_conductor_split";
					ret2.text = temp_text.join("");
@if(TAG_QUEUE_DEBUG)
					Debug.message("Submitting text " + ret2.text);
@endif
					ret2.append = messagelayer_tag_append;
@if(TAG_QUEUE_DEBUG)
					if (messagelayer_tag_append.count > 0)
					{
						var tag_ls = [];
						for (var i = 0; i < messagelayer_tag_append.count; i += 1)
						{
							tag_ls.add(messagelayer_tag_append[i].tagname);
						}
						Debug.message("and append tags " + tag_ls.join(","));
					}
@endif
					ret2.prepend = messagelayer_tag_prepend;
@if(TAG_QUEUE_DEBUG)
					if (messagelayer_tag_prepend.count > 0)
					{
						var tag_ls = [];
						for (var i = 0; i < messagelayer_tag_prepend.count; i += 1)
						{
							tag_ls.add(messagelayer_tag_prepend[i].tagname);
						}
						Debug.message("and prepend tags " + tag_ls.join(","));
					}
@endif
					conductor_split_tags.add(ret2);
				}
				else if (messagelayer_tag_prepend.count > 0 || messagelayer_tag_append.count > 0)
				{
					var ret2 = %[];
					ret2.__patch_conductor_storage = save_curStorage;
					ret2.__patch_conductor_line = save_curLine;
					ret2.tagname = "ch_patch_conductor_messagelayer_tag";
					{
						ret2.append = messagelayer_tag_append;
@if(TAG_QUEUE_DEBUG)
						var tag_ls = [];
						for (var i = 0; i < messagelayer_tag_append.count; i += 1)
						{
							tag_ls.add(messagelayer_tag_append[i].tagname);
						}
						Debug.message("Submitting tags " + tag_ls.join(","));
@endif
					}
					{
						ret2.prepend = messagelayer_tag_prepend;
@if(TAG_QUEUE_DEBUG)
						var tag_ls = [];
						for (var i = 0; i < messagelayer_tag_prepend.count; i += 1)
						{
							tag_ls.add(messagelayer_tag_prepend[i].tagname);
						}
						Debug.message("and prepend tags " + tag_ls.join(","));
@endif
					}
					conductor_split_tags.add(ret2);
				}
				if (temp_text.count > 0 || messagelayer_tag_append.count > 0 || messagelayer_tag_prepend.count > 0)
				{
					continue;
				}
				break;
			}
			if (conductor_split_tags.count > 0)
			{
@if(TAG_QUEUE_DEBUG)
				Debug.message("End of submission with " + conductor_split_tags.count);
@endif
				for (var i = conductor_split_tags.count - 1; i >= 0; i -= 1)
				{
					this.pendings.insert(0, conductor_split_tags[i]);
				}
			}
		}
		if (typeof(ret) === "Object")
		{
			ret.__patch_conductor_storage = this.curStorage;
			ret.__patch_conductor_line = this.curLine;
		}
		return ret;
	}

	function queueTag(i, elm)
	{
		var ret2 = %[];
		(global.Dictionary.assignStruct incontextof ret2)(elm);
		ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
		ret2.__patch_conductor_line = elm.__patch_conductor_line;
		this.pendings.insert(i, ret2);
	}

	function requeueText(text, elm)
	{
		var ret2 = %[];
		ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
		ret2.__patch_conductor_line = elm.__patch_conductor_line;
		ret2.tagname = "ch_patch_conductor_split";
		ret2.text = text;
		ret2.append = elm.append;
		ret2.prepend = elm.prepend;
		this.pendings.insert(0, ret2);
	}

	function patch_conductor_do_ch_tag_insert(text, elm)
	{
		var ret2 = %[];
		ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
		ret2.__patch_conductor_line = elm.__patch_conductor_line;
		if (text == "\n")
		{
			ret2.tagname = "r";
		}
		else
		{
			ret2.tagname = "ch";
			ret2.text = text;
		}
		this.pendings.insert(0, ret2);
	}

	function queueText_internal(text, userdata)
	{
		this.patch_conductor_do_ch_tag_insert(text, userdata);
	}

	function queueText(text, elm)
	{
		global.split_text_by_grapheme((typeof(global.kag) === "Object") ? global.kag : this.owner, text, this.queueText_internal, elm);
	}

	function queueReline(elm, reline_ml=true, reline_hl=true)
	{
		if (reline_ml && reline_hl)
		{
			var ret2 = %[];
			ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
			ret2.__patch_conductor_line = elm.__patch_conductor_line;
			ret2.tagname = "r";
			this.pendings.insert(0, ret2);
		}
		else if (reline_hl && !reline_ml)
		{
			var ret2 = %[];
			ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
			ret2.__patch_conductor_line = elm.__patch_conductor_line;
			ret2.tagname = "hr";
			this.pendings.insert(0, ret2);
		}
		else if (reline_ml && !reline_hl)
		{
			var old_historyWriteEnabled = this.owner.historyWriteEnabled;
			{
				if (old_historyWriteEnabled)
				{
					// re-enable history output
					var ret2 = %[];
					ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
					ret2.__patch_conductor_line = elm.__patch_conductor_line;
					ret2.tagname = "history";
					ret2.output = "1";
					this.pendings.insert(0, ret2);
				}
				{
					// reline (on message layer only)
					var ret2 = %[];
					ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
					ret2.__patch_conductor_line = elm.__patch_conductor_line;
					ret2.tagname = "r";
					this.pendings.insert(0, ret2);
				}
				if (old_historyWriteEnabled)
				{
					// disable history output
					var ret2 = %[];
					ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
					ret2.__patch_conductor_line = elm.__patch_conductor_line;
					ret2.tagname = "history";
					ret2.output = "0";
					this.pendings.insert(0, ret2);
				}
			}
		}
	}

	function queuePrependMessageLayerRelatedTags(elm)
	{
		var prepend = [];
		prepend.assignStruct(elm.prepend);
		for (var i = prepend.count - 1; i >= 0; i -= 1)
		{
			var ret2 = %[];
			(global.Dictionary.assignStruct incontextof ret2)(prepend[i]);
			ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
			ret2.__patch_conductor_line = elm.__patch_conductor_line;
			this.pendings.insert(0, ret2);
		}
	}

	function queueAppendMessageLayerRelatedTags(elm)
	{
		var append = [];
		append.assignStruct(elm.append);
		for (var i = append.count - 1; i >= 0; i -= 1)
		{
			var ret2 = %[];
			(global.Dictionary.assignStruct incontextof ret2)(append[i]);
			ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
			ret2.__patch_conductor_line = elm.__patch_conductor_line;
			this.pendings.insert(0, ret2);
		}
	}

	var preprocess_ch_callbacks;
	function getPreprocessChCallbacks()
	{
		if (this.preprocess_ch_callbacks === void)
		{
			this.preprocess_ch_callbacks = [];
		}
		return this.preprocess_ch_callbacks;
	}

	function doPreprocessCh(elm)
	{
		var text = elm.text;
		text += "";
		if (this.preprocess_ch_callbacks !== void && text !== "")
		{
			var last_text = text;//this.owner.onConductorPreprocessCh(text, this, elm);
			var preprocess_ch_callbacks = this.getPreprocessChCallbacks();
			for (var i = 0; i < preprocess_ch_callbacks.count; i += 1)
			{
				var preprocess_ch_callback = preprocess_ch_callbacks[i];
				last_text = preprocess_ch_callback(last_text, this, elm);
			}
			return last_text;
		}
		return text;
	}

	var preprocess_ch_completion_callbacks;
	function getPreprocessChCompletionCallbacks()
	{
		if (this.preprocess_ch_completion_callbacks === void)
		{
			this.preprocess_ch_completion_callbacks = [];
		}
		return this.preprocess_ch_completion_callbacks;
	}

	function doPreprocessChCompletion(elm)
	{
		if (this.preprocess_ch_completion_callbacks !== void)
		{
			var preprocess_ch_completion_callbacks = this.getPreprocessChCompletionCallbacks();
			for (var i = 0; i < preprocess_ch_completion_callbacks.count; i += 1)
			{
				var preprocess_ch_completion_callback = preprocess_ch_completion_callbacks[i];
				preprocess_ch_completion_callback(this, elm);
			}
		}
	}

	function handleConductorSplit(elm)
	{
		elm.requeue = true;
		var text = this.doPreprocessCh(elm);
		if (elm.requeue)
		{
			if (elm.append !== void)
			{
				this.queueAppendMessageLayerRelatedTags(elm);
			}
			this.queueText(text, elm);
			if (elm.prepend !== void)
			{
				this.queuePrependMessageLayerRelatedTags(elm);
			}
		}
		this.doPreprocessChCompletion(elm);

		return 0;
	}

	function handleConductorMessageLayerTag(elm)
	{
		{
			this.queueAppendMessageLayerRelatedTags(elm);
			this.queuePrependMessageLayerRelatedTags(elm);
		}
		this.doPreprocessChCompletion(elm);
		return 0;
	}

	function onTag(elm)
	{
		if (elm.tagname === "ch_patch_conductor_split")
		{
			return this.handleConductorSplit(elm);
		}
		if (elm.tagname === "ch_patch_conductor_messagelayer_tag")
		{
			return this.handleConductorMessageLayerTag(elm);
		}
		if (elm.tagname === "ch" && elm.__patch_conductor_storage !== void && elm.__patch_conductor_line !== void)
		{
			if (elm.__patch_conductor_storage != this.conductorPrevStorage || elm.__patch_conductor_line != this.conductorPrevLine || (this.isInQuiz() && this.lastQuizdataQuestion != global.quizdata.question))
			{
				{
					this.hasNewLineSinceLastCall = true;
					this.conductorPrevStorage = elm.__patch_conductor_storage;
					this.conductorPrevLine = elm.__patch_conductor_line;
					if (this.isInQuiz() && this.lastQuizdataQuestion != global.quizdata.question) {
						this.lastQuizdataQuestion = global.quizdata.question;
					}
				}
			}
		}
		return super.onTag(...);
	}

	function onScenarioLoad(name)
	{
		this.conductorPrevStorage = void;
		this.conductorPrevLine = void;
		this.lastQuizdataQuestion = void;
		super.onScenarioLoad(...);
		// Use Array.load for loading scenario
		this.lines.clear();
		this.lines.load(name);
		var joined_lines = this.lines.join("\n");
		var joined_cleaned_lines = this.cleanMultiLine(joined_lines);
		if (typeof(this.owner.replace_characters_regex) === "Object")
		{
			joined_cleaned_lines = this.owner.replace_characters_regex(joined_cleaned_lines);
		}
		this.cleaned_lines = joined_cleaned_lines.split("\n");
		if (typeof(this.owner.onConductorScenarioPreLoad) === "Object")
		{
			this.owner.onConductorScenarioPreLoad(joined_cleaned_lines, this);
		}
		return joined_lines;
	}

	var patch_conductor_in_utility_scenario = false;
	var patch_conductor_utility_scenario_list = [
		"flowtrackerplugin.ks",
		"tracerplugin.ks",
	];

	var patch_conductor_scenario_manager_depth = void;
	var patch_conductor_entered_from_utility_scenario = void;

	function onCall(dic)
	{
		this.patch_conductor_entered_from_utility_scenario = false;
		if (dic !== void)
		{
			if (this.patch_conductor_scenario_manager_depth === void)
			{
				if (this.curStorage !== void && this.patch_conductor_utility_scenario_list.find(this.curStorage.toLowerCase()) !== -1)
				{
					this.patch_conductor_scenario_manager_depth = this.callStackDepth;
				}
			}
			else if (this.callStackDepth >= this.patch_conductor_scenario_manager_depth + 1)
			{
				this.patch_conductor_in_utility_scenario = true;
			}
		}
		return super.onCall(...);
	}

	function onReturn(dic)
	{
		this.patch_conductor_entered_from_utility_scenario = false;
		if (dic !== void)
		{
			if (this.callStackDepth - 1 === this.patch_conductor_scenario_manager_depth)
			{
				this.patch_conductor_scenario_manager_depth = void;
			}
			else if (this.callStackDepth - 1 === this.patch_conductor_scenario_manager_depth + 1)
			{
				this.patch_conductor_entered_from_utility_scenario = true;
				this.patch_conductor_in_utility_scenario = false;
			}
		}
		return super.onReturn(...);
	}

	function clearCallStack()
	{
		this.patch_conductor_scenario_manager_depth = void;
		return super.clearCallStack(...);
	}

	function restore(dic)
	{
		this.patch_conductor_scenario_manager_depth = void;
		if (dic !== void)
		{
			var val = dic.callStack;
			if (val !== void)
			{
				var clo = val;
				var count = clo.count;

				for (var i = 0; i < count; i += 1)
				{
					var item = clo[i];
					if (item !== void && typeof(item.storage) === "String" && this.patch_conductor_utility_scenario_list.find(item.storage.toLowerCase()) !== -1)
					{
						this.patch_conductor_scenario_manager_depth = i;
						break;
					}
				}
			}
		}
		return super.restore(...);
	}
}

global.Conductor = global.Conductor_patch_conductor_override;
