
@if(GAME_WOHN)
@set(USE_GET_GLYPH_DRAW_RECT=1)
@endif

@set(DO_WORDWRAP_BENCHMARK=0)
@set(USE_GET_INDIVIDUAL_CHARS=1)

global.HistoryLayer_patch_wordwrap_original = global.HistoryLayer;
class HistoryLayer_patch_wordwrap_override extends global.HistoryLayer_patch_wordwrap_original
{
	function HistoryLayer_patch_wordwrap_override()
	{
		super.HistoryLayer(...);
	}

	function HistoryLayer()
	{
		this.HistoryLayer_patch_wordwrap_override(...);
	}

	function nextWord(elm)
	{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = elm.hllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = 0;
		var bold = this.font.bold;
		var italic = this.font.italic;
		if (bold && italic)
		{
			currentWordWidth = elm.hllengthbi;
		}
		else if (bold)
		{
			currentWordWidth = elm.hllengthb;
		}
		else if (italic)
		{
			currentWordWidth = elm.hllengthi;
		}
		else
		{
			currentWordWidth = elm.hllength;
		}
@endif
		if ((this.getCurrentLineWidth() + currentWordWidth) >= this.relinePos && currentWordWidth < this.relinePos)
		{
			if (this.reline())
			{
				return this.autoReturn;
			}
		}
		return false;
	}

	function needsReline(elm)
	{
		if (typeof(this.window) === "Object" && typeof(this.window.historyWriteEnabled) === "Integer" && !(this.window.historyWriteEnabled))
		{
			return false;
		}
		var currentWordWidth = 0;
		if (typeof(elm) === "Object")
		{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			currentWordWidth = elm.hllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			var bold = this.font.bold;
			var italic = this.font.italic;
			if (bold && italic)
			{
				currentWordWidth = elm.hllengthbi;
			}
			else if (bold)
			{
				currentWordWidth = elm.hllengthb;
			}
			else if (italic)
			{
				currentWordWidth = elm.hllengthi;
			}
			else
			{
				currentWordWidth = elm.hllength;
			}
@endif
		}
		else
		{
			currentWordWidth = this.font.getTextWidth(elm);
		}

		if ((this.getCurrentLineWidth() + currentWordWidth) >= this.relinePos && currentWordWidth < this.relinePos)
		{
			return true;
		}
		return false;
	}
}
global.HistoryLayer = global.HistoryLayer_patch_wordwrap_override;

global.MessageLayer_patch_wordwrap_original = global.MessageLayer;
class MessageLayer_patch_wordwrap_override extends global.MessageLayer_patch_wordwrap_original
{
@if(GAME_WOHN)
	var char2graph_arr = [];
@endif
	function MessageLayer_patch_wordwrap_override()
	{
		super.MessageLayer(...);
@if(GAME_WOHN)
		this.char2graph_arr.assign(this.char2graph);
@endif
	}

	function MessageLayer()
	{
		this.MessageLayer_patch_wordwrap_override(...);
	}

	function shouldReline(ch)
	{
		var vert = this.vertical;
		if((vert ?  this.y >= this.relinexpos  : this.x >= this.relinexpos ) && this.autoReturn)
		{
			if(((this.lastDrawnCh=="" || this.wwLeading.indexOf(this.lastDrawnCh)==-1) &&
				this.wwFollowing.indexOf(ch)==-1) ||
				(this.lastDrawnCh!="" && this.wwFollowingWeak.indexOf(this.lastDrawnCh)!=-1 &&
					this.wwFollowingWeak.indexOf(ch)!=-1))
			{
				// 最後に描画したのが行末禁則文字でない場合
				// しかもこれから描画するのが行頭禁則文字でない
				// 場合
				// または弱禁則文字が連続していない場合
				return true;
			}
			else if(vert ? ( this.y>this.imageHeight ) : (this.x>this.imageWidth))
			{
				// これから描画するのが強禁則文字ではなくて、
				// 確実に 右端を越える場合
				// ( この場合は余白は考えない )
				return true;
			}
		}
		return false;
	}

	function nextWord(elm)
	{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = elm.mllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = 0, bold = false, italic = false;
		if (typeof(this.lineLayer) === "Object")
		{
			bold = this.lineLayer.font.bold;
			italic = this.lineLayer.font.italic;
		}
		else if (typeof(this.getChWidth) === "Object")
		{
			bold = this.bold;
			italic = this.fontItalic;
		}
		if (bold && italic)
		{
			currentWordWidth = elm.mllengthbi;
		}
		else if (bold)
		{
			currentWordWidth = elm.mllengthb;
		}
		else if (italic)
		{
			currentWordWidth = elm.mllengthi;
		}
		else
		{
			currentWordWidth = elm.mllength;
		}
@endif
		if ((this.x + currentWordWidth) >= this.relinexpos && currentWordWidth < this.relinexpos)
		{
			if (this.reline())
			{
				return this.autoReturn;
			}
		}
		return false;
	}

	function needsReline(elm)
	{
		var currentWordWidth = 0;
		if (typeof(elm) === "Object")
		{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			currentWordWidth = elm.mllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			var bold = false, italic = false;
			if (typeof(this.lineLayer) === "Object")
			{
				bold = this.lineLayer.font.bold;
				italic = this.lineLayer.font.italic;
			}
			else if (typeof(this.getChWidth) === "Object")
			{
				bold = this.bold;
				italic = this.fontItalic;
			}
			if (bold && italic)
			{
				currentWordWidth = elm.mllengthbi;
			}
			else if (bold)
			{
				currentWordWidth = elm.mllengthb;
			}
			else if (italic)
			{
				currentWordWidth = elm.mllengthi;
			}
			else
			{
				currentWordWidth = elm.mllength;
			}
@endif
		}
		else
		{
			if (typeof(this.lineLayer) === "Object")
			{
				currentWordWidth = this.lineLayer.font.getTextWidth(elm);
			}
			else if (typeof(this.getChWidth) === "Object")
			{
				currentWordWidth = this.getChWidth(elm)[1];
			}
		}

@if(MESSAGELAYER_USECHARLAYER)
		if ((this.x + currentWordWidth) >= this.relinexpos && currentWordWidth < this.relinexpos)
		{
			return true;
		}
@endif
@if(!MESSAGELAYER_USECHARLAYER)
		if ((this.lineLayerOriginX + this.lineLayerLength + currentWordWidth) >= this.relinexpos && currentWordWidth < this.relinexpos)
		{
			return true;
		}
@endif
		return false;
	}
}
global.MessageLayer = global.MessageLayer_patch_wordwrap_override;

global.KAGWindow_patch_wordwrap_original = global.KAGWindow;
class KAGWindow_patch_wordwrap_override extends global.KAGWindow_patch_wordwrap_original
{
	function KAGWindow_patch_wordwrap_override()
	{
		super.KAGWindow(...);

		this.conductor.getPreprocessChCallbacks().add(this.processWordWrappingChunkAtOnce);
	}

	function KAGWindow()
	{
		this.KAGWindow_patch_wordwrap_override(...);
	}

	var word_lines_scenario_changed = false;
	function onConductorScenarioLoad()
	{
		if (this.conductor === this.mainConductor)
		{
			this.words.clear();
@if(0)
			this.inQuotes = 0;
@endif
			this.word_lines_scenario_changed = true;
		}
		return super.onConductorScenarioLoad(...);
	}

	function onConductorScenarioLoaded()
	{
		if ((this.conductor === this.mainConductor) && (this.word_lines_space.count !== 0 || this.word_lines_chinese.count !== 0))
		{
			if ((typeof(this.current) === "Object" && !isvalid(this.current)) || (typeof(this.current) !== "Object") || (this.fore.messages.count === 0))
			{
				this.allocateMessageLayers(1);
				global.reload_messagelayer_config(this);
			}
			if (!this.conductor.patch_conductor_entered_from_utility_scenario)
			{
				this.setMessageLayerUserFont();
				this.clearMessageLayers();
			}
			if (this.word_lines_scenario_changed || this.check_word_length_cache())
			{
				this.word_lines_scenario_changed = false;
				this.generate_word_wrapping_list(this.conductor);
			}
		}

		return super.onConductorScenarioLoaded(...);
	}

	var words = [];

	//Chinese
	var currentWordIndex = 0;
	var currentCharPos = 0;

	var word_lines_current_storage = "";

	function onNewLine(elm)
	{
		var is_japanese = global.isJapanese();
		if (is_japanese)
		{
			// Don't bother doing the wordwrap calculations since we won't be using them
			return;
		}
		if (this.conductor === this.extraConductor)
		{
			// We don't do wordwrap on the extra conductor
			return;
		}

@if(0)
		processQuotedLine();
@endif

		{
			this.words.clear();
		}

		var clean = this.conductor.cleaned_lines[elm.__patch_conductor_line];

		if ((clean === void) || (clean !== void && clean.length === 0)) return;

		if (global.isChinese()) {
			this.onNewLineWordWrapChinese(elm.__patch_conductor_line);
		} else if (!is_japanese) {
			this.onNewLineWordWrapSpace(elm.__patch_conductor_line);
		}
	}

@if(GAME_WOHN)
	var char2glyph_cache = %[];
@endif

@if(USE_GET_INDIVIDUAL_CHARS)
	var individual_chars_cache = %[];
@endif

	function gtw_func(font, str, use_char2graph=false)
	{
		var res = 0;
@if(GAME_WOHN)
		if (use_char2graph)
		{
			var cache = this.char2glyph_cache["|" + font.height];
			if (cache !== void)
			{
				var maps = cache[0];
				var regexps = cache[1];
				for (var i = 0, internal_forloop_count = regexps.count; i < internal_forloop_count; i += 1)
				{
					var oldstr = str;
					str = regexps[i].replace(str, "");
					var count_diff = oldstr.length - str.length;
					if (count_diff > 0)
					{
						res += maps[regexps[i]]["" + count_diff];
					}
				}
			}
		}
@endif
@if(USE_GET_INDIVIDUAL_CHARS)
		var individual_chars_cache = this.individual_chars_cache;
		var font_values = [font.face, font.angle, font.bold, font.italic, font.height].join("|");
		for (var i = 0; i < str.length; i += 1)
		{
			var str_char = str[i];
			var str_key = str_char + "|" + font_values;
			var str_value = individual_chars_cache[str_key];
			if (str_value !== void)
			{
				res += str_value;
				continue;
			}
@if(USE_GET_GLYPH_DRAW_RECT)
			var rect = font.getGlyphDrawRect(str_char);
			if (typeof(rect) === "Object")
			{
				str_value = rect.right;
			}
			else
			{
				str_value = 0;
			}
@endif
@if(!USE_GET_GLYPH_DRAW_RECT)
			str_value = font.getTextWidth(str_char);
@endif
			res += str_value;
			individual_chars_cache[str_key] = str_value;
		}
@endif
@if(!USE_GET_INDIVIDUAL_CHARS)
@if(USE_GET_GLYPH_DRAW_RECT)
		var rect = font.getGlyphDrawRect(str);
		if (typeof(rect) === "Object")
		{
			res += rect.right;
		}
@endif
@if(!USE_GET_GLYPH_DRAW_RECT)
		res += font.getTextWidth(str);
@endif
@endif
		return res;
	}

@if(!WORDWRAP_BOLDITALIC_MODIFIER)
	var get_lengths_for_string_ret = [0, 0];
	function getLengthsForString(str, hlf, mlf)
	{
		var ret = this.get_lengths_for_string_ret;
		ret[0] = this.gtw_func(hlf, str);
		ret[1] = this.gtw_func(mlf, str, true);
		return ret;
	}
@endif

	var word_length_cache = %[];
	var word_length_test = [0, 0];
	var word_lines_space = [];
	var word_lines_chinese = [];
	var word_lines_needed = [];
	var nextWordTagName = "nextword";
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
	var empty_word = %[
		tagname: this.nextWordTagName,
		text: "",
		hllength: 0,
		mllength: 0
	];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
	var empty_word = %[
		tagname: this.nextWordTagName,
		text: "",
		hllength: 0,
		mllength: 0,
		hllengthb: 0,
		mllengthb: 0,
		hllengthi: 0,
		mllengthi: 0,
		hllengthbi: 0,
		mllengthbi: 0
	];
@endif
	var empty_line = [];

	function onConductorScenarioPreLoad(joined_cleaned_lines, conductor)
	{
		if (typeof(global.kag) !== "Object")
		{
			// We haven't finished initialization yet
			return;
		}
		if (conductor === this.extraConductor)
		{
			// We don't do wordwrap on the extra conductor
			return;
		}
		if (conductor.callStackDepth === 0)
		{
			// We are still at the initialization stage
			return;
		}
		if (global.isJapanese())
		{
			// Don't bother doing the wordwrap calculations since we won't be using them
			return;
		}
		var empty_scr = joined_cleaned_lines.replace(/[\n \t\[\]\(\)""'']+/g, "");
		if (empty_scr.length === 0)
		{
			return;
		}
		var word_length_cache = this.word_length_cache;
		var word_lines_space = this.word_lines_space;
		var word_lines_chinese = this.word_lines_chinese;
		word_lines_space.clear();
		word_lines_chinese.clear();
		var empty_line = this.empty_line;
		var empty_word = this.empty_word;
		var cleaned_lines = conductor.cleaned_lines;
		var word_lines_needed = this.word_lines_needed;
		var getLengthsForString = this.getLengthsForString;
		var nextWordTagName = this.nextWordTagName;
@if(GAME_WOHN)
		if ((typeof(this.current) === "Object" && !isvalid(this.current)) || (typeof(this.current) !== "Object") || (this.fore.messages.count === 0))
		{
			this.allocateMessageLayers(1);
			global.reload_messagelayer_config(this);
		}
		var mlf = this.get_mlf();
		var mlf_size = mlf.height;
		var char2glyph_cache = this.char2glyph_cache;
		var test_char2glyph = "|" + mlf_size;
		var total = 30;
		if (char2glyph_cache[test_char2glyph] === void)
		{
			var tmp_cache = %[];
			
			var tmp_char2glyph_arr = [];
			tmp_char2glyph_arr.assign(this.current.char2graph);
			var tmp_char2glyph_mapped = [];
			var tmp_char2glyph_map = %[];
			var tmp_layer_for_char2glyph = new Layer(this, this.primaryLayer);
			for (var i = 0, internal_forloop_count = tmp_char2glyph_arr.count; i < internal_forloop_count; i += 2)
			{
				var regexp_obj = new RegExp(tmp_char2glyph_arr[i]);
				tmp_char2glyph_mapped.add(regexp_obj);
				var map_tmp = %[];
				for (var j = 0; j <= 30; j += 1)
				{
					var image_dir = tmp_char2glyph_arr[i + 1].sprintf(mlf_size, j);
					if (Storages.isExistentImage(image_dir))
					{
						tmp_layer_for_char2glyph.loadImages(image_dir);
						map_tmp["" + j] = tmp_layer_for_char2glyph.imageWidth;
					}
				}
				tmp_char2glyph_map[regexp_obj] = map_tmp;
			}
			invalidate tmp_layer_for_char2glyph;
			char2glyph_cache[test_char2glyph] = [tmp_char2glyph_map, tmp_char2glyph_mapped];
		}
@endif
		for (var i = 0, internal_forloop_count = cleaned_lines.count; i < internal_forloop_count; i += 1)
		{
			if (cleaned_lines[i].length === 0)
			{
				word_lines_space[i] = empty_line;
				continue;
			}
			var arr = [];
			var additionalWords = cleaned_lines[i].split(" ");
			for (var j = 0, internal_forloop_count = additionalWords.count; j < internal_forloop_count; j += 1)
			{
				var word = additionalWords[j];
				if (word.length === 0)
				{
					arr[j] = empty_word;
					continue;
				}
				if (word_length_cache[word] === void)
				{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
					word_length_cache[word] = %[
						tagname: nextWordTagName,
						text: word
					];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
					word_length_cache[word] = %[
						tagname: nextWordTagName,
						text: word,
					];
@endif
					word_lines_needed.add(word_length_cache[word]);
				}
				arr[j] = word_length_cache[word];
			}
			word_lines_space[i] = arr;
		}
		{
			var word = " ";
			if (word_length_cache[word] === void)
			{
				word_length_cache[word] = %[
					tagname: nextWordTagName,
					text: word,
				];
				word_lines_needed.add(word_length_cache[word]);
			}
		}
		if (global.isChinese())
		{
			var splitter = /([A-zＡ-ｚ-]+)/g;
			for (var i = 0, internal_forloop_count = cleaned_lines.count; i < internal_forloop_count; i += 1)
			{
				if (cleaned_lines[i].length === 0)
				{
					word_lines_chinese[i] = empty_line;
					continue;
				}
				var arr = [];
				//	Use continuous English characters as separators to split the line into an array of substrings. / 中英文分词
				var additionalWords = splitter.split(cleaned_lines[i]);
				for (var j = 0, internal_forloop_count = additionalWords.count; j < internal_forloop_count; j += 1)
				{
					var word = additionalWords[j];
					if (word.length === 0)
					{
						arr[j] = empty_word;
						continue;
					}
					if (word_length_cache[word] === void)
					{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
						word_length_cache[word] = %[
							tagname: nextWordTagName,
							text: word
						];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
						word_length_cache[word] = %[
							tagname: nextWordTagName,
							text: word,
						];
@endif
						word_lines_needed.add(word_length_cache[word]);
					}
					arr[j] = word_length_cache[word];
				}
				word_lines_chinese[i] = arr;
			}
		}
	}

	function get_hlf()
	{
		if (typeof(this.historyLayer) === "Object")
		{
			return this.historyLayer.font;
		}
		return void;
	}

	function get_mlf()
	{
		var ml_charlayer = void;
		var invalidate_wordcache = false;
		if (typeof(this.current.getCharLayer) === "Object")
		{
			var ml = this.current;
			ml_charlayer = ml.tmpCharLayer;
			ml_charlayer.setFont(ml.fontFace, ml.fontAngle, ml.bold, ml.fontItalic, ml.fontStrikeout, ml.fontUnderline, ml.fontSize);
		}
		var mlf = void;
		if (typeof(this.current.lineLayer) === "Object")
		{
			mlf = this.current.lineLayer.font;
		}
		else if (ml_charlayer !== void)
		{
			if (!ml_charlayer.hasImage)
			{
				ml_charlayer.hasImage = true;
			}
			mlf = ml_charlayer.font;
		}
		return mlf;
	}

	function check_word_length_cache(hlf=this.get_hlf(), mlf=this.get_mlf(), process=false)
	{
		var invalidate_wordcache = false;
		if (hlf === void || mlf === void)
		{
			return invalidate_wordcache;
		}
		var word_length_test_str = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var gtw_func = this.gtw_func;
		var save_bold_hlf = hlf.bold;
		var save_italic_hlf = hlf.italic;
		var save_bold_mlf = mlf.bold;
		var save_italic_mlf = mlf.italic;
		hlf.bold = false;
		hlf.italic = false;
		mlf.bold = false;
		mlf.italic = false;
		var word_length_test_hl = gtw_func(hlf, word_length_test_str);
		var word_length_test_ml = gtw_func(mlf, word_length_test_str, true);
		if (word_length_test_hl !== this.word_length_test[0] || word_length_test_ml !== this.word_length_test[1])
		{
			invalidate_wordcache = true;
			if (process)
			{
				this.word_length_test[0] = word_length_test_hl;
				this.word_length_test[1] = word_length_test_ml;
			}
		}
		hlf.bold = save_bold_hlf;
		hlf.italic = save_italic_hlf;
		mlf.bold = save_bold_mlf;
		mlf.italic = save_italic_mlf;
@endif
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var word_length_test_cur = this.getLengthsForString(word_length_test_str, hlf, mlf);
		if (word_length_test_cur[0] !== this.word_length_test[0] || word_length_test_cur[1] !== this.word_length_test[1])
		{
			invalidate_wordcache = true;
			if (process)
			{
				this.word_length_test.assign(word_length_test_cur);
			}
		}
@endif
		return invalidate_wordcache;
	}

	function generate_word_wrapping_list(conductor, should_invalidate=true)
	{
@if(DO_WORDWRAP_BENCHMARK)
		var start = System.getTickCount();
@endif
		var hlf = this.get_hlf();
		var mlf = this.get_mlf();
		var invalidate_wordcache = should_invalidate ? this.check_word_length_cache(hlf, mlf, true) : false;

		if (invalidate_wordcache)
		{
			var word_length_cache_arr = [];
			word_length_cache_arr.assign(this.word_length_cache);
			for (var i = 0, internal_forloop_count = word_length_cache_arr.count; i < internal_forloop_count; i += 2)
			{
				var word_tag = word_length_cache_arr[i + 1];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
				var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
				word_tag.hllength = lengths[0];
				word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
				needed_lengths[word_tag.text] = word_tag;
@endif
			}
		}

@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var needed_lengths = %[];
@endif
		var word_lines_needed = this.word_lines_needed;
		for (var i = 0, internal_forloop_count = word_lines_needed.count; i < internal_forloop_count; i += 1)
		{
			var word_tag = word_lines_needed[i];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
			word_tag.hllength = lengths[0];
			word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			needed_lengths[word_tag.text] = word_tag;
@endif
		}
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var needed_lengths_arr = [];
		needed_lengths_arr.assign(needed_lengths);
		for (var i = 0, internal_forloop_count = needed_lengths_arr.count; i < internal_forloop_count; i += 2)
		{
			var word = needed_lengths_arr[i];
			var dic = needed_lengths_arr[i + 1];
			hlf.bold = false;
			hlf.italic = false;
			mlf.bold = false;
			mlf.italic = false;
			dic.hllength = gtw_func(hlf, word);
			dic.mllength = gtw_func(mlf, word, true);
			hlf.bold = true;
			mlf.bold = true;
			dic.hllengthb = gtw_func(hlf, word);
			dic.mllengthb = gtw_func(mlf, word, true);
			hlf.italic = true;
			mlf.italic = true;
			dic.hllengthbi = gtw_func(hlf, word);
			dic.mllengthbi = gtw_func(mlf, word, true);
			hlf.bold = false;
			mlf.bold = false;
			dic.hllengthi = gtw_func(hlf, word);
			dic.mllengthi = gtw_func(mlf, word, true);
		}
		hlf.bold = save_bold_hlf;
		hlf.italic = save_italic_hlf;
		mlf.bold = save_bold_mlf;
		mlf.italic = save_italic_mlf;
@endif

@if(CACHE_CHAR_LAYERS_FROM_TEXT)
		if (invalidate_wordcache)
		{
			global.reload_messagelayer_config(this);
			this.setMessageLayerUserFont();
		}
@if(CACHE_CHAR_LAYERS_FROM_TEXT_FIRSTLOAD_ONLY)
		if (invalidate_wordcache)
@endif
		{
			if (typeof(this.current.cacheCharLayerFromText) === "Object")
			{
				var cclft = this.current.cacheCharLayerFromText;
				for (var i = 0, internal_forloop_count = word_lines_needed.count; i < internal_forloop_count; i += 1)
				{
					var word_tag = word_lines_needed[i];
					cclft(word_tag.text, false);
				}
				for (var i = 0, internal_forloop_count = word_lines_needed.count; i < internal_forloop_count; i += 1)
				{
					var word_tag = word_lines_needed[i];
					cclft(word_tag.text, true);
				}
			}
		}
@endif
		word_lines_needed.clear();
		// Garbage collection.
		if (should_invalidate)
		{
			global.System.doCompact(global.clIdle);
		}
@if(DO_WORDWRAP_BENCHMARK)
		var end = System.getTickCount();
		Debug.message("Wordwrap was calculated in " + (end - start) + "ms");
@endif
	}

	function onNewLineWordWrapSpace(linenum)
	{
		var words = this.words;

		var word_lines = this.word_lines_space;

		var word_line = word_lines[linenum];
		if (word_line === void)
		{
			return;
		}
		{
			words.assign(word_line);
		}
		/*if (additionalWords.count > 0) {
			dm("clean line: " + clean);
			dm("found " + additionalWords.count + " words.");

			for (var i = 0, internal_forloop_count = words.count; i < internal_forloop_count; i += 1) {
				dm("word: '"+words[i][0]+"'");
			}
		}*/
	}

	function onNewLineWordWrapChinese(linenum)
	{
		var words = this.words;
		var word_lines = this.word_lines_chinese;
		var word_line = word_lines[linenum];
		if (word_line === void)
		{
			return;
		}
		{
			words.assign(word_line);
		}

		this.currentWordIndex = 0;
		this.currentCharPos = -2;

		/*if (words.count > 0) {
			dm("clean line: " + clean);
			dm("found " + words.count + " words.");

			for (var i = 0, internal_forloop_count = words.count; i < internal_forloop_count; i += 1) {
				dm("word: ['"+words[i][0]+"', "+i%2+"]");
			}
		}*/
	}

	function processWordWrapping(elm)
	{
		if (global.isChinese()) {
			return this.processWordWrappingChinese(elm);
		} else if (!global.isJapanese()) {
			return this.processWordWrappingSpace(elm);
		}
		return false;
	}

	function processWordWrappingSpace(elm)
	{
		if (
			#(elm.text) === 32 // " "
			&& this.words.count > 1
			)
		{
			this.words.erase(0);
			var nextWord = this.words[0];

			this.conductor.pendings.insert(0, nextWord);
			//dm("word: ["+nextWord[0]+"]");
		}
		return false;
	}

	function getHandlers()
	{
		var handlers = super.getHandlers();
		handlers.ruby_patch_wordwrap_original = handlers.ruby;
		handlers.ruby = function(elm)
		{
			{
				var e = elm;
				if(e.char != void && string(+e.char) != e.char)
				{
					// We'll treat this ruby entry as one whole word.
					var ttext = e.char;
					var word_length_cache = this.word_length_cache;
					var word_lines_needed = this.word_lines_needed;
					var wcacheentry = word_length_cache[ttext];
					if (typeof(wcacheentry) !== "Object")
					{
						word_length_cache[ttext] = %[
							tagname: this.nextWordTagName,
							text: ttext,
						];
						word_lines_needed.add(word_length_cache[ttext]);
						this.generate_word_wrapping_list(this.conductor, false);
						wcacheentry = word_length_cache[ttext];
					}
					var ml_needsreline = this.current.needsReline(wcacheentry);
					var hl_needsreline = this.historyLayer.needsReline(wcacheentry);
					if (ml_needsreline && hl_needsreline)
					{
						this.tagHandlers.r(%[tagname : "r"]);
					}
					else if (hl_needsreline && !ml_needsreline)
					{
						this.tagHandlers.hr(%[tagname : "hr"]);
					}
					else if (ml_needsreline && !hl_needsreline)
					{
						var old_historyWriteEnabled = this.historyWriteEnabled;
						{
							if (old_historyWriteEnabled)
							{
								// disable history output
								this.tagHandlers.history(%[tagname : "history", output : "0"]);
							}
							{
								// reline (on message layer only)
								this.tagHandlers.r(%[tagname : "r"]);
							}
							if (old_historyWriteEnabled)
							{
								// re-enable history output
								this.tagHandlers.history(%[tagname : "history", output : "1"]);
							}
						}
					}
				}
			}
			return this.tagHandlers.ruby_patch_wordwrap_original(elm);
		} incontextof this;
		return handlers;
	}

	function processWordWrappingChinese(elm)
	{
		if(this.words.count > 1) {
	//			dm(@"this.words[${this.currentWordIndex}][0] = ${this.words[this.currentWordIndex][0]}");
			switch(this.currentCharPos)
			{	//	Lookup the position of the first occurrence of current character in the current word. / 在当前词组中查找该字符第一次出现的位置
				case -3: // 禁用
					return false;
				case -1:
					break;
				case -2:	//	This is a new word or need start from 0 position. / 新词组
					this.currentCharPos++;
				default:
					this.currentCharPos = this.words[this.currentWordIndex].text.indexOf(elm.text, this.currentCharPos+1);
					break;
			}
			if(this.currentCharPos == -1) {	//	To determine the current word needs to be processed. / 处理
				while(this.currentWordIndex++ <= this.words.count) {
					if(this.words[this.currentWordIndex] === void)
					{
						this.currentCharPos = -3;
						return false;
					}
					else if(this.words[this.currentWordIndex].text.indexOf(elm.text) != -1)
					{
						this.currentCharPos = -2;
						if(this.currentWordIndex%2)
						{
							var word = this.words[this.currentWordIndex];
							return this.processNextWord(word);
						}
						return false;
					}
				}
			}
			//	End of the word, the next word should be determined it needs to process. / 到该词组末尾，下一词组需要处理
			if(this.currentCharPos == this.words[this.currentWordIndex].text.length - 1) this.currentCharPos = -1;
		}
		return false;
	}

	function processNextWord(elm)
	{
		this.historyLayer.nextWord(elm);
		if(this.currentWithBack) this.current.comp.nextWord(elm);
		return this.current.nextWord(elm);
	}

	function getWordWrapBreakPosition(text)
	{
		return this.getWordWrapBreakPositionUAX14(text);
@if(0)
		if (global.isChinese()) {
			return this.getWordWrapBreakPositionChinese(text);
		} else if (!global.isJapanese()) {
			return this.getWordWrapBreakPositionSpace(text);
		}
		return -1;
@endif
	}

	function getWordWrapBreakPositionUAX14(text)
	{
		var breaker = new global.LineBreaker(text);
		var breaks = [];
		var last = 0;
		var bk = breaker.nextBreak();
		if (!bk)
		{
			return -1;
		}
		var space_index = bk.position;
		// To avoid infinite recursion, break after space position
		if (space_index == 0)
		{
			return 1;
		}
		return space_index;
	}

	function getWordWrapBreakPositionSpace(text)
	{
		var space_index = text.indexOf(" ");
		// To avoid infinite recursion, break after space position
		if (space_index == 0)
		{
			return 1;
		}
		return space_index;
	}

	function getWordWrapBreakPositionChinese(text)
	{
		//	Use continuous English characters as separators to split the line into an array of substrings. / 中英文分词
		var additionalWords = text.split(/([A-zＡ-ｚ-]+)/);
		if (additionalWords.count > 0)
		{
			if (additionalWords[0].length > 0)
			{
				return additionalWords[0].length;
			}
		}
		return -1;
	}

	function processWordWrappingChunkAtOnce(in_text, conductor, elm)
	{
		var text = in_text;
		var rtl_enabled = global.get_rtl_enabled(typeof(global.kag) === "Object" ? global.kag : this);
		if (typeof(elm.extra_param) !== "Object")
		{
			elm.extra_param = %[];
		}
		if (elm.extra_param.processed_bidi !== true)
		{
			var arabic_shaping_enabled = global.get_arabic_shaping_enabled(typeof(global.kag) === "Object" ? global.kag : this);
			if (arabic_shaping_enabled)
			{
				if (typeof(global.arabic_shaper_instance_ltr) !== "Object")
				{
					global.init_arabic_shaper_instance();
				}
				text = global.arabic_presentation_tashkil_remap(global.arabic_shaper_instance_rtl.shape(text));
			}
			var bidi_str = global.Bidi.from_string(text, %["direction" => (rtl_enabled ? "RTL" : "LTR")]);
			bidi_str.reorder_visually();
			text = bidi_str.toString();
			elm.extra_param.processed_bidi = true;
		}
		var wwtext = text;
		if (rtl_enabled)
		{
			wwtext = wwtext.reverse();
		}
		var word_wrap_break_position = this.getWordWrapBreakPosition(wwtext);
		var ttext = text;
		var should_append_break_tags = true;
		if (elm.prepend.count > 0)
		{
			elm.requeue = false;
			conductor.requeueText(ttext, elm);
			conductor.queuePrependMessageLayerRelatedTags(elm);
			elm.prepend.clear();
			return "";
		}
		if (word_wrap_break_position > 0)
		{
			// Cut before the space
			var check_if_space = wwtext.substr(word_wrap_break_position - 1, 1);
			if (check_if_space === " ")
			{
				// Ensure that cutting the space won't result in empty string
				var check_ttext = wwtext.substr(0, word_wrap_break_position - 1);
				if (check_ttext !== "")
				{
					word_wrap_break_position -= 1;
				}
			}
			var cut_text = wwtext.substr(word_wrap_break_position);
			if (cut_text.length > 0)
			{
				if (rtl_enabled)
				{
					cut_text = cut_text.reverse();
				}
				conductor.requeueText(cut_text, elm);
				should_append_break_tags = false;
			}
			var wwctext = wwtext.substr(0, word_wrap_break_position);
			if (rtl_enabled)
			{
				wwctext = wwctext.reverse();
			}
			ttext = wwctext;
		}
@if(0)
		global.Debug.message("Before cut: " + text + "$");
		global.Debug.message("After cut: " + ttext + "$");
@endif
		var is_empty_space = ttext === " ";
		var word_length_cache = this.word_length_cache;
		var word_lines_needed = this.word_lines_needed;
		var wcacheentry = word_length_cache[ttext];
		if (typeof(wcacheentry) !== "Object")
		{
			word_length_cache[ttext] = %[
				tagname: this.nextWordTagName,
				text: ttext,
			];
			word_lines_needed.add(word_length_cache[ttext]);
			this.generate_word_wrapping_list(conductor, false);
			wcacheentry = word_length_cache[ttext];
		}
@if(0)
		var ll_len = this.current.lineLayer.font.getTextWidth(ttext);
		if (typeof(wcacheentry) === "Object")
		{
			if (wcacheentry.mllength !== ll_len)
			{
				global.Debug.message("ww x " + wcacheentry.mllength + " " + ll_len);
			}
			global.Debug.message("ML length: " + wcacheentry.mllength);
		}
		global.Debug.message("LL length: " + ll_len);
@endif
		var ml_needsreline = this.current.needsReline(wcacheentry);
		var hl_needsreline = this.historyLayer.needsReline(wcacheentry);
		if (is_empty_space)
		{
			if (ml_needsreline && hl_needsreline)
			{
				ttext = "\n" + (is_empty_space ? "" : ttext);
			}
		}
		else
		{
			if (ml_needsreline && hl_needsreline)
			{
				ttext = "\n" + (is_empty_space ? "" : ttext);
			}
			else if (hl_needsreline && !ml_needsreline)
			{
				elm.requeue = false;
				if (should_append_break_tags)
				{
					conductor.queueAppendMessageLayerRelatedTags(elm);
				}
				if (!is_empty_space)
				{
					conductor.queueText(ttext, elm);
				}
				conductor.queueReline(elm, false, true);
				return "";
			}
			else if (ml_needsreline && !hl_needsreline)
			{
				elm.requeue = false;
				if (should_append_break_tags)
				{
					conductor.queueAppendMessageLayerRelatedTags(elm);
				}
				if (!is_empty_space)
				{
					conductor.queueText(ttext, elm);
				}
				conductor.queueReline(elm, true, false);
				return "";
			}
		}

		if (!should_append_break_tags)
		{
			elm.requeue = false;
			conductor.queueText(ttext, elm);
			return "";
		}

		return ttext;
	}

@if(0)
	var quotesIndentedLeft = 1;
	var afterQuotesIndentedRight = 2;
	var quotesMethod = 0;
	var inQuotes = 0;
	var openingQuote = "“";
	var endingQuote = "”";
	var lineStartsWithOpeningQuoteRegex = new RegExp(" {2}"+openingQuote);
	var lineInSpeechRegex = new RegExp("^ {3}");

	function processQuotesIndent(elm)
	{
		{
			var text = elm.text;
			if (text == openingQuote) {
				inQuotes++;
				onOpeningQuote();
			} else if (text == endingQuote) {
				inQuotes--;
				onEndingQuote();
			}
		}
	}

	var quoteIndentation = false;
	function processQuotedLine()
	{
		if ([quotesIndentedLeft, afterQuotesIndentedRight].find(quotesMethod) == -1) {
			return;
		}

		if (!quoteIndentation) {
			quoteIndentation = lineStartsWithOpeningQuoteRegex.test(conductor.curLineStr);
		}

		if (!quoteIndentation) return;

		if (quotesMethod == afterQuotesIndentedRight) {
			if (lineInSpeechRegex.test(conductor.curLineStr)) {
				for (var i = 0; i < 3; i += 1) {
					conductor.getNextTag();
				}
			}
		}
	}

	function onOpeningQuote()
	{
		if (quotesMethod == afterQuotesIndentedRight && quoteIndentation) {
			tagHandlers.indent();
		}
	}

	function onEndingQuote()
	{
		if (inQuotes == 0 && quoteIndentation) {
			quoteIndentation = false;
			if (quotesMethod == afterQuotesIndentedRight) {
				tagHandlers.endindent();
			}
		}
	}
@endif
}
global.KAGWindow = global.KAGWindow_patch_wordwrap_override;


// Splits text into an array of lines with wordwrapping on spaces.
// Offset is an amount to add to the first line if you want it to be shorter
// than the rest of the lines (negative number for longer).
// Preserves leading spaces. Breaks lines at end of word and discards the first space between words.
// Words longer than one line break at the first character that is over the limit.
// If maxlines is reached, the rest of the string is returned in the last line regardless of length.
// Note: Breaking on characters other than space (e.g. tab, hyphen) is not supported.
global.wordWrapSplit = function(text, maxWidth, font, offset=0, maxLines=0, directiveCharacters="", delimiter=" ", delimiterOnNewLine=false)
{
	var directiveCharactersRegex = directiveCharacters != ""? new global.RegExp("["+directiveCharacters+"]", "g") : void;

	var totalTextToTest = directiveCharactersRegex === void? text : text.replace(directiveCharactersRegex, "");
	var textwidth = font.getTextWidth(totalTextToTest);
	if (textwidth+offset < maxWidth || maxLines == 1) {
		return [text];
	}

	var out = [];
	var words = [].split(delimiter, text);

	var tmp = "";
	for (var i = 0, internal_forloop_count = words.count; i < internal_forloop_count; i += 1)
	{
		var space = i != 0 ? delimiter : "";
		var word = space + words[i];
		var textToTest = directiveCharactersRegex === void? (tmp+word) : (tmp+word).replace(directiveCharactersRegex, "");
		if (font.getTextWidth(textToTest)+offset < maxWidth) {
			tmp += word;
		} else {
			if (tmp != "") {
				out.add(tmp);
			}

			if (out.count == maxLines && maxLines > 0) {
				for (var j = i, internal_forloop_count = words.count; j < internal_forloop_count; j += 1) {
					out[out.count-1] += space + words[j];
				}
				return out;
			} else {
				offset = 0;
				tmp = delimiterOnNewLine? delimiter + words[i] : words[i];
			}
		}
	}
	if (tmp != "") out.add(tmp);
	return out;
};


global.wordWrapSplitLines = function(lines, maxWidth, font, offset=0, maxLines=0)
{
	if (typeof(lines) === "String")
	{
		lines = lines.split("\n");
	}
	var out = [];
	for (var i = 0, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
		var sublines = global.wordWrapSplit(lines[i], maxWidth, font, offset, maxLines);
		for (var j = 0, internal_forloop_count = sublines.count; j < internal_forloop_count; j += 1) {
			out.add(sublines[j]);
		}
	}
	if (global.sf.language == global.japaneseLanguage) {
		var out2 = [];
		for (var i = 0, internal_forloop_count = out.count; i < internal_forloop_count; i += 1) {
			var sublines = global.wordWrapSplit(out[i], maxWidth, font, offset, maxLines,, "・", true);
			for (var j = 0, internal_forloop_count = sublines.count; j < internal_forloop_count; j += 1) {
				out2.add(sublines[j]);
			}
		}
		return out2;
	}
	return out;
};

global.wordWrapSplitParagraphs = function(paragraphs, maxWidth, font, offset=0, maxLines=0)
{
	if (typeof(paragraphs) === "String")
	{
		paragraphs = paragraphs.replace(/\n\n/g, "\v");
		paragraphs = paragraphs.split("\v");
	}
	for (var p = 0, internal_forloop_count = paragraphs.count; p < internal_forloop_count; p += 1) {
		paragraphs[p] = global.wordWrapSplitLines(paragraphs[p], maxWidth, font, offset, maxLines);
	}
	return paragraphs;
};
