
// ウィンドウのメニュー部分のみshowModalで表示
class PopupMenuWindow extends Window
{
	var autoclose; // 自動で閉じるか 0:閉じない, -1:マウス操作, 1:キー操作
	function PopupMenuWindow(win, ac, x, y, w) {
		super.Window();
		autoclose = ac;

		// スタイル設定
		if (typeof(this.innerSunken) === "Integer")
		{
			this.innerSunken = false;
		}
		if (typeof(this.borderStyle) === "Integer")
		{
			this.borderStyle = bsNone;
		}
		if (typeof(this.showScrollBars) === "Integer")
		{
			this.showScrollBars = false;
		}

		menu.visible = true;
		if (typeof(this.registerExEvent) === "Object") {
			registerExEvent();
		} else if (autoclose) {
			var f10 = new MenuItem(this, "");
			menu.add(f10);
			f10.shortcut = "F10";
			f10.onClick = close;
			f10.visible = false;
			this.onKeyDown = function(key, shift) {
				close() if (key == VK_ESCAPE && autoclose);
				return superKeyDown(...);
			} incontextof this;
		}
		// メニュー生成（windowからコピー）
		copyMenu(menu, win.menu.children);

		// 位置を決定
		if (typeof(win.getClientRect) !== "Object") {
			x = win.left if (x === void);
			y = win.top  if (y === void);
			w = win.innerWidth if (w === void);
		} else {
			var rect = win.getClientRect();
			x = rect.x if (x === void);
			y = rect.y if (y === void);
			w = rect.w if (w === void);
		}
		setPos(x, y);
		setInnerSize(w, 1);
//		height--;

		showModal();
	}
	function finalize() { super.finalize(...); }
	function onCloseQuery() { return super.onCloseQuery(true); }

	// メニューを複製
	function copyMenu(dst, srclist) {
		var items = [];
		for (var i = 0, internal_forloop_count = srclist.count; i < internal_forloop_count; i += 1) {
			var src = srclist[i], hasCh = src.children.count > 0;
			var item = new MenuItem(this, src.caption);
			with (item) {
				.group    = src.group;
				.radio    = src.radio;
				.checked  = src.checked;
				.shortcut = src.shortcut;
				.enabled  = src.enabled;
				.visible  = src.visible;
				.exp      = src.onClick;
				.onClick  = (function() {
					exp();
					root.window.close();
				} incontextof item) if (!hasCh);
			}
			add(item);
			dst.add(item);
			items.add(%[ item:item, src:src ]);
			// 再帰コピー
			copyMenu(item, src.children) if (hasCh);
		}
		// 順番を設定
		items.sort(function(a,b) { return a.src.index < b.src.index; }, true);
		for (var i = 0, internal_forloop_count = items.count; i < internal_forloop_count; i += 1)
			with (items[i]) .item.index = .src.index;

		// rightJustify / bmpItem設定
		for (var i = 0, item, src, internal_forloop_count = items.count; i < internal_forloop_count; i += 1) {
			with (items[i]) item = .item, src = .src;
			item.bmpItem      = src.bmpItem      if (typeof(src.bmpItem)      === "Object");
			item.rightJustify = src.rightJustify if (typeof(src.rightJustify) === "Integer");
		}
	}
	function onMouseLeave() {
		// マウスがウィンドウの外に出たら自動で閉じる
		close() if (autoclose);
		return super.onMouseLeave(...);
	}
	function onExitMenuLoop() {
		close() if (autoclose > 0);
	}
	function superKeyDown { return super.onKeyDown(...); }
}

/**
 * 最小化・最大化/復帰，閉じるメニューを追加・削除（要 WindowExプラグイン）
 * @param win Windowインスタンス
 * @param min 最小化表示 -1:無効 0:非表示 1:表示
 * @param max 最大化表示 -1:無効 0:非表示 1:表示
 * @param res 復帰表示   -1:無効 0:非表示 1:表示
 * @param cls 閉じる表示 -1:無効 0:非表示 1:表示
 */
global.SetWindowControlMenu = function(win, min, max, res, cls)
{
	if (typeof(win.minimize) !== "Object") return;
	var btns, tag = "__windowControlMenus";
	if (typeof(win[tag]) !== "Object") {
		var names = (typeof(win.windowControlMenusNames) === "Object") ?
			/**/            win.windowControlMenusNames : %[];
		// メニューアイテム生成
		with (names) btns = %[
		minimize: new MenuItem(win, .minimize !== void ? .minimize : ''),
		maximize: new MenuItem(win, .maximize !== void ? .maximize : ''),
		restore:  new MenuItem(win, .restore  !== void ? .restore  : ''),
		close:    new MenuItem(win, .close    !== void ? .close    : '')
			];
		with (btns) {
			with (.minimize) .icon = .caption != "" ? MenuItem.biPopupMinimize : MenuItem.biMinimize;
			with (.maximize) .icon =                  MenuItem.biPopupMaximize;
			with (.restore ) .icon = .caption != "" ? MenuItem.biPopupRestore  : MenuItem.biRestore;
			with (.close   ) .icon = .caption != "" ? MenuItem.biPopupClose    : MenuItem.biClose;

			// クリック処理
			.minimize.onClick = win.minimize;
			.maximize.onClick = win.maximize;
			.close   .onClick = win.onCloseQuery;
			.restore .onClick = function() {
				if (fullScreened) onWindowedMenuItemClick();
				else showRestore(...);
			} incontextof win;

			// ウィンドウの管理オブジェクトに追加
			win.add(.minimize);
			win.add(.maximize);
			win.add(.restore);
			win.add(.close);
		}
		/**/win[tag] = btns;
	}
	btns =  win[tag];
	with (btns) {
		// 追加
		var first, add = function(item, f) {
			this.add(item);
			return (f === void) ? item : f;
		} incontextof win.menu;
		var reset = function(item) {
			var parent = item.parent;
			if (parent) {
				try {
					if (*(&global.MenuItem.HMENU incontextof parent))
						item.rightJustify = false;
				} catch(e) {
					Debug.message(e.message);
				}
				parent.remove(item);
			}
		} incontextof global;
		reset(.minimize);
		reset(.maximize);
		reset(.restore );
		reset(.close   );
		first = add(.minimize, first) if (min);
		first = add(.maximize, first) if (max);
		first = add(.restore,  first) if (res);
		first = add(.close,    first) if (cls);

		// アイコン設定
		.minimize.bmpItem = .minimize.icon if (min);
		.maximize.bmpItem = .maximize.icon if (max);
		.restore .bmpItem = .restore .icon if (res);
		.close   .bmpItem = .close   .icon if (cls);

		// 無効設定
		.minimize.enabled = (min > 0) if (min);
		.maximize.enabled = (max > 0) if (max);
		.restore .enabled = (res > 0) if (res);
		.close   .enabled = (cls > 0) if (cls);

		// 右寄せ
		first.rightJustify = true if (first !== void);
	}
};

global.KAGWindow_patch_zoom_window_original = KAGWindow;
class KAGWindow_patch_zoom_window_override extends KAGWindow_patch_zoom_window_original
{
	var exWidth, exHeight; // 拡張画面サイズ⇒sysbase/fore.base/back.baseレイヤサイズ
	var pxWidth, pxHeight; // 現在のサイズ（sc～exまでの値）
	var exEventEnabled = false;

	function KAGWindow_patch_zoom_window_override()
	{
		super.KAGWindow(...);
	}

	function KAGWindow()
	{
		KAGWindow_patch_zoom_window_override(...);
	}

@if(SCALE_USING_FLOATING_POINT)
	property innerWidthScale { getter { return innerWidth / exWidth; } }
	property innerHeightScale { getter { return innerHeight / exHeight; } }
@endif
@if(!SCALE_USING_FLOATING_POINT)
	property innerWidthScale { getter { return innerWidth \ exWidth; } }
	property innerHeightScale { getter { return innerHeight \ exHeight; } }
@endif

	function init_zoom_window()
	{
		this.forcefull = false; // 強制フルスクリーンフラグ
		with (System) {
			// 座標・サイズを決定
			var x = left,  y = top;          // ウィンドウ座標
			var w = width, h = height;       // ウィンドウサイズ
			var pw = pxWidth, ph = pxHeight; // 実サイズ
			var iw = pw, ih = ph;            // インナーサイズ
			var mw = 0, mh = 0;              // 最小補正サイズ
			//	フルスクリーン状態で終了した後、再起動後にウィンドウへ切り替えると、フルスクリーン状態の拡大率のまま
			//	ウィンドウに戻ってしまうので、フルスクリーンだった場合は拡大率を復帰させない
			var	numer = 1, denom = 1;
			if(!scflags.fullScreen)
			{
				numer = scflags.zoomNumer;
				denom = scflags.zoomDenom;
			}
			var zoom  = (numer > 0 && denom > 0) ? (numer / denom) : 0;
			var max;

			if (isMain) {
				// ウィンドウ実サイズ
				iw = pw * zoom if (zoom > 0);
				ih = ph * zoom if (zoom > 0);

				// 位置を復帰
				if (System.getArgument("-restorewindowpos") != "no") with (scflags) {
					x = .windowLeft	  if (.windowLeft	 !== void);
					y = .windowTop	  if (.windowTop	 !== void);
					w = .windowWidth  if (.windowWidth	 !== void);
					h = .windowHeight if (.windowHeight	 !== void);
					max = .windowMaximized;
				}
			}
			w = iw if (w <= 0);
			h = ih if (h <= 0);
			mw = w\3, mh = h\3 if (isMain);

			// モニタ情報の取得
			var info;
			var desktop = %[ /**/  x:.desktopLeft,	 y:.desktopTop,
							 /**/  w:.desktopWidth,	 h:.desktopHeight ];
			var screen	= %[ /**/  x: 0,			 y: 0,
							 /**/  w:.screenWidth,	 h:.screenHeight  ];

			// WindowExプラグインが使える場合はそちらを使用する
			if (typeof(.getMonitorInfo) === "Object") {
				var info = .getMonitorInfo(true, x, y, w, h);
				if (typeof(info) === "Object") {
					(Dictionary.assign incontextof desktop)(info.work,	  true);
					(Dictionary.assign incontextof screen )(info.monitor, true);
				}
			}

			// ズーム状態補正
			var sw = screen.w, sh = screen.h;
			var over = (iw > sw || ih >= sh);
			if (!isMain || over || !zoom) {
				numer = denom = 1;
				// 標準サイズでも画面からはみ出す場合
				if (isMain && over && (pw > sw || ph >= sh)) {
					// 3/4～1/4 まで縮小できるか試す
					for (numer=3, denom=4; numer > 1; numer--)
						if (pw*numer/denom < sw && ph*numer/denom < sh) break;
					// 強制でフルスクリーン
					this.forcefull = true;
				}
			}
			setZoom(numer, denom);

			// ウィンドウ位置の調節
			with (desktop) {
				x = .x+.w - w if (x	  + mw > .x+.w);
				y = .y+.h - h if (y	  + mh > .y+.h);
				x = .x		  if (x+w - mw < .x	  );
				y = .y		  if (y		   < .y	  );
			}
			setPos(x, y) if (left != x || top != y);
			maximize() if (max && typeof(this.maximize) === "Object");
		}

		if (typeof(this.noneMagnifyMenuItem) === "Object")
		{
			noneMagnifyMenuItem.enabled	= false if System.getArgument("-fullscreenmode") == "primaryonly";
		}

		// -fszoom が設定されていなければ、前回選択されていたものを選ぶ
		var	fszoom	= System.getArgument("-fszoom");
		dm("-fszoom = "+fszoom+" / scflags.fszoom = "+scflags.fszoom);
		if(fszoom === void)
		{
			switch(scflags.fszoom)
			{
			case "inner":	onInnerMagnifyMenuItemClick();	break;
			case "outer":	onOuterMagnifyMenuItemClick();	break;
			case "none":	onNoneMagnifyMenuItemClick();	break;
			default:		onInnerMagnifyMenuItemClick();	break;
			}
		}
		else
			this[fszoom+"MagnifyMenuItem"].checked	= true if typeof(this[fszoom+"MagnifyMenuItem"]) === "Object";
	}

	function init_zoom_window_menubar_hide()
	{
		if (typeof(this.registerExEvent) === "Object") {
			// windowEx 拡張イベントを使用可能
			registerExEvent();
			exEventEnabled = true;
			createMenuBarHideMenu();
		} else {
			// 拡張イベントなし
			menuBarMode = 0; // 強制固定
		}
	}

	function zoom_window_save_system_variables()
	{
		scflags.zoomNumer = origZoomNumer;
		scflags.zoomDenom = origZoomDenom;

		scflags.fszoom = System.getArgument("-fszoom");

		scflags.menuBarState = menuBarState;
		scflags.windowResizeable = windowResizeable;
		scflags.limitWindowSize = limitWindowSize;
		scflags.windowMaximized  = false;
		var rect;
		if (typeof(this.maximized) === "Integer" && maximized) {
			scflags.windowMaximized	 = !fullScreen;
			if (_pseudoFullScreen !== void) with (_pseudoFullScreen) {
				rect = .rect;
				scflags.windowMaximized = .max && .restmax;
			} else
			if (typeof(this.getNormalRect) === "Object")
				rect = getNormalRect();
		} else if (fullScreened && typeof(_lastWindowSize) === "Object") {
			rect = _lastWindowSize.window; //if (!pseudoFullScreened);
		}
		if (rect !== void) {
			scflags.windowLeft	 = rect.x;
			scflags.windowTop	 = rect.y;
			scflags.windowWidth	 = rect.w;
			scflags.windowHeight = rect.h;
		} else {
			scflags.windowLeft	 = left;
			scflags.windowTop	 = top;
			scflags.windowWidth	 = width;
			scflags.windowHeight = height;
		}
	}

	//------------------------------------------ フルスクリーン・ズーム処理 --

	property fullScreenMode { getter {
		var tag = System.getArgument("-fullscreenmode");
		var map = %[ auto:-1, primaryonly:0, usepseudo:1, pseudoall:3 ];
		return (tag != "" && typeof(map[tag]) === "Integer") ? map[tag] : -1;
	} }

	function isPseudoMode() {
		if (pseudoFullScreened) return true;
		var info, mode = fullScreenMode;
		mode = 0 if (!exEventEnabled);
		switch (mode) {
		case -1:
@if(0)
			// マルチモニタ環境の場合は擬似フルスクリーン
			mode = (typeof(System.getDisplayMonitors) === "Object" &&
					(info = System.getDisplayMonitors()) !== void &&
					(info.count > 1));
@endif
			// Pseudo full screen mode does not work correctly at the moment, so disable it even for multiple monitors.
			// We only support primary monitor fullscreen at the moment.
			mode = 0;
			break;
		case 1:
			// ウィンドウがセカンダリ以降なら擬似フルスクリーン
			mode = (typeof(System.getMonitorInfo) === "Object" &&
					(info = System.getMonitorInfo(true, this)) !== void &&
					!info.primary);
			break;
		}
		return !!mode;
	}

	var _pseudoFullScreen;
	property pseudoFullScreened { getter { return (_pseudoFullScreen !== void); } }

	var _lastWindowSize;
	property fullScreen {
		getter { return super.fullScreen || pseudoFullScreened; }
		setter(v) {
			if (!fullScreen == !v) return;

			// Prevent direct maximized->fullscreened transition. Go back to normal window mode instead; the user can fullscreen from there.
			// (Todo: Find glitch free way for direct transition)
			if (v && (typeof(this.maximized) === "Integer") && this.maximized) {
				showRestore();
				return;
			}

			if (typeof(this.screenModeChangedTrigger) !== "Object") {
				add(   this.screenModeChangedTrigger = new AsyncTrigger(this, "screenModeChanged"));
				with (      screenModeChangedTrigger) .cached = true, .mode = atmAtIdle, .trigged = false;
			}
			var trig =      screenModeChangedTrigger;
			with (trig) {
				.maximize = .resetIcon = .callResize = .windowPos = void;
				if (.trigged) throw new Exception("Cant set fullScreen, changed trigger not completed.");
			}

			// フック
			callHook("prepareChangeScreenMode", v);
			onMovieScreenChanging(v);

			// フルスクリーンモードチェック
			if (v) {
				var min = 1;
				_lastWindowSize = %[
					/**/window: ((typeof(this.getNormalRect) === "Object") ? getNormalRect() :
								 /**/%[ x:left, y:top, w:width, h:height ]) ];
				_lastWindowSize.window	= %[ x:left, y:top, w:width, h:height ] if _lastWindowSize.window.left === void;
				if (isPseudoMode()) {
					// 擬似フルスクリーン
					var max = (typeof(this.maximized) === "Integer") ? maximized : false;
					_pseudoFullScreen =
						%[	/**/x:left, y:top, w:width, h:height,
							/**/max:max, restmax:(System.getArgument("-restoremaximizebyf2w") == "yes"),
							/**/rect:getNormalRect(), bs:borderStyle, //menu:menu.visible,
							/**/shortcut:(menuBarEnable ? makePseudoMenuTable(menu) : void) ];
					if (!max) {
						visible = false;
						trig.maximize = true;
					}
					menu.visible = false;
					borderStyle = bsNone;
				}
				else
				{
					// プライマリフルスクリーン
					setInnerSize(pxWidth, pxHeight);
					resetPrimaryPos();
					trig = void;
					if(exEventEnabled)
						menu.visible = menuBarEnable && menuBarState;
					super.fullScreen = true;
					min = -1;
					// 解像度が変わる場合があるので
					_lastWindowSize.fullscreen = %[
						/**/w:System.screenWidth, h:System.screenHeight, x:0, y:0 ];
				}
				updateMenuBarState();
				if (typeof(global.SetWindowControlMenu) === "Object")
				{
					SetWindowControlMenu(this, min, 0, 1, 1);
				}
			} else {
				super.fullScreen = false;
				if (pseudoFullScreened) with (_pseudoFullScreen) {
					visible = false;
					setPos (.x, .y);
					setSize(.w, .h);
					// menu.visible	= .menu;
					borderStyle	= .bs;

					trig.callResize = true;
					if (.max) {
						trig.windowPos = .rect;
						trig.maximize = .restmax;;
					}
					showRestore();
					_pseudoFullScreen = void;
				}
				else
				{
					if (typeof(this.maximized) === "Integer" && this.maximized) {
						// If fullscreen window additionally had the maximized flag, do a restore, then maximize again to fix positioning.
						// (Todo: Find glitch free way for direct transition)
						showRestore();
						maximize();
					}
					else
						setZoom(origZoomNumer, origZoomDenom);

					trig.resetIcon = true;
				}

				// メニューを消す
				updateMenuBarState();
				if (typeof(global.SetWindowControlMenu) === "Object")
				{
					SetWindowControlMenu(this);
				}
				_lastWindowSize = void;
			}

			// Only allow access to "Window Size" menu when not in fullscreen and not in maximized mode
			if (typeof(this.windowSizeMenu) === "Object")
				{
				if (typeof(this.maximized) === "Integer")
					this.windowSizeMenu.enabled	= !fullScreen && !this.maximized;
				else
					this.windowSizeMenu.enabled	= !fullScreen;
				}

			if (trig !== void) with (trig) {
				.trigged = true;
				.trigger();
			}
			else
				callHook("afterChangeScreenMode");
		}
	}
	function screenModeChanged() {
		with (screenModeChangedTrigger) {
			resetWindowIcon() if (.resetIcon && typeof(this.resetWindowIcon) === "Object");
			if (.windowPos !== void) with (.windowPos) {
				setPos (.x, .y);
				setSize(.w, .h);
			}
			if (	 .maximize	) maximize();
			else if (.callResize) onResize();

			.maximize = .resetIcon = .callResize = .windowPos = void;
			.trigged = false;
		}
		visible = true if !visible;

		// フック
		callHook("afterChangeScreenMode");
	}
	function resetPrimaryPos(max = 0, w, h) {
		if (typeof(_primaryLayer) === "Object")
		{
			var windowWideFactor = 1;
			if (typeof(this.absoluteMode) === "Integer")
			{
				if (["Integer", "Real"].find(typeof(this.wideFactor)) !== -1)
				{
					windowWideFactor = this.wideFactor;
				}
			}
			with (_primaryLayer) {
				if (max) { // Maximized window
					// z is the zoom factor between screen space and base resolution when touching the window borders from inside.
					var z = w / (pxWidth * windowWideFactor);
					if ((innerWidth / innerHeight) > (pxWidth * windowWideFactor / pxHeight))
						z = h / pxHeight;

					// Scale values from screen space to base resolution. They will be upscaled again by setPos and setSize for internal usage.
					var x = (innerWidth  - w) / (z * 2);
					var y = (innerHeight - h) / (z * 2 * windowWideFactor);					// isbg=1, so y will be handled by this.window.scaleWidth(), which will multiply in an unwanted wideFactor
					var w = global.Math.ceil(innerWidth / (z * windowWideFactor));
					var h = global.Math.ceil((innerHeight / (z * windowWideFactor)) - y);	// y substracted to make the viewport smaller than the clientRect, in order to add a black bar at the bottom in wide mode.

					if (typeof(sysbase) === "Object")
					{
						sysbase.setPos(x, y);
					}
					.hasImage = true;
					.setImageSize(w, h);
					.fillRect(0, 0, w, h, 0);
					.setSize(w, h);
				} else { // Normal window
					if (typeof(sysbase) === "Object")
					{
						sysbase.setPos(0, 0);
					}
					.hasImage = false;
					.setSize(pxWidth, pxHeight / windowWideFactor);	// isbg=1, so both coordinates will be handled by this.window.scaleWidth() -> fine for width, but height would be larger then the window frame in wide mode (paints even outside of client area)
				}
			}
		}
		if (typeof(sysbase) === "Object")
		{
			with (sysbase) onMoviePrimaryPosChanged(.left, .top);
		}
	}

	var _zoomNumer, _zoomDenom;
	property origZoomNumer { setter(v) { super.zoomNumer = v; } getter { return tempZoomed ? _zoomNumer : super.zoomNumer; } }
	property origZoomDenom { setter(v) { super.zoomDenom = v; } getter { return tempZoomed ? _zoomDenom : super.zoomDenom; } }
	property tempZoomed    { getter { return _zoomNumer !== void; } }
	function setZoom(numer, denom, resize = true) {
		if (super.fullScreen) return;
		if (typeof(this.absoluteMode) === "Integer")
		{
			this.absoluteMode += 1;
		}
		_zoomNumer = _zoomDenom = void;
		var zn = super.zoomNumer;
		var zd = super.zoomDenom;
		super.setZoom(numer, denom);
		var z = zoomNumer / zoomDenom;
		var pxWidth_abs = pxWidth;
		var pxHeight_abs = pxHeight;
		if (typeof(this.absoluteMode) === "Integer")
		{
			pxWidth_abs = this.scaleWidth(pxWidth_abs);
			pxHeight_abs = this.scaleHeight(pxHeight_abs);
		}
		var w = global.Math.round(pxWidth_abs * z) | 0;
		var h = global.Math.round(pxHeight_abs * z) | 0;
		if (resize) {
			setInnerSize(w, h);
			resetPrimaryPos();
		} else {
			// This section is only called when window gets maximized.
			resetPrimaryPos(z, w, h);
			_zoomNumer = zn;
			_zoomDenom = zd;
		}
		top++, top--; // VCRなムービーが追従するようにおまじない XXX
@if(GAME_WOHN)
		callHook("afterChangeWindowSize");
@endif
		if (typeof(this.absoluteMode) === "Integer")
		{
			this.absoluteMode -= 1;
		}
	}

	var menuBarMode = 1; // 0:固定・変更不可，1:固定・変更可（menuBarState準拠）
	var menuBarEnable = false;   // メニューバー有効
	var menuBarState;  // 現在のメニューの表示状態(0:非表示，1:表示，-1:自動表示）
	var defaultMenuBarState = 1; // 初期状態
	var menuBarHideButtonVisible = true; // メニューバーに消す・復帰ボタンを表示する
	var menuBarHideAutoVisible   = true; // 自動表示の有効フラグ
	var menuBarRightClickEnabled = true; // メニューバー上の右クリックを有効
	var menuBarTempMenuEnabled   = true; // 一時メニュー表示を有効

	var menuBarHideMenuItem;
	var menuBarHidePopupMenu;
	var menuBarHideSysMenu;
	var menuBarHidePseudoShortcut;
	property menuBarHideModeEnable { getter { return menuBarMode && menuBarEnable; } }
	function updateMenuBarState() {
		if (!menuBarHideModeEnable) return;
		menuBarState = (int)menuBarState;
		menuBarState = -1 if (menuBarState < 0);
		menuBarState =  1 if (menuBarState > 0 || (!menuBarHideAutoVisible && menuBarState < 0));

		menu.visible = (menuBarState > 0) if (!fullScreen);
		var list = menuBarHidePopupMenu;
		if (typeof(list) === "Object")
		{
			for (var i = list.count - 1; i >= 0; i -= 1)
				 with (list[i]) .checked = (.state == menuBarState);
		}

		if (!menuBarHideAutoVisible) {
			list = menuBarHideSysMenu;
			if (typeof(list) === "Object")
			{
				for (var i = list.count - 1; i >= 0; i -= 1)
					with (list[i]) if (typeof(.state) === "Integer") .checked = (.state == menuBarState);
			}
		}
		if (menuBarHideMenuItem !== void) with (menuBarHideMenuItem) {
			if (fullScreen) .visible = false;
			else {
				.caption = (menuBarState > 0) ? "x" : "+";
				.visible = true;
//				.bmpItem = MenuItem[(menuBarState > 0) ? "biPopupClose" : "biPopupRestore"];
				.rightJustify = true;
			}
		}
	}
	function getMenuBarPseudoShortcut() {
		return (menuBarHideModeEnable && menuBarState <= 0) ? menuBarHidePseudoShortcut : void;
	}
	function changeMenuBarState(stat) {
		if (!menuBarHideModeEnable) return;
		menuBarState = stat;
		menuBarHidePseudoShortcut = makePseudoMenuTable(menu) if (menuBarState <= 0 && menuBarHidePseudoShortcut === void);
		updateMenuBarState();
		onResize();
	}
	function toggleMenuBarState(sender) {
		if (!menuBarHideModeEnable) return;
		var state = (menuBarState <= 0) ? 1 : (menuBarHideAutoVisible ? -1 : 0);
		state = sender.state if (sender !== void && typeof(sender.state) === "Integer");
		changeMenuBarState(state);
	}
	function createMenuBarHideMenu() {
		if (!menuBarHideModeEnable) return;
		if (menuBarHideAutoVisible) {
			menuBarHidePopupMenu = [
				%[  originalCaption:__t("常に表示"),   group:1, state: 1 ],
				%[  originalCaption:__t("常に非表示"), group:1, state: 0 ],
				%[  originalCaption:__t("動的に表示"), group:1, state:-1 ] ];
			menuBarHideSysMenu = [
				%[  caption:"-" ],
				%[  originalCaption:__t("メニューバー"), children:menuBarHidePopupMenu ] ];
		} else {
			menuBarHidePopupMenu = [
				%[  originalCaption:__t("表示"),   group:1, state: 1 ],
				%[  originalCaption:__t("非表示"), group:1, state: 0 ] ];
			menuBarHideSysMenu = [
				%[  caption:"-" ],
				%[  originalCaption:__t("メニューバーを表示"),   group:1, state: 1 ],
				%[  originalCaption:__t("メニューバーを非表示"), group:1, state: 0 ] ];
		}
		exSystemMenu = menuBarHideSysMenu;
		refreshExSystemMenu();
		if (menuBarHideButtonVisible && typeof(this.menuBarHideMenuItem) !== "Object") {
			menu.add(menuBarHideMenuItem  = new KAGMenuItem(this, "x", 0, toggleMenuBarState, false));
			/**/     menuBarHideMenuItem.visible = false;
		}
	}
	function refreshExSystemMenu(menu=exSystemMenu) {
		if (menu === void) {
			return;
		}
		for (var i = 0, internal_forloop_count = menu.count; i < internal_forloop_count; i += 1) {
			if (menu[i].originalCaption !== void) {
				menu[i].caption = __(menu[i].originalCaption);
				if (typeof(menu[i].children) === "Object") {
					refreshExSystemMenu(menu[i].children);
				}
			}
		}
	}
	function onExSystemMenuSelected(sel) {
		if (sel && typeof(sel) === "Object") changeMenuBarState(sel.state);
	}
	var _ncCaptionClick;
	function onNcMouseDown(x, y, btn, rg) {
		_ncCaptionClick = (btn == mbRight && rg == global.Window.nchtMenu);
		if (typeof(this.toggleMenuBarState) === "Object" && btn == mbMiddle && rg == global.Window.nchtCaption) {
			toggleMenuBarState();
			_ncCaptionMove = false;
		}
	}
	function onNcMouseUp(x, y, btn, rg, cb) {
		if (_ncCaptionClick && btn == mbRight && rg == global.Window.nchtMenu && menuBarRightClickEnabled) {
			var pop = MenuItem.popupEx(tpmRightButton, void, void, this, void, menuBarHidePopupMenu);
			if (pop !== void) {
				changeMenuBarState(pop.state);
				cb() if (cb !== void);
			}
		}
		_ncCaptionClick = void;
	}
	function onMouseLeave  () { checkMenuBarHideTrackPseudoMenu(); }
	function onNcMouseLeave() { checkMenuBarHideTrackPseudoMenu(); }
	function checkMenuBarHideTrackPseudoMenu() {
		if (_ncCaptionMove || trackTempMenuShowing > 0) {
			var cur = System.getCursorPos();
			if (trackTempMenuShowing > 0) {
				trackTempMenu(false) if (ncHitTest(cur.x, cur.y) != global.Window.nchtMenu);
			} else {
				var rect = getClientRect();
				if (cur.x >= rect.x        && cur.y >= rect.y &&
					cur.x <  rect.x+rect.w && cur.y <  rect.y+System.getSystemMetrics("CYMENU")) {
					trackMenuByMouse(true);
				}
			}
		}
		_ncCaptionMove = false;
	}
	var _ncCaptionMove;
	function onNcMouseMove(x, y, rg) {
		if (!menuBarHideModeEnable || menuBarState >= 0 || fullScreen) return;
		with (global.Window) {
			_ncCaptionMove = (rg == .nchtCaption || rg == .nchtSysMenu);
			if (trackTempMenuShowing > 0 && rg != .nchtMenu) trackTempMenu(false);
		}
	}
	function onMouseMove(x, y) {
		if (pseudoFullScreened && y == 0 && menuBarEnable && menuBarState) trackPseudoMenu();
		else if (trackTempMenuShowing) checkMenuBarHideTrackPseudoMenu();
		return super.onMouseMove(...);
	}

	// MenuItem.shortcut からテーブルを作成
	function makePseudoMenuTable(menu, table) {
		var list = menu.children, first = (table === void);
		table = %[] if (first);
		for (var i = list.count - 1; i >= 0; i -= 1) {
			var item = list[i];
			if (item.children.count > 0) makePseudoMenuTable(item, table);
			else if (item.shortcut != "") {
				var sc = item.shortcut.split("+");
				var key = sc[sc.count-1], sft = 0, vk;
				if (key == "") continue;
				sc.erase(sc.count-1);
				key = key.toUpperCase();
				vk  = shortcutTextToVirtualKeyString[key];
				key = vk if (vk != "");
				if (typeof(global["VK_"+key]) !== "String") continue;
				key =     +global["VK_"+key];
				table[key] = %[] if (table[key] === void);
				for (var j = sc.count - 1; j >= 0; j -= 1) {
					var tag = sc[j];
					tag = tag.toLowerCase() if (tag != "");
					switch (tag) {
					case "shift":   sft |= ssShift; break;
					case "ctrl":    sft |= ssCtrl;  break;
					case "alt":     sft |= ssAlt;   break;
					}
				}
				table[key][sft] = item.onClick;
			}
		}
		if (first && !exEventEnabled) {
			var f10 = table[VK_F10];
			f10 = table[VK_F10] = %[] if (f10 === void);
			f10[0] = trackMenuByKey;
		}
		return table;
	}
	// shortcut ⇒ VK_* 例外変換用テーブル
	var shortcutTextToVirtualKeyString = (const)%[
		"DEL"=>"DELETE",
		"ENTER"=>"RETURN",
		"PAGEUP"=>"PRIOR",
		"PAGEDOWN"=>"NEXT"//,
		];
	// 擬似フルスクリーン時ショートカットキー処理
	function pseudoMenuShortcut(key, shift) {
		var table = pseudoFullScreened ? _pseudoFullScreen.shortcut : getMenuBarPseudoShortcut();
		if (table !== void) {
			shift &= ~ssRepeat if (shift & ssAlt); // [XXX] ALTでリピートフラグが正しく立たない
			var info = table[key], func;
			if ((info !== void) &&
				(func  = info[+shift]) !== void &&
				!(shift & ssRepeat))
			{
				func();
				return true;
			}
		}
		return false;
	}
	function onAccelKeyMenu(key, f) {
		var info, table = pseudoFullScreened ? _pseudoFullScreen.shortcut : getMenuBarPseudoShortcut();
		return  table !== void && (info = table[key]) !== void && info[+ssAlt] !== void;
	}
	function onStartKeyMenu(key) {
		if (key || (menu.visible)) return;
		return (trackMenuByKey(true) <= 0);
	}

	var ignoreTrackPseudoMenu = false, trackTempMenuShowing = 0;
	function trackPseudoMenu(bykey, rclick) {
		if ((!bykey && ignoreTrackPseudoMenu) || trackTempMenuShowing) return;
		rclick &= exEventEnabled;
		var popup = new PopupMenuWindow(this, bykey ? 1: -1,/*x*/,/*y*/,/*w*/, !rclick);
		if (rclick) with (popup) {
			._ncCaptionClick = void;
			.menuBarHidePopupMenu = menuBarHidePopupMenu;
			.menuBarRightClickEnabled = menuBarRightClickEnabled;
			.changeMenuBarState   = changeMenuBarState;
			.onNcMouseDown = (onNcMouseDown incontextof popup);
			.onNcMouseUp__ = (onNcMouseUp   incontextof popup);
			.onNcMouseUp   = function(x, y, btn, rg) { onNcMouseUp__(x, y, btn, rg, close); } incontextof popup;
			.showModal();
		}
		invalidate popup;
	}
	function closeTempMenu() { trackTempMenu(false,, true); }
	function trackTempMenu(vis, bykey, force) {
		if (vis && !bykey && ignoreTrackPseudoMenu) return;
		var old = trackTempMenuShowing;
		trackTempMenuShowing = !vis ? 0 : bykey ? -1 : 1;
		if ((force || !old != !vis)) {
			if  (vis) menu.visible = true;
			else {
				menu.visible = false if (pseudoFullScreened);
				updateMenuBarState();
			}
		}
	}
	function onExitMenuLoop() {
		if (trackTempMenuShowing) {
			trackTempMenuShowing = false;
			var trig;
			if (typeof(this.closeTempMenuTrigger) === "Object") {
				trig = this.closeTempMenuTrigger;
			} else {
				trig = this.closeTempMenuTrigger = new AsyncTrigger(closeTempMenu, "");
				trig.mode = atmAtIdle;
				trig.cached = true;
				add(trig);
			}
			trig.trigger();
		}
	}
	function trackMenuByMouse() {
		if (menuBarTempMenuEnabled) trackTempMenu(true);
		else trackPseudoMenu(false, menuBarRightClickEnabled);
	}
	function trackMenuByKey(delay) {
		var  fs = super.fullScreen;
		if (!fs && menuBarEnable && (menuBarState/* || pseudoFullScreened*/)) {
			if (menuBarTempMenuEnabled && !pseudoFullScreened) trackTempMenu(true, true);
			else {
				trackPseudoMenu(true);
				return -1;
			}
		} else return fs;
		return true;
	}

	// スクリーンセーバー抑制
	function onScreenSave()       { return true; }
	function onMonitorPower(mode) { return (mode > 0); }

	//-------------------------------------------------------- リサイズ処理 --

	property maximizeMode { getter {
		var tag = System.getArgument("-maximizemode");
		var map = %[ auto:-1, maximize:0, fullscreen:1 ];
		return (tag != "" && typeof(map[tag]) === "Object") ? map[tag] : -1;
	} }

	function onMaximizeQuery() {
		if (pseudoFullScreened) return;
		var mode = maximizeMode;
		if (!mode || (mode < 0 && windowResizeable)) return;
		onFullScreenMenuItemClick();
		return true;
	}
	var _minimized;
	function onMinimize() { _minimized = true;  }
	function onHide()     { _minimized = true;  }
	function onShow()     { _minimized = false; }

	var in_limit_size = 0;
	function limitSize(mon)
	{
		// A maximized window by definition is sized so that the window borders and title menu are outside of the screen
		// So don't limit the size to desktop if the window is maximized.
		if (this.maximized == true || limitWindowSize == false)
			return false;

		if (this.in_limit_size)
		{
			return true;
		}
		var	szchg	= false;
		this.in_limit_size += 1;
		if(!fullScreen && typeof(System.getMonitorInfo) === "Object")
		{
			if (typeof(this.absoluteMode) === "Integer")
			{
				this.absoluteMode += 1;
			}
			mon	= System.getMonitorInfo(true, this) if mon == void;
			var	ml	= mon.work.x, mt = mon.work.y;
			var	mw	= mon.work.w, mh = mon.work.h;
			var width = this.width;
			var height = this.height;
			var innerWidth = this.innerWidth;
			var innerHeight = this.innerHeight;

			var hBorders = width - innerWidth;
			var vBorders = height - innerHeight;
			var innerRatio = innerWidth / innerHeight;

			if(mw < width)
			{
				width	= mw;
				innerWidth = width - hBorders;
				innerHeight = int((innerWidth / innerRatio) + 0.5);
				height = innerHeight + vBorders;

				szchg	= true;
			}

			// If height is still outside of the working area 'mh' at this point,
			//   recalculate all values based on height.
			if(mh < height)
			{
				height	= mh;
				innerHeight = height - vBorders;
				innerWidth = int((innerHeight * innerRatio) + 0.5);
				width = innerWidth + hBorders;

				szchg	= true;
			}

			if (szchg)
			{
				// Order is important, inner size is set before size
				this.setInnerSize(innerWidth, innerHeight);
				this.setSize(width, height);
			}
			var poschg = false;
			var left = this.left;
			var top = this.top;
			if(left < ml)
			{
				left	= ml;
				poschg = true;
			}
			else if(left + width > ml + mw)
			{
				left	= ml + mw - width;
				poschg = true;
			}
			if(top < mt)
			{
				top	= mt;
				poschg = true;
			}
			else if(top + height > mt + mh)
			{
				top	= mt + mh - height;
				poschg = true;
			}
			if (poschg)
			{
				this.setPos(left, top);
			}
			if (typeof(this.absoluteMode) === "Integer")
			{
				this.absoluteMode -= 1;
			}
		}
		this.in_limit_size -= 1;
		return szchg;
	}

	var _lastInnerSize;
	var _onResizeProcess = true;
	var _limitSizeCounter = 0;
@if(ZOOM_WINDOW_ENABLE_ONRESIZE)
	function onResize() {
		if (trackTempMenuShowing)
		{
			return super.onResize();
		}
		if(limitSize())
		{
			this._limitSizeCounter += 1;
			return;
		}
//		dm("onResize", innerWidth, innerHeight);
		if (!_minimized && _onResizeProcess && _resizeSnapshot === void)
		{
			if (typeof(this.absoluteMode) === "Integer")
			{
				this.absoluteMode += 1;
			}
			_onResizeProcess = false;
			var pxWidth_abs = pxWidth;
			var pxHeight_abs = pxHeight;
			if (typeof(this.absoluteMode) === "Integer")
			{
				pxWidth_abs = this.scaleWidth(pxWidth_abs);
				pxHeight_abs = this.scaleHeight(pxHeight_abs);
			}
			var numer = innerWidth, denom = pxWidth_abs;
			var max = (typeof(this.maximized) === "Integer") ? maximized : false;
			if (max) {
				var vert = (innerWidth/innerHeight > pxWidth_abs/pxHeight_abs);
				var zoom = System.getArgument("-fszoom");
				if (!pseudoFullScreened) {
					var mz = System.getArgument("-maximizezoom");
					zoom = mz if (mz != "fszoom");
				}
				switch (zoom) {
				case "outer": vert = !vert; break;
				case "no":
				case "none":	numer = denom = 1; vert = false; break;
				case "middle": // 中間拡大
					var per = System.getArgument("-mzpercent");
					per = (per == "") ? 50 : (int)(+per);
					if (per < 0) {
						numer = -per;
						denom = 100;
					} else {
						per = 100 if (per > 100);
						var iw =  innerWidth, ih =  innerHeight;
						var pw = pxWidth_abs, ph = pxHeight_abs;
						if (vert) iw <-> ih, pw <-> ph;
						numer = (int)(iw + (ih - iw) * per / 100);
						denom = (int)(pw + (ph - pw) * per / 100);
					}
					vert = false;
					break;
				}
				if (vert) numer = innerHeight, denom = pxHeight_abs;
			}
			setZoom(numer, denom, !max);
			if (typeof(this.absoluteMode) === "Integer")
			{
				this.absoluteMode -= 1;
			}
			callResizeHook();
			_onResizeProcess = true;
		}
		this._limitSizeCounter = 0;
		return super.onResize();
	}
@endif
	var _windowResizeable = true; // フレームを掴んでリサイズ可能かどうか
	property windowResizeable {
		getter { return _windowResizeable; }
		setter(v) {
			_windowResizeable = v;
			if (exEventEnabled){
				this.disableResize = !v;
			} else {
				var x = (v ? left-5 : left+5), y = (v ? top-5 : top+5);

				borderStyle = v ? bsSizeable : bsSingle;
				setPos(x, y);
				setZoom(origZoomNumer, origZoomDenom);
			}
			callHook("afterChangeWindowResizeable");
		}
	}
	var _limitWindowSize = true;
	property limitWindowSize {
		getter { return _limitWindowSize; }
		setter(v) {
			_limitWindowSize = v;
		}
	}
	function onResizing(rect) {
		if (typeof(this.absoluteMode) === "Integer")
		{
			this.absoluteMode += 1;
		}
		if (_resizeSnapshot === void) onMoveSizeBegin();
		if (!windowResizeable) {
			with (_resizeSnapshot.window) {
				rect.x = .x;
				rect.y = .y;
				rect.w = .w;
				rect.h = .h;
			}
			if (typeof(this.absoluteMode) === "Integer")
			{
				this.absoluteMode -= 1;
			}
			return true;
		}
		var pxWidth_abs = pxWidth;
		var pxHeight_abs = pxHeight;
		var wideRatio = pxWidth_abs / pxHeight_abs;
		if (typeof(this.absoluteMode) === "Integer")
		{
			pxWidth_abs = this.scaleWidth(pxWidth_abs);
			pxHeight_abs = this.scaleHeight(pxHeight_abs);
			wideRatio = this.wideRatio;
		}
		var w, h, dw, dh;
		with (_resizeSnapshot) dw=.dw, dh=.dh;
		with (rect) {
			w = .w - dw;
			h = .h - dh;
			var sel;
			switch (.type) {
			case 1: case 2: sel = true;  break;
			case 3: case 6: sel = false; break;
			default: sel = (w / h) > wideRatio; break;
			}
@if(!SCALE_ROUND_TOWARDS_NEAREST)
			if (sel) h = (w / wideRatio) | 0;
			else     w = (h * wideRatio) | 0;
			if (w < pxWidth_abs\4) {
				w = pxWidth_abs\4;
				h = (w / wideRatio) | 0;
			}
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
			if (sel) h = global.Math.round(w / wideRatio) | 0;
			else     w = global.Math.round(h * wideRatio) | 0;
			if (w < pxWidth_abs\4) {
				w = pxWidth_abs\4;
				h = global.Math.round(w / wideRatio) | 0;
			}
@endif
			w += dw;
			h += dh;
			const repos = function(type, p, o, n, sel) {
				switch (type % 3) {
				case 0:	 return sel ? p+(o-n)\2 : p;
				case 1:	 return p+o-n;
				default: return p;
				}
			};
			var x = repos(.type,   .x, .w, w, true);
			var y = repos(.type\3, .y, .h, h, false);
			if (.x == x && .y == y && .w == w && .h == h)
			{
				if (typeof(this.absoluteMode) === "Integer")
				{
					this.absoluteMode -= 1;
				}
				return false;
			}
			.x = x;
			.y = y;
			.w = w;
			.h = h;
		}
		if (typeof(this.absoluteMode) === "Integer")
		{
			this.absoluteMode -= 1;
		}
		return true;
	}
	var _resizeSnapshot = void;
	function onMoveSizeBegin() {
		this._limitSizeCounter = 0;
		if (typeof(this.absoluteMode) === "Integer")
		{
			this.absoluteMode += 1;
		}
		_resizeSnapshot = %[
		window:		 getWindowRect(),
		client:		 getClientRect(),
		innerWidth:	 innerWidth,
		innerHeight: innerHeight
			];
		with (_resizeSnapshot) {
			.dw = .window.w  - .innerWidth;
			.dh = .window.h - .innerHeight;
		}
		if (typeof(this.absoluteMode) === "Integer")
		{
			this.absoluteMode -= 1;
		}
	}
	function onMoveSizeEnd() {
		this._limitSizeCounter = 0;
		limitSize();
		if(_resizeSnapshot !== void)
			setZoom(innerWidth, pxWidth);
//		dm("onResizeEnd/zoomed", innerWidth, innerHeight);
		callHook("onMoveSizeEndHook", this, _resizeSnapshot);
		_resizeSnapshot = void;
		callResizeHook();
	}
	function callResizeHook() {
//		dm("callResizeHook");
		callHook("onWindowResizeHook", this, innerWidth, innerHeight);
		updateWindowSizeChecked(fullScreen ? 0 : innerWidth);
		updateLimitWindowSizeMenuItem();

		// Only allow access to "Window Size" menu when not in fullscreen and not in maximized mode
		if (typeof(this.windowSizeMenu) === "Object")
			{
			if (typeof(this.maximized) === "Integer")
				this.windowSizeMenu.enabled	= !fullScreen && !this.maximized;
			else
				this.windowSizeMenu.enabled	= !fullScreen;
			}

		if (typeof(this.hintlayer) === "Object")
		{
			invalidate this.hintlayer;
			this.hintlayer = void;
		}
	}
	function onDisplayChanged() {
//		dm("callDisplayChanged");
		callHook("onDisplayChangedHook", this);
	}

	function fullScreenAfterChangeScreenMode()
	{
		this.fullScreen = true;
		this.removeHook("afterChangeScreenMode", fullScreenAfterChangeScreenMode);
	}

	function onWindowSizeMenuItemClick(sender, w)
	{
		if(!w)
		{
			windowResizeable = !windowResizeable;
			updateWindowResizeable();
			return;
		}
		if(!fullScreen)
@if(GAME_WOHN)
			setInnerSize(w, global.Math.round((w * 9) / 16) | 0);
@endif
@if(GAME_FATE||GAME_FHAT)
			setInnerSize(w, global.Math.round((w * 3) / 4) | 0);
@endif
	}

@if(GAME_WOHN)
	var	windowWidthes	= [ 640, 800, 1024, 1280, 1440, 1600, 1920 ];
@endif
@if(GAME_FATE||GAME_FHAT)
	var	windowWidthes	= [ 200, 400, 640, 800, 1024, 1280, 1440 ];
@endif
	function updateWindowSizeChecked(size)
	{
		if(typeof(this["window"+windowWidthes[0]+"MenuItem"]) === "Object")
		{
			for (var i = 0, internal_forloop_count = windowWidthes.count; i < internal_forloop_count; i += 1)
				this["window"+windowWidthes[i]+"MenuItem"].checked	= size == windowWidthes[i];
		}
		updateWindowResizeable();
	}

	function updateWindowResizeable()
	{
		if(typeof(this.windowResizeableMenuItem) === "Object")
			this.windowResizeableMenuItem.checked = !windowResizeable;
	}

	function onLimitWindowSizeMenuItemClick(sender)
	{
	limitWindowSize = !limitWindowSize;
	updateLimitWindowSizeMenuItem();
	if (limitWindowSize == true)
		limitSize();
	}
	function updateLimitWindowSizeMenuItem()
	{
	if(typeof(this.limitWindowSizeMenuItem) === "Object")
		this.limitWindowSizeMenuItem.checked = limitWindowSize;
	}

	function setSystemStateFromSystemVariables()
	{
		super.setSystemStateFromSystemVariables();
		windowResizeable = scflags.windowResizeable !== void ? scflags.windowResizeable : false;
		limitWindowSize = scflags.limitWindowSize !== void ? scflags.limitWindowSize : true;
		changeMenuBarState(scflags.menuBarState !== void ? scflags.menuBarState : defaultMenuBarState);
	}

@if(GAME_WOHN)
	function onMove()
	{
		if (typeof(System.getMonitorInfo) !== "Object")
		{
			return;
		}
		var	mon	= System.getMonitorInfo(true, this);
		var	mw	= mon.work.w, mh = mon.work.h;

		//	zoomNumer == zoomDenom 以外のときは、複数のモニターに重ならないよう修正する
		if(!fullScreen && zoomNumer != zoomDenom && limitSize(mon))
			return;

		//	表示されているモニタが変化したか、そのウィンドウサイズにできるかを調べ、メニューを更新
		var	bw	= width - innerWidth, bh = height - innerHeight;	//	ウィンドウの枠のサイズ
		for (var i = 0, internal_forloop_count = windowWidthes.count; i < internal_forloop_count; i += 1)
		{
			var	w	= windowWidthes[i];
			var	h	= (w * 9) \ 16;
//			dm("monitor: "+mw+", "+mh+" / "+w+", "+h);
			if (typeof(this["window"+w+"MenuItem"]) === "Object")
			{
				this["window"+w+"MenuItem"].enabled	= mw >= w + bw && mh >= h + bh;
			}
		}
	}
@endif

	// スクリーン切り替え時にムービー再生を一時的に止めるロジック
	var	movieStore;
	function onMovieScreenChanging(full)
	{
		movieStore	= new AsyncTrigger(onMovieScreenChanged, "");
		var	states	= [];
		for (var i = 0, internal_forloop_count = numMovies; i < internal_forloop_count; i += 1)
		{
			var movie = movies[i], st = %[];
			if (typeof(movie) === "Object")
			{
				movie.store(st);
				movie.stop();
			}
			states.add(st);
		}
		movieStore.states	= states;
		movieStore.trigger();
	}

	function onMovieScreenChanged()
	{
		for (var i = 0, internal_forloop_count = numMovies; i < internal_forloop_count; i += 1)
		{
			var movie = movies[i];
			if (typeof(movie) === "Object")
			{
				movie.restore(movieStore.states[i]);
			}
		}
		invalidate movieStore;
		movieStore	= void;
	}

	// プライマリの位置が変わった
	function onMoviePrimaryPosChanged(ox, oy) {
		if (!isMain) return;
		for (var i = 0, internal_forloop_count = numMovies; i < internal_forloop_count; i += 1)
			with (movies[i]) .setOptions(%[ primox:ox, primoy:oy ]);
	}
	function onMovieStatusChanged(state, id)
	{
		// 拡張用スタブ（何もしない）
	}
	function onMoviePlay(id)
	{
		// ムービーの再生を開始した
		onMovieStatusChanged("play", id);
	}

	function resetFullScreen()
	{
		if(fullScreened)
		{
			try
			{
				fullScreen	= false;
				with(this.reFSTimer = new Timer(onCheckFS, ""))
					.interval	= 8, .enabled	= true;
			}
			catch(e)
				Debug.notice("フルスクリーンのリセットに失敗しました。: "+e.message);
		}
	}

	function onCheckFS
	{
		//	フルスクリーンの解除処理が終了したら、再度フルスクリーンにする
		if(typeof(this.screenModeChangedTrigger) !== "Object" || !screenModeChangedTrigger.trigged)
		{
			try
				fullScreen	= true;
			catch(e)
				Debug.notice("フルスクリーンのリセットに失敗しました。: "+e.message);
			reFSTimer.enabled	= false;
			invalidate reFSTimer;
			reFSTimer	= void;
			callHook("afterChangeMagnifyType");
		}
@if(DEBUG)
		else
			dm("フルスクリーン解除待ち");
@endif
	}

	function onInnerMagnifyMenuItemClick(sender)
	{
		System.setArgument("-fszoom", "inner");
		if (typeof(this.innerMagnifyMenuItem) === "Object")
		{
			innerMagnifyMenuItem.checked	= true;
			outerMagnifyMenuItem.checked = noneMagnifyMenuItem.checked	= false;
		}
		resetFullScreen();
	}

	function onOuterMagnifyMenuItemClick(sender)
	{
		System.setArgument("-fszoom", "outer");
		if (typeof(this.outerMagnifyMenuItem) === "Object")
		{
			outerMagnifyMenuItem.checked	= true;
			innerMagnifyMenuItem.checked = noneMagnifyMenuItem.checked	= false;
		}
		resetFullScreen();
	}

	function onNoneMagnifyMenuItemClick(sender)
	{
		System.setArgument("-fszoom", "none");
		if (typeof(this.noneMagnifyMenuItem) === "Object")
		{
			noneMagnifyMenuItem.checked	= true;
			outerMagnifyMenuItem.checked = innerMagnifyMenuItem.checked	= false;
		}
		resetFullScreen();
	}
}
global.KAGWindow = KAGWindow_patch_zoom_window_override;

global.Movie_patch_zoom_window_original = Movie;
class Movie_patch_zoom_window_override extends Movie_patch_zoom_window_original
{
	function Movie_patch_zoom_window_override()
	{
		super.Movie(...);
	}

	function Movie()
	{
		Movie_patch_zoom_window_override(...);
	}

	var _left, _top, _boundWidth, _boundHeight, _offsetx, _offsety;
	property offsetx { getter { return (mode == vomMixer || mode == vomOverlay) ? _offsetx : 0; } }
	property offsety { getter { return (mode == vomMixer || mode == vomOverlay) ? _offsety : 0; } }
	property left { getter { return _left; } setter(v) { super.left = (_left = v) + offsetx; } }
	property top  { getter { return _top;  } setter(v) { super.top  = (_top  = v) + offsety; } }
	function setBounds(x, y, w, h) {
		return super.setBounds((_left=x) + offsetx, (_top=y) + offsety, (_boundWidth=w), (_boundHeight =h));
	}

	function setOptions(elm)
	{
		var l = left, t = top, w = width, h = height;
		var set = false;
		(set = true, _offsetx = +elm.primox) if (elm.primox !== void);
		(set = true, _offsety = +elm.primoy) if (elm.primoy !== void);
		if (elm.left !== void || elm.top !== void || elm.width !== void || elm.height !== void)
		{
			set = false;
		}
		if (set)
		{
			setBounds(l, t, w, h);
		}
		return super.setOptions(...);
	}
}
global.Movie = Movie_patch_zoom_window_override;

