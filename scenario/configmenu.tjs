@if(__CONFIG_MENU_DEFINED__==0)
@set(__CONFIG_MENU_DEFINED__=1)

//	メッセージ表示間隔
var	CFminCh	= 0, CFmaxCh = 200;
var	CFminPageWait = 0, CFmaxPageWait = 9950;
var	CFminLineWait = 0, CFmaxLineWait = 2990;

var	CFbaseAbsolute	= 3000000;
var	CFactionTime	= 200;

//	推奨設定
var	RecommendedSettings	= %[
	userChSpeed:35,
	chNonStopToPageBreak:false,
	userCh2ndSpeed:26,
	ch2ndNonStopToPageBreak:false,
	autoModePageWait:3000,
	autoModeLineWait:2200,
	effectSkip:false,
	effectCut:false,
	speffect:true,
];

function openConfigMenu()
{
	if(tf.cf_opened)
		return;
	tf.cf_opened	= true;
	sf.cf_page	= 1 if sf.cf_page == void;

	//	save/load メニューは閉じる
	closeSaveMenu(true);
	closeLoadMenu(true);

	inMenu("config");
	Scripts.execStorage("config_system.ttd");

@if(ZOOM_WINDOW)
	//	ウィンドウメニューからウィンドウサイズが変更されたときにも追随するように
	kag.addHook("afterChangeWindowSize", CFonAfterChangeWindowSize);
	kag.addHook("afterChangeScreenMode", CFonAfterChangeScreenMode);
	kag.addHook("afterChangeMagnifyType", CFonAfterChangeMagnifyType);
	kag.addHook("afterChangeWindowResizeable", CFonAfterChangeWindowResizeable);

	kag.addHook("keyDown", CFonKeyDown);	//	Cキーで閉じるため
@endif
	Menu_object.keyDownCallback	= CFonKeyDown;
	Menu_object.setClick(, "closeConfigMenu()");
	Menu_object.setDisfocusableAll();	//	titleメニューや右クリックメニューを focusable=false にする

	CFopenPage(sf.cf_page, true);
}

function closeConfigMenu()
{
	if(!tf.cf_opened)
		return;
	delete tf.cf_opened;
	delete tf.cf_opentick;
	kag.setUserSpeed();
	kag.saveSystemVariables();
	CFcloseFontSelect();
	outMenu("config");

@if(ZOOM_WINDOW)
	kag.removeHook("afterChangeWindowSize", CFonAfterChangeWindowSize);
	kag.removeHook("afterChangeScreenMode", CFonAfterChangeScreenMode);
	kag.removeHook("afterChangeMagnifyType", CFonAfterChangeMagnifyType);
	kag.removeHook("afterChangeWindowResizeable", CFonAfterChangeWindowResizeable);
	kag.removeHook("keyDown", CFonKeyDown);	//	Cキーで閉じるため
@endif
	with(Menu_object)
	{
		.playSE(closese);
		delete .keyDownCallback;
		.resetClick();
		.revertDisfocusable();
	}

	//開くのと閉じるのを同時に行わせないように遅延させる
	asyncCaller.call(function()
	{
		switch(sf.cf_page)
		{
		case 1:	CFcloseSystem(true);	break;
		case 2:
			CFcloseMessage(true);
			break;
		case 3:	CFcloseSound(true);		break;
		case 4:	CFcloseShortcut(true);	break;
		}
	});

	//	cf.ch2ndSkip が true に変更されたら、既読スキップを開始する
	//	ただし、アーカイブの読み込みでない間
	//dm("cf.ch2ndSkip = "+cf.ch2ndSkip);
	if(cf.ch2ndSkip && !f.doArchiveMenu)
	{
		if(tf.do_systemmenu)
			global.startSkipAtOutMenu	= true;
		else
			kag.skipToStop(true) if kag.getCurrentRead();
	}
}

//	ウィンドウサイズが変更された
function CFonAfterChangeWindowSize()
{
	var	fs	= kag.fullScreen;
	for(var i=0; i<kag.windowWidthes.count; i++)
	{
		var	sz	= kag.windowWidthes[i];
		var	target	= Menu_object.find("サイズ" + sz, PRIMARY);
		if(target != void && target isvalid)
		{
			if(sz != kag.innerWidth)
			{
				target.on = 0;
				if(!fs && kag["window"+sz+"MenuItem"].enabled)
					target.release(), target.enabled	= true;
				else
					target.enabled	= false;
			}
			else
				target.on = true, target.release();
		}
	}
}

//	フルスクリーン状態が変更された
function CFonAfterChangeScreenMode()
{
	var	v	= kag.fullScreen;
	with(Menu_object)
	{
		.setProp("フルスクリーン表示", "on", v, PRIMARY);
		var	fszoom	= System.getArgument("-fszoom");
		for(var i=0; i<CFfullScreenModes.count; i+=3)
		{
			var	enabled	= v;
			enabled	= false if CFfullScreenModes[i+1] == "none" && kag.fullScreenMode == 0;
			.setProps(CFfullScreenModes[i], ["enabled", enabled, "on", fszoom == CFfullScreenModes[i+1]], PRIMARY);
		}

		.setProp("ウィンドウ表示", "on", !v, PRIMARY);
		for(var i=0; i<kag.windowWidthes.count; i++)
		{
			var	sz	= kag.windowWidthes[i];
			.setProp("サイズ"+sz, "enabled", !v && kag["window"+sz+"MenuItem"].enabled, PRIMARY);
		}
	}
}

//	フルスクリーンの拡大状態が変更された
function CFonAfterChangeMagnifyType()
{
	with(Menu_object)
	{
		var	fszoom	= System.getArgument("-fszoom");
		for(var i=0; i<CFfullScreenModes.count; i+=3)
			.setProp(CFfullScreenModes[i], "on", CFfullScreenModes[i+1] == fszoom, PRIMARY);
	}
}

//	サイズ可変指定が変更された
function CFonAfterChangeWindowResizeable()
{
	with(Menu_object)
	{
		.setProp("サイズ可変", "on", !kag.windowResizeable, PRIMARY);
	}
}

//	キーが押下された
function CFonKeyDown(key, shift)
{
	if(tf.do_askyesno)
		return false;
	if(key == VK_C)
	{
		if(tf.cf_fontopened)
			CFcloseFontSelect();
		else
			closeConfigMenu();
@if(0)
		if(shift == ssCtrl)
			doRClick();
@endif
		return true;
	}
	return false;
}

//	ページ切替ボタンとBackボタンの遷移先を指定する
function CFsetFocusNext(sys, msg, snd, stc, bak)
{
	with(Menu_object)
	{
		.setProp("システム", "downItems", [sys], PRIMARY);
		.setProp("メッセージ", "downItems", [msg], PRIMARY);
		.setProp("サウンド/エフェクト", "downItems", [snd], PRIMARY);
		.setProp("ショートカットキー", "downItems", [stc], PRIMARY);
		.setProp("Back", "upItems", [bak], PRIMARY);
		.setProp("Default", "upItems", [bak], PRIMARY);
	}
}

//	数値変換用プロパティ定義
var	MAX_LME_TIME	= 100;	//	既読フェードアウトの時間(文字数)
property lme_time
{
	setter(v)
	{
		v	= int(v * MAX_LME_TIME / 100 + 0.5);
		cf.lme_time	= Math.max(0, Math.min(MAX_LME_TIME, v));
	}
	getter	{ return int(cf.lme_time * 100 / MAX_LME_TIME + 0.5); }
}

property lme_opacity
{
	setter(v)
	{
		v	= int(v * 255 / 100 + 0.5);
		cf.lme_opacity	= Math.max(0, Math.min(255, v));
	}
	getter	{ return int(cf.lme_opacity * 100 / 255 + 0.5); }
}

//	ページ切り替えボタンが押された時の処理
function CFopenPage(pgno, firsttime=false)
{
	tf.cf_opentick	= System.getTickCount();

	//	コンフィグで開始されたアクションが存在していたら、停止する
/*	var	menuitems	= Menu_object.getMenuItems(PRIMARY);
	for(var i=0; i<menuitems.count; i++)
	{
		var	item	= menuitems[i];
		if(item != void && item isvalid && kag.isInAction(item))
		{
			dm("clear: "+item.name);
			item.doInvalidate();
		}
	}
*/
	//	開いていたら閉じる
	if(pgno != sf.cf_page)
	{
		switch(sf.cf_page)
		{
		case 1:	CFcloseSystem();	break;
		case 2:	CFcloseMessage();	break;
		case 3:	CFcloseSound();		break;
		case 4:	CFcloseShortcut();	break;
		}
	}
	//	ひと呼吸おいて、開く
	sf.cf_page = pgno;
	asyncCaller.call(function(firsttime)
	{
		//	開く
		switch(sf.cf_page)
		{
		case 1:	CFopenSystem(firsttime);	break;
		case 2:	CFopenMessage(firsttime);	break;
		case 3:	CFopenSound(firsttime);		break;
		case 4:	CFopenShortcut(firsttime);	break;
		}
	}, firsttime);
}

//	指定の setfunc でタイムラインを調整して、開く
function CFplayTimeline(sno, setfunc, firsttime=false, isclose=false, closeall=false)
{
	var	tdata	= __get_config_system_timelinedata(sno);
	var name2pos = tdata[0], creates = tdata[1], actions = tdata[2];
	setfunc(name2pos, creates, actions, isclose) if setfunc != void;

	var	ignore;
	var names	= ["システム","メッセージ","サウンド/エフェクト","ショートカットキー"];
	if(firsttime)
	{//	初回はページ切り替えボタンの設定を行う
		for(var i=0; i<names.count; i++)
		{
			var	selected	= i+1 == sf.cf_page;
			setCreateProps(creates[name2pos[names[i]]], %[on:false, itemMode:imButton,
				mouseUp:"CFopenPage("+(i+1)+");release();"], 3);
		}
		setCreateProps(creates[name2pos["Back"]], %[
			mouseUp:"closeConfigMenu();release();",
			pressse:"",
		], 2);
		setCreateProps(creates[name2pos["Default"]], %[
			mouseUp:"setConfigToDefault();release();",
		], 2);
		ignore	= %[];
	}
	else if(closeall)
	{
		ignore	= %[];	//	完全に閉じるときはすべてアクションさせる
	}
	else
	{//	二回目以降はフェード等行わず、ボタンの状態変更のみ
		ignore	= %[基本背景:1, タイトル:1, タイトルコピー:1, タイトル草1:1, タイトル草2:1, タイトル草3:1, Back:1, Default:1];
		for(var i=0; i<names.count; i++)
		{
			ignore[names[i]]= 1;
			var	item		= Menu_object.find(names[i], PRIMARY);
			var	selected	= i+1 == sf.cf_page;
			item.on			= selected;
			item.itemMode	= selected ? imParts : imButton;
			item.leave() if !selected;
		}
	}

	//	閉じるときは現在の absolute を設定する
	if(isclose)
	{
		var	items	= Menu_object.getMenuItems(PRIMARY);
		for(var i=0; i<items.count; i++)
		{
			var	item	= items[i], pos;
			if(item != void && item isvalid && (pos = name2pos[item.name]) !== void)
			{
				setCreateProp(creates[pos], "absolute", item.absolute - CFbaseAbsolute);
				item.hint	= "";
			}
		}
	}

	Menu_object.playTimeline(PRIMARY, creates, actions, %[absolute:CFbaseAbsolute], ignore, isclose,, false);

	if(firsttime)
		Menu_object.setProps(names[sf.cf_page - 1], ["on", true, "itemMode", imParts], PRIMARY);
}

var	CFfullScreenModes	= [
	"フルスク拡大しない",	"none",		"kag.onNoneMagnifyMenuItemClick()",
	"フルスク拡大表示",		"outer",	"kag.onOuterMagnifyMenuItemClick()",
	"フルスクフィット",		"inner",	"kag.onInnerMagnifyMenuItemClick()"
];
function CFsetSystemMenuItems(name2pos, creates, actions, isclose)
{
	var	v	= kag.fullScreen;
	var	name;
/*	setCreateProps(creates[name2pos["フルスクリーン表示"]], %[on:v, disabled:v], 2);
	setCreateProps(creates[name2pos["ウィンドウ表示"]], %[on:!v, disabled:!v], 2);
*/	setCreateProp(creates[name2pos["フルスクリーン表示"]], "on", v);
	setCreateProp(creates[name2pos["ウィンドウ表示"]], "on", !v);
	setCreateProp(creates[name2pos["サイズ可変"]], "on", !kag.windowResizeable);

	if(isclose)
	{
		var	onoffnames	= [ "フェードアウト濃", "フェードアウト薄", "フェードアウト長", "フェードアウト短" ];
		for(var i=0; i<onoffnames.count; i++)
		{
			clearCreateProp(creates[name2pos[onoffnames[i]]], %[opacity:1], 1);
			var	item	= Menu_object.find(onoffnames[i], PRIMARY);
			if(item == void || !(item isvalid))
				continue;
			setCreateProp(creates[name2pos[onoffnames[i]]], "enabled", !cf.lme_disable);
			setActionsTop(actions[name2pos[onoffnames[i]]], %[opacity:item.opacity], 1);
		}
	}
	else
	{
		v	= cf.lme_disable;
//		var	opac	= v ? 64 : 255;
		var	btnnames= ["フェードアウト濃", "フェードアウト薄", "フェードアウト長", "フェードアウト短" ];
		for(var i=0; i<btnnames.count; i++)
		{
			name	= btnnames[i];
//			setActionLast(actions[name2pos[name]], "opacity", opac);
			setCreateProp(creates[name2pos[name]], "enabled", !v);
		}
	}

	var	v	= kag.fullScreen;
	var	fszoom	= System.getArgument("-fszoom");
	for(var i=0; i<CFfullScreenModes.count; i+=3)
	{
		name	= CFfullScreenModes[i];
		var	elm	= %[on:fszoom == CFfullScreenModes[i+1], enabled:v];
		elm.enabled	= false if CFfullScreenModes[i+1] == "none" && kag.fullScreenMode == 0;
		setCreateProps(creates[name2pos[name]], elm, 2);
	}

	for(var i=0; i<kag.windowWidthes.count; i++)
	{
		var	sz	= kag.windowWidthes[i];
		setCreateProps(creates[name2pos["サイズ"+sz]], %[enabled:(!v & kag["window"+sz+"MenuItem"].enabled), on:sz == kag.innerWidth]);
	}

	v	= cf.disableCharAppearAction;
	setCreateProp(creates[name2pos["テキスト演出フェードイン"]], "on", !v);
	setCreateProp(creates[name2pos["テキスト演出なし"]], "on", v);

	v	= cf.lme_disable;
	setCreateProp(creates[name2pos["既読演出なし"]], "on", v);
	setCreateProps(creates[name2pos["既読フェードアウト"]], %[on:!v, downItems:["フェードアウト短"]], 2);
	setCreateProp(creates[name2pos["フェードアウトON"]], "visible", !v);
	setCreateProp(creates[name2pos["フェードアウトOFF"]], "visible", v);

	v	= cf.doubleCushionMenuOpen;
	setCreateProps(creates[name2pos["マウス設定A"]], %[on:!v, upItems:["フェードアウト短"], downItems:["マウス自動移動"]], 2);
	setCreateProp(creates[name2pos["マウス設定B"]], "on", v);

	v	= cf.autoMouseMove;
	setCreateProps(creates[name2pos["マウス自動移動"]], %[on:v, upItems:["マウス設定A"]]);
}

function CFopenSystem(firsttime=false)
{
	if(!tf.cf_opened)
		return;
	CFplayTimeline(firsttime ? 1 : 11, CFsetSystemMenuItems, firsttime);

	CFsetFocusNext(, "テキスト演出フェードイン", "テキスト演出なし", "テキスト演出なし", "マウス自動移動");

	//	追加メニューアイテム
	var	cont	= kag.transCount > 0;
	with(Menu_object)
	{
		var	items	= [];
		items.add(.addMenuItem(%[
			"page"=>PRIMARY,"class"=>"NumberMenuItemLayer","center"=>643,"vcenter"=>270,
			"digit"=>3,"value"=>lme_time,"min"=>0,"max"=>100,"storage"=>"c_フェードイン用数字",
			"absolute"=>9000+CFbaseAbsolute,"visible"=>1,"name"=>"既読フェードアウト時間表示","opacity"=>0,
			enabled:!cf.lme_disable, cont:cont
		]));
		items.add(.addMenuItem(%[
			"page"=>PRIMARY,"class"=>"NumberMenuItemLayer","center"=>869,"vcenter"=>270,
			"digit"=>3,"value"=>lme_opacity,"min"=>0,"max"=>100,
			"storage"=>"c_フェードイン用数字","absolute"=>9000+CFbaseAbsolute,"visible"=>1,
			"name"=>"既読フェードアウト不透明度表示","opacity"=>0,
			enabled:!cf.lme_disable, cont:cont
		]));
		var	sample;
		items.add(sample = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"MessageMenuItemLayer","left"=>465,"top"=>293,"width"=>490,"height"=>85,
			"absolute"=>9000+CFbaseAbsolute,"opacity"=>1,"name"=>"フェードサンプル表示","margin"=>0,
			"framecolor"=>0,"frameopacity"=>0,"linespacing"=>9,"msgdelay"=>1500, "ibv"=>false, "visible"=>true,
			enabled:!cf.lme_disable, str:__("魔法使いの夜 ABC abc 012"), cont:cont
		]));
		sample.updateTextInfo	= function
		{
			var tl = str.length;
			var wt = tl * kag.userChSpeed + 500;
			stopMessage();
			text = str + "<w" + string(wt) + "><r><e>" +
				   str + "<w" + string(wt) + "><r><e>" +
				   "<w" + string(1000) + ">";
		} incontextof sample;
		sample.updateTextInfo();

		var	delay	= 100;
		var	time	= firsttime ? 200 : 150;
		for(var i=0; i<items.count; i++)
		{
			var	item	= items[i];
			item.top	-= 10;
			item.ssact(delay+time, "top", item.top + 10);
			item.ssact(time, "opacity", cf.lme_disable ? 128 : 255, delay);
		}
		if(cf.lme_disable)
		{
			sample.stopMessage();
			sample.clear();
		}
	}
}

function CFcloseSystem(closeall=false)
{
	//プレビューをまず真っ先に消す
	var obj = Menu_object.find("フェードサンプル表示", PRIMARY);
	if( obj !== void && isvalid obj )
		obj.stopMessage();

	//	追加メニューアイテムを隠す
	var	items	= [ "既読フェードアウト時間表示", "既読フェードアウト不透明度表示", "フェードサンプル表示" ];
	var	time	= closeall ? 300 : 250;
	for(var i=0; i<items.count; i++)
	{
		var	item	= Menu_object.find(items[i], PRIMARY);
		if(item == void || !(item isvalid))
			continue;
		item.hint	= "";
		item.ssact(time, "top", item.top + 10,,, false);
		item.vanish(time);
	}

	CFplayTimeline(closeall ? 2 : 12, CFsetSystemMenuItems,, true, closeall);
}

//	フルスクリーン/ウィンドウ切替など
function configChgWindowStyle(item)
{
	if(item.name.substr(0, 3) == "サイズ")
	{
		kag.onWindowSizeMenuItemClick(, item.name.substr(3));
		CFonAfterChangeWindowSize();
	}
	else if(item.name == "フルスクリーン表示")
	{
		if(kag.fullScreen)
		{
			item.release();
			return;
		}
		askYesNo(__("フルスクリーン表示に変更しますか？"),, CFtoFullScreen, configChgWindowStyleNo, item);
	}
	else if(item.name == "ウィンドウ表示")
	{
		if(!kag.fullScreen)
		{
			item.release();
			return;
		}
		askYesNo(__("ウィンドウ表示に変更しますか？"),, CFtoWindow, configChgWindowStyleNo, item);
	}
	else
	{
		var	fszoom	= System.getArgument("-fszoom");
		for(var i=0; i<CFfullScreenModes.count; i+=3)
		{
			if(item.name == CFfullScreenModes[i])
			{
				if(fszoom != CFfullScreenModes[i+1])
					(CFfullScreenModes[i+2])!;	//	変更
				item.release();
				break;
			}
		}
	}
}

function CFtoFullScreen(item)
{
	item.release();
	kag.onFullScreenMenuItemClick();
}

function CFtoWindow(item)
{
	item.release();
	kag.onWindowedMenuItemClick();
}

function configChgWindowStyleNo(item)
{
	item.release();
}

function CFvalueRepeat(val, power, obj, targetprop)
{
	if(obj != void && obj isvalid)
	{
		obj.value	+= val * (System.getKeyState(VK_CONTROL) ? power : 1);
		global[targetprop]	= obj.value;
	}
}

//	システムのボタン押下
function configSystemMouseDown(item)
{
	var	mv	= -1;
	var	obj, power;
	switch(item.name)
	{
	case "フェードアウト濃":
		mv	= 1;
	case "フェードアウト薄":
		item.press();
		power	= 5;
		obj		= Menu_object.find("既読フェードアウト不透明度表示", PRIMARY);
		item.startRepeat(400, 100, CFvalueRepeat, mv, power, obj, "lme_opacity");
		obj.value	+= mv * (System.getKeyState(VK_CONTROL) ? power : 1);
		lme_opacity	= obj.value;
		break;

	case "フェードアウト長":
		mv	= 1;
	case "フェードアウト短":
		item.press();
		power	= 5;
		obj		= Menu_object.find("既読フェードアウト時間表示", PRIMARY);
		item.startRepeat(400, 100, CFvalueRepeat, mv, power, obj, "lme_time");
		obj.value	+= mv * (System.getKeyState(VK_CONTROL) ? power : 1);
		lme_time	= obj.value;
		break;
	}
}

//	システムのボタン離した
function configSystemMouseUp(item)
{
	var	obj;
	var	names	= ["フェードアウト濃","フェードアウト薄","フェードアウト長","フェードアウト短"];
	var	numnames= ["既読フェードアウト時間表示","既読フェードアウト不透明度表示"];
	with(Menu_object)
	{
		switch(item.name)
		{
		case "フェードアウト濃":
		case "フェードアウト薄":
		case "フェードアウト長":
		case "フェードアウト短":
			item.release();
			item.stopRepeat();
			break;

		case "マウス自動移動":
			cf.autoMouseMove	= item.on = !item.on;
			item.enter();
			break;

		case "サイズ可変":
			item.on = !item.on;
			kag.windowResizeable = !item.on;
			kag.updateWindowResizeable();
			item.enter();
			break;

		case "マウス設定A":
		case "マウス設定B":
			var	rev	= item.name.substr(5, 1) == "A" ? "B" : "A";
			item.on	= true;
			item.enter();
			.setProp("マウス設定" + rev, "on", false, PRIMARY);
			cf.doubleCushionMenuOpen	= rev == "A";
			break;

		case "既読演出なし":
		case "既読フェードアウト":
			cf.lme_disable	= item.name.substr(4, 2) == "なし";
			.setProp("既読"+(cf.lme_disable ? "フェードアウト" : "演出なし"), "on", false, PRIMARY);
			.setProp("フェードアウトON", "visible", !cf.lme_disable, PRIMARY);
			.setProp("フェードアウトOFF", "visible", cf.lme_disable, PRIMARY);
			item.on	= true;
			item.enter();
			for(var i=0; i<names.count; i++)
//				.setProps(names[i], ["enabled", !cf.lme_disable, "opacity", cf.lme_disable ? 64 : 255], PRIMARY);
				.setProp(names[i], "enabled", !cf.lme_disable, PRIMARY);
			for(var i=0; i<numnames.count; i++)
				.setProp(numnames[i], "opacity", cf.lme_disable ? 128 : 255, PRIMARY);
			obj	= .setProp("フェードサンプル表示", "opacity", cf.lme_disable ? 1 : 255, PRIMARY);
			if(obj != void && obj isvalid)
			{
				if(cf.lme_disable)
					obj.stopMessage(), obj.clear();
				else
					obj.clear(), obj.playMessage();
			}
			break;

		case "テキスト演出なし":
		case "テキスト演出フェードイン":
			cf.disableCharAppearAction	= item.name.substr(6, 2) == "なし";
			.setProp("テキスト演出" + (cf.disableCharAppearAction ? "フェードイン" : "なし"), "on", false, PRIMARY);
			item.on	= true;
			item.enter();
			break;
		}
	}
}

function CFsetMessageMenuItem(name2pos, creates, actions, isclose)
{
	var	v, name;

	setCreateProp(creates[name2pos["スキップの確認"]], "on", !cf.skipWithoutCheck);
	setCreateProp(creates[name2pos["既読ページ末一気"]], "on", kag.ch2ndNonStopToPageBreak);
	setCreateProp(creates[name2pos["未読ページ末一気"]], "on", kag.chNonStopToPageBreak);
	cf.skipKey	= 2 if cf.skipKey < 1 || cf.skipKey > 3;
	v	= cf.skipKey;
	setCreateProp(creates[name2pos["早送りキーctrl"]], "on", v == 2);
	setCreateProp(creates[name2pos["早送りキーshift"]], "on", v == 3);
	setCreateProp(creates[name2pos["早送りキーenter"]], "on", v == 1);

/*	v = cf.stopSkipAtAlternative;
	setCreateProp(creates[name2pos["選択肢Skip解除OFF"]], "on", !v);
	setCreateProp(creates[name2pos["選択肢Skip解除ON"]], "on", v);
*/
	v = cf.skipOnly2nd;
	setCreateProp(creates[name2pos["早送り既読のみOFF"]], "on", !v);
	setCreateProp(creates[name2pos["早送り既読のみON"]], "on", v);

	v = +cf.scene2ndSkip;
	setCreateProp(creates[name2pos["既読SceneSkipOFF"]], "on", !v);
	setCreateProp(creates[name2pos["既読SceneSkipON"]], "on", v);

/*
	v = +cf.ch2ndSkip;
	setCreateProp(creates[name2pos["既読MsgSkipOFF"]], "on", !+v);
	setCreateProp(creates[name2pos["既読MsgSkipON"]], "on", +v);
*/
	v = +cf.autoModeArrowClick;
	setCreateProp(creates[name2pos["自動中カットOFF"]], "on", !+v);
	setCreateProp(creates[name2pos["自動中カットON"]], "on", +v);

	setCreateProp(creates[name2pos["フォント変更"]], "on", false);
}

//	クリックした位置を値にする
function CFsetValueBySpace(val, target, inv=false)
{
	var	item	= Menu_object.find(target, PRIMARY);
	if(item != void && item isvalid)
	{
		var	w	= inv ? -item.width / 2 - 4 : -1;
		item.pos= val + w;
		item.onMouseUp();
	}
}

//	プールで再利用されないよう派生させたクラス(表示だけ、イベントを拾うだけのコントロールなど)
class TmpMenuItemLayer extends MenuItemLayer
{
	function TmpMenuItemLayer()
	{
		super.MenuItemLayer(...);
	}
}

//	未読メッセージ表示間隔を変更したときの処理
//		推奨より早くした場合に演出がカットされる可能性があることを伝える
function changeUserChSpeed(value)
{
	var	last	= kag.userChSpeed;
	tf.lastUserChSpeed	= last if tf.lastUserChSpeed === void;
	return kag.userChSpeed = value;
}
function changeUserChSpeedWithCheck(value)
{
	var	last	= kag.userChSpeed;
	tf.lastUserChSpeed	= last if tf.lastUserChSpeed === void;
	if(!sf.userChSpeedChecked && value < RecommendedSettings.userChSpeed)
	{
		askYesNo(__("未読メッセージ表示間隔を推奨以下に設定した場合、一部演出がカットされることがあります。\n変更してもよろしいですか？"),
			"設定変更確認", onFastUserChSpeed, cancelFastUserChSpeed);
		return tf.newUserChSpeed = value;
	}
	else
		tf.lastUserChSpeed	= void;
	return kag.userChSpeed = value;
}
function onFastUserChSpeed()
{
	Menu_object.setProp("未読メッセージ表示間隔", "value", kag.userChSpeed = tf.newUserChSpeed, PRIMARY);
	delete tf.newUserChSpeed;
	delete tf.lastUserChSpeed;
	sf.userChSpeedChecked	= true;
}
function cancelFastUserChSpeed()
{
	Menu_object.setProp("未読メッセージ表示間隔", "value", kag.userChSpeed = tf.lastUserChSpeed, PRIMARY);
	Menu_object.setProp("未読メッセージ表示間隔変更", "value", kag.userChSpeed, PRIMARY);
	delete tf.newUserChSpeed;
	delete tf.lastUserChSpeed;
}

function CFopenMessage(firsttime=false)
{
	if(!tf.cf_opened)
		return;
	CFplayTimeline(firsttime ? 3: 13, CFsetMessageMenuItem, firsttime);

	CFsetFocusNext("未読メッセージ表示間隔変更",, "既読MsgSkipON", "既読MsgSkipOFF", "早送り既読のみOFF");

	var	cont	= kag.transCount > 0;
	with(Menu_object)
	{
		//	追加メニューアイテム
		var	item;
		var	items	= [];

		kag.autoModePageWait	= 0 if kag.autoModePageWait < 0;
		kag.autoModeLineWait	= 0 if kag.autoModeLineWait < 0;

		var	baseabsolute	= .getProp("メッセージ用背景", "absolute", PRIMARY);
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"NumberMenuItemLayer","center"=>269,"vcenter"=>154,
			"digit"=>3,"value"=>kag.userChSpeed,
			"min"=>CFminCh,"max"=>CFmaxCh,"storage"=>"c_メッセージ用数字",
			"absolute"=>baseabsolute+50,"visible"=>1,
			"name"=>"未読メッセージ表示間隔","opacity"=>0,"aligncenter"=>1, cont:cont
		]));
		var	cmd1	= 'Menu_object.setProp("未読メッセージ表示間隔","value",changeUserChSpeedWithCheck(this.value),PRIMARY)';
		var	cmd2	= 'Menu_object.setProp("未読メッセージ表示間隔","value",changeUserChSpeed(this.value),PRIMARY)';
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>128,
			"range"=>324,invert:true,"min"=>CFminCh,"max"=>CFmaxCh, step:1, "storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>baseabsolute+50,"visible"=>1,
			"name"=>"未読メッセージ表示間隔変更","targetprop"=>"value","opacity"=>0,
			"mouseup"=> cmd1, keydown:cmd1, mousemove:cmd2,
			upItems:["システム"], downItems:["未読ページ末一気"], leftItems:[void], rightItems:[void],
			value:kag.userChSpeed, cont:cont,
			"hint"=>__("未読メッセージの表示間隔(ミリ秒)を変更します[推奨: %s]").sprintf(RecommendedSettings.userChSpeed)
		]));

		var	lastabsolute	= .getProp("フォント変更", "absolute", PRIMARY);
		items.add(.addMenuItem(%[
			"page"=>PRIMARY,"class"=>"NumberMenuItemLayer","center"=>269,"vcenter"=>299,
			"digit"=>3,"value"=>kag.userCh2ndSpeed,
			"min"=>CFminCh,"max"=>CFmaxCh,"storage"=>"c_メッセージ用数字",
			"absolute"=>lastabsolute+50,"visible"=>1,
			"name"=>"既読メッセージ表示間隔","opacity"=>0,"aligncenter"=>1, cont:cont
		]));
		var	cmd	= 'Menu_object.setProp("既読メッセージ表示間隔","value",kag.userCh2ndSpeed=this.value,PRIMARY)';
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>273,
			"range"=>324,invert:true,"min"=>CFminCh,"max"=>CFmaxCh, step:1, "storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>lastabsolute+50,"visible"=>1,
			"name"=>"既読メッセージ表示間隔変更","targetprop"=>"value","opacity"=>0,
			"mouseup"=> cmd, keydown:cmd, mousemove:cmd,
			upItems:["フォント変更"], downItems:["既読ページ末一気"], leftItems:[void], rightItems:[void],
			value:kag.userCh2ndSpeed, cont:cont,
			"hint"=>__("既読メッセージの表示間隔(ミリ秒)を変更します[推奨: %s]").sprintf(RecommendedSettings.userCh2ndSpeed)
		]));

		lastabsolute	= .getProp("既読ページ末一気", "absolute", PRIMARY);
		items.add(.addMenuItem(%[
			"page"=>PRIMARY,"class"=>"NumberMenuItemLayer","center"=>269,"vcenter"=>389,
			"digit"=>4,"value"=>kag.autoModePageWait,
			"min"=>CFminPageWait,"max"=>CFmaxPageWait,
			"storage"=>"c_メッセージ用数字","absolute"=>lastabsolute+50,"visible"=>1,
			"name"=>"オートページ切替時間","opacity"=>0,"aligncenter"=>1, cont:cont
		]));
		var	cmd	= 'Menu_object.setProp("オートページ切替時間","value",kag.autoModePageWait=int this.value*50,PRIMARY)';
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>363,
			"range"=>324,invert:true,"min"=>CFminPageWait\50,"max"=>CFmaxPageWait\50,"step"=>1,
			"storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>lastabsolute+50,"visible"=>1,
			"name"=>"オートページ切替時間変更","opacity"=>0,
			"mouseup"=> cmd, keydown:cmd, mousemove:cmd,
			upItems:["既読ページ末一気"], downItems:["オート改行切替時間変更"], leftItems:[void], rightItems:[void],
			value:kag.autoModePageWait \ 50, cont:cont,
			"hint"=>__("オートモード時のページ切替時間(ミリ秒)を変更します[推奨: %s]").sprintf(RecommendedSettings.autoModePageWait)
		]));

		items.add(.addMenuItem(%[
			"page"=>PRIMARY,"class"=>"NumberMenuItemLayer","center"=>269,"vcenter"=>480,
			"digit"=>4,"value"=>kag.autoModeLineWait,
			"min"=>CFminLineWait,"max"=>CFmaxLineWait,
			"storage"=>"c_メッセージ用数字","absolute"=>lastabsolute+100,"visible"=>1,
			"name"=>"オート改行切替時間","opacity"=>0,"aligncenter"=>1, cont:cont
		]));
		var	cmd	= 'Menu_object.setProp("オート改行切替時間","value",kag.autoModeLineWait=int this.value*10,PRIMARY)';
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>454,
			"range"=>324,invert:true,"min"=>CFminLineWait\10,"max"=>CFmaxLineWait\10,"step"=>1,
			"storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>lastabsolute+100,"visible"=>1,
			"name"=>"オート改行切替時間変更","opacity"=>0,
			"mouseup"=> cmd, keydown:cmd, mousemove:cmd,
			upItems:["オートページ切替時間変更"], downItems:["Back"], leftItems:[void], rightItems:[void],
			value:kag.autoModeLineWait \ 10, cont:cont,
			"hint"=>__("オートモード時の改行待ち時間(ミリ秒)を変更します[推奨: %s]").sprintf(RecommendedSettings.autoModeLineWait)
		]));

		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>128,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"未読メッセージ表示間隔変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x + width / 2, "未読メッセージ表示間隔変更", true) if button === mbLeft;
		} incontextof item;

		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>273,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"既読メッセージ表示間隔変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x + width / 2, "既読メッセージ表示間隔変更", true) if button === mbLeft;
		} incontextof item;

		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>363,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"オートページ切替時間変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x + width / 2, "オートページ切替時間変更", true) if button === mbLeft;
		} incontextof item;

		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>454,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"オート改行切替時間変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x + width / 2, "オート改行切替時間変更", true) if button === mbLeft;
		} incontextof item;

/*		items.add(.addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>275,"vcenter"=>419,
			"storage"=>"c_book","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"オートページ切替時間アニメ","opacity"=>0, cont:cont
		]));
*/		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"MessageMenuItemLayer","left"=>79,"top"=>180,"width"=>394,"height"=>42,
			"absolute"=>baseabsolute+10,"opacity"=>1,"name"=>"メッセージサンプル表示","margin"=>2,
			"framecolor"=>0,"frameopacity"=>0,"linespacing"=>9,"msgdelay"=>1500, "ibv"=>false, "visible"=>true,
			text:__("<w500>魔法使いの夜 ABC abc 012<w1000>"), cont:cont
		]));

		var	delay	= 100;
		var	time	= firsttime ? 200 : 150;
		for(var i=0; i<items.count; i++)
		{
			item	= items[i];
			item.ssact(time + delay, "top", item.top + 10);
			item.ssact(time, "opacity", 255, delay);
		}

		var	btndirs	= [
			"未読ページ末一気",	"未読メッセージ表示間隔変更",	"フォント変更",
			"既読ページ末一気",	"既読メッセージ表示間隔変更",	"オートページ切替時間変更",
			"フォント変更",		"未読ページ末一気",				"既読メッセージ表示間隔変更",
			"スキップの確認",	"既読MsgSkipON",				"早送りキーenter",
			"早送りキーenter",	"スキップの確認",				"早送り既読のみOFF"
		];
		for(var i=0; i<btndirs.count; i+=3)
		{
			item	= .find(btndirs[i], PRIMARY);
			if(item != void && item isvalid)
			{
				item.upItems	= [ btndirs[i+1] ] if btndirs[i+1] != void;
				item.downItems	= [ btndirs[i+2] ] if btndirs[i+2] != void;
			}
		}
	}
}

function CFcloseMessage(closeall=false)
{
	//プレビューをまず真っ先に消す
	var obj = Menu_object.find("メッセージサンプル表示", PRIMARY);
	if( obj !== void && isvalid obj )
		obj.stopMessage();

	//	追加メニューアイテムを隠す
	var	items	= [ "未読メッセージ表示間隔変更", "既読メッセージ表示間隔変更", "オートページ切替時間変更", "オート改行切替時間変更",
					"未読メッセージ表示間隔", "既読メッセージ表示間隔", "オートページ切替時間", "オート改行切替時間",
					"未読メッセージ表示間隔変更余白", "既読メッセージ表示間隔変更余白","オートページ切替時間変更余白", "オート改行切替時間変更余白",
					"オートページ切替時間アニメ", "メッセージサンプル表示" ];
	var	time	= closeall ? 300 : 150;
	var	delay	= closeall ? 0 : 100;
	for(var i=0; i<items.count; i++)
	{
		var	item	 = Menu_object.find(items[i], PRIMARY);
		if(item == void || !(item isvalid))
			continue;
		item.hint	= "";
		item.ssact(time + delay, "top", item.top + 10,,, false);
		item.vanish(time);
	}

	CFplayTimeline(closeall ? 4 : 14, CFsetMessageMenuItem,, true, closeall);

	kag.autoModePageWait	= -4 if kag.autoModePageWait == 0;
	kag.autoModeLineWait	= -4 if kag.autoModeLineWait == 0;
}

//	未読ページ末一気の設定確認
function onNonStopToPageBreak()
{
//	Menu_object.setProp("未読ページ末一気", "on", true, PRIMARY);
	global.kag.chNonStopToPageBreak	= true;
	global.sf.nonStopToPageBreakChecked	= true;	//	確認するのは一度だけ
//	item.enter();
}
function cancelNonStopToPageBreak()
{
	Menu_object.setProp("未読ページ末一気", "on", false, PRIMARY);
//	item.enter();
}

//	メッセージのボタン離した
function configMessageMouseUp(item)
{
	switch(item.name)
	{
	case "スキップの確認":
		item.on	= !item.on;
		cf.skipWithoutCheck	= !item.on;
		item.enter();
		break;

	case "既読ページ末一気":
		kag.ch2ndNonStopToPageBreak	= item.on = !item.on;
		item.enter();
		break;

	case "未読ページ末一気":
		if(!item.on && !sf.nonStopToPageBreakChecked)
		{
			askYesNo(__("メッセージをページ末まで一気に表示する場合、一部演出がカットされることがあります。\n変更してもよろしいですか？"),
				"設定変更確認",  onNonStopToPageBreak, cancelNonStopToPageBreak);
			item.on	= true;
			break;
		}
		kag.chNonStopToPageBreak	= item.on = !item.on;
		item.enter();
		break;

	case "早送りキーenter":
	case "早送りキーctrl":
	case "早送りキーshift":
		var	skipbtns	= [ "早送りキーenter", "早送りキーctrl", "早送りキーshift" ];
		for(var i=0; i<skipbtns.count; i++)
		{
			var	name	= skipbtns[i];
			if(item.name == name)
			{
				item.on	= true;
				item.enter();
				cf.skipKey	= i + 1;
			}
			else
				Menu_object.setProp(name, "on", false, PRIMARY);
		}
		break;

/*	case "選択肢Skip解除ON":
	case "選択肢Skip解除OFF":
		var	on	= item.name.substr(9, 2) == "ON";
		item.on	= true;
		item.enter();
		cf.stopSkipAtAlternative	= on;
		Menu_object.setProp("選択肢Skip解除" + (on ? "OFF" : "ON"), "on", false, PRIMARY);
		break;
*/
	case "早送り既読のみON":
	case "早送り既読のみOFF":
		var	on	= item.name.substr(7, 2) == "ON";
		item.on	= true;
		item.enter();
		cf.skipOnly2nd	= on;
		Menu_object.setProp("早送り既読のみ" + (on ? "OFF" : "ON"), "on", false, PRIMARY);
		break;

	case "既読SceneSkipOFF":
	case "既読SceneSkipON":
		var	on	= item.name.substr(11, 2) == "ON";
		item.on	= true;
		item.enter();
		cf.scene2ndSkip	= on;
		Menu_object.setProp("既読SceneSkip" + (on ? "OFF" : "ON"), "on", false, PRIMARY);
		break;

	/*
	case "既読MsgSkipOFF":
	case "既読MsgSkipON":
		var	on	= item.name.substr(9, 2) == "ON";
		item.on	= true;
		item.enter();
		cf.ch2ndSkip	= on;
		Menu_object.setProp("既読MsgSkip" + (on ? "OFF" : "ON"), "on", false, PRIMARY);
		break;
	*/

	case "自動中カットOFF":
	case "自動中カットON":
		var	on	= item.name.substr(6, 2) == "ON";
		item.on	= true;
		item.enter();
		cf.autoModeArrowClick	= on;
		Menu_object.setProp("自動中カット" + (on ? "OFF" : "ON"), "on", false, PRIMARY);
		break;

	case "フォント変更":
		item.enter();
		CFopenFontSelect();
		break;

	case "太字ルビ":
	case "太字":
		var	ruby	= item.name.substr(2, 2) == "ルビ";
		item.on		= !item.on;
		item.enter();
		tf[ruby ? "chDefaultRubyBold" : "chDefaultBold"]	= item.on;
		var	sample	= Menu_object.find("フォントサンプル表示", PRIMARY);
		if(sample != void && sample isvalid) with(sample)
		{
			.defaultBold	= tf.chDefaultBold;
			.defaultRubyBold= tf.chDefaultRubyBold;
			.clear();
			.updateTestRuby();
			.playMessage();
		}
		break;

	case "OK":
		kag.chDefaultFace		= tf.chDefaultFace;
		kag.chDefaultBold		= tf.chDefaultBold;
		kag.chDefaultRubyBold	= tf.chDefaultRubyBold;
		kag.setMessageLayerUserFont();

	case "CANCEL":
		CFcloseFontSelect(item.name == "OK");
		item.enter();
		break;
	}
}

function CFsetFontMenuItem(name2pos, creates, actions, isclose)
{
	tf.chDefaultFace		= kag.chDefaultFace;
	tf.chDefaultBold		= kag.chDefaultBold;
	tf.chDefaultRubyBold	= kag.chDefaultRubyBold;

	if(!isclose)
	{
		var	isbitmap	= loadedBitmapFonts[kag.chDefaultFace] != void;
		setCreateProps(creates[name2pos["太字"]], %[on:kag.chDefaultBold, enabled:!isbitmap], 2);
		setCreateProps(creates[name2pos["太字ルビ"]], %[on:kag.chDefaultRubyBold, enabled:!isbitmap], 2);
	}
	else
	{
		var	names	= [ "太字", "太字ルビ" ];
		for(var i=0; i<names.count; i++)
		{
			var	name	= names[i];
			var	item	= Menu_object.find(name, PRIMARY);
			if(item == void || !(item isvalid))
				continue;
			setCreateProps(creates[name2pos[name]], %[on:item.on, enabled:item.enabled], 2);
		}
	}
	setCreateProp(creates[name2pos["CANCEL"]], "pressse", "");
}

function CFopenFontSelect()
{
	if(tf.cf_fontopened)
		return;
	tf.cf_fontopened	= true;
	inMenu("fontselect");

	//	メッセージサンプル表示を停止
	var	item	= Menu_object.find("メッセージサンプル表示", PRIMARY);
	if(item != void && item isvalid)
		item.stopMessage();

	var	cont	= kag.transCount > 0;
	with(Menu_object)
	{
		.setClick(, "CFcloseFontSelect()");
		.setDisfocusableAll();	//	titleメニューや右クリックメニューを focusable=false にする

		CFplayTimeline(5, CFsetFontMenuItem);

		//	追加メニューアイテム
		var	items = [], item;
		var	time	= 350;
		var	fontselect;
		items.add(fontselect = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"FontListMenuItemLayer","center"=>509,"vcenter"=>233,"width"=>301,"height"=>212,
			"name"=>"フォント選択","visible"=>1,"opacity"=>0,"absolute"=>14100+CFbaseAbsolute,
			"zoom"=>105,"margint"=>2,"marginb"=>2,"marginl"=>2,"marginr"=>2,"ibv"=>false, fontheight:kag.current.fontSize,
			"mouseup"=> "chgFontName=fontno;", sliderstorage:"font_スクロール", slidercenter:671, sliderviewarea:"0/0/17/11",
			leftItems:[ "CANCEL" ], rightItems:[ "OK" ], cont:cont
		]));
		with(fontselect)
		{
			.mute	= true;	.fontface	= tf.chDefaultFace;	.mute	= false;	//	現在のフォントを選択状態にするとき、効果音がならないように mute する
			.ssact(time, "zoom", 100);
			.ssact(time * 1.5, "opacity", 255);
			.position	= .lineheight * .chosenno;
			.onChose	= function(index, fontface)
			{
				var	bold	= find("太字", PRIMARY);
				var	rubybold= find("太字ルビ", PRIMARY);
				var	sample	= find("フォントサンプル表示", PRIMARY);
				if(bold == void || !(bold isvalid) || rubybold == void || !(rubybold isvalid) || sample == void || !(sample isvalid))
					return;

				var	isbitmap	= loadedBitmapFonts[fontface] != void;
				with(sample)
				{
					.holdFont	= true;
					bold.enabled = rubybold.enabled = !isbitmap;
					if(!isbitmap)
					{
						.defaultBold	= .bold		= bold.on;
						.defaultRubyBold= .rubyBold	= rubybold.on;
					}
					else
						.defaultBold = .bold = .defaultRubyBold = .rubyBold = false;
					.userFace	= .fontFace = .defaultFace = tf.chDefaultFace = fontface;
					.clear();
					.updateTestRuby();
					.playMessage();
				}
			} incontextof fontselect;
			.slider.ssact(time * 1.5, "opacity", 255, time) if .slider isvalid;
		}

		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"MessageMenuItemLayer","left"=>360,"top"=>351,"width"=>320,"height"=>50,
			"absolute"=>14650+CFbaseAbsolute,"opacity"=>1,"visible"=>true,"name"=>"フォントサンプル表示","margin"=>2,
			"ibv"=>false,"framecolor"=>0,"linespacing"=>9,"zoom"=>105,"frameopacity"=>0,"msgdelay"=>time, cont:cont
		]));
		with(item)
		{
			.updateTestRuby	= function
			{
				setRuby(%[text:__("まほうつかいのよる ABC 012"), char:length]);
				update();
			} incontextof item;
			.text	= __("魔法使いの夜 ABC 012<s>");
			.length	= .text.length - 3;
			.updateTestRuby();
			.ssact(time, "zoom", 100);
			.ssact(time * 1.5, "opacity", 255);
		}

		if(cf.autoMouseMove)
			moveCursor(fontselect,,,, time \ 2);
	}
}

function CFcloseFontSelect(ok=false)
{
	if(!tf.cf_fontopened)
		return;
	delete tf.cf_fontopened;
	delete tf.chDefaultFace;
	delete tf.chDefaultBold;
	delete tf.chDefaultRubyBold;
	outMenu("fontselect");

	//	メッセージサンプル表示を再開
	var	item	= Menu_object.find("メッセージサンプル表示", PRIMARY);
	if(item != void && item isvalid)
	{
		item.defaultFace = item.userFace = item.fontFace = kag.chDefaultFace;
		item.bold = item.defaultBold = kag.chDefaultBold;
		item.rubyBold = item.defaultRubyBold = kag.chDefaultRubyBold;
		item.clear();
		item.msgdelay	= 300;
		item.text	= item.text;	//	playMessageの代わりにtext再代入してmsgdelayを有効に
	}

	with(Menu_object)
	{
		.playSE(cancelse) if !ok;
		.resetClick();
		.revertDisfocusable();

		//	追加メニューアイテムも閉じる
		var	time	= 350;
		var	item	= .find("フォント選択", PRIMARY);
		if(item != void && item isvalid)
		{
			item.enabled= false;
			item.zoom	= 100;
			item.vanish(time * 0.2);
			item.ssact(time, "zoom", 95,,, false);
		}
		item	= .find("フォント選択スライダー", PRIMARY);
		if(item != void && item isvalid)
			item.vanish(time * 0.2);
		item	= .find("フォントサンプル表示", PRIMARY);
		if(item != void && item isvalid)
			item.vanish(time * 0.2);

		CFplayTimeline(6, CFsetFontMenuItem,, true);
	}
	if (ok)
	{
		closeConfigMenu();
		closeRClickMenu();
		kag.onReloadScenarioMenuItemClick();
	}
}

function CFsetSoundMenuItem(name2pos, creates, actions, isclose)
{
	if(typeof kag.bgmPropMute == "undefined")
	{
		kag.bgmPropMute		= false;
		kag.bgmPropVolume	= kag.bgmVolume;
	}
	if(typeof kag.sePropMute == "undefined")
	{
		kag.sePropMute	= false;
		kag.sePropVolume= kag.seVolume;
	}

	var	btns	= [
		"エフェクト瞬間",	cf.effectSkip,
		"演出スキップ",		cf.effectCut,
		"画面切替時TXT消",	!cf.noTextOff,
		"特殊効果表示",		cf.speffect
	];
	for(var i=0; i<btns.count; i+=2)
	{
		setCreateProp(creates[name2pos[btns[i]+"する"]], "on", btns[i+1]);
		setCreateProp(creates[name2pos[btns[i]+"しない"]], "on", !btns[i+1]);
	}
	setCreateProps(creates[name2pos["BGMミュート"]], %[on:kag.bgmPropMute, upItems:["BGMボリューム変更"], downItems:["SEボリューム変更"]], 3);
	setCreateProps(creates[name2pos["SEミュート"]], %[on:kag.sePropMute, upItems:["SEボリューム変更"], downItems:["SE再生テスト"], otherBuff:true], 3);
	setCreateProps(creates[name2pos["SYSSEミュート"]], %[on:kag.systemSEMute, upItems:["SYSSEボリューム変更"], downItems:["Back"]], 3);

@if(CONFIG_DRAW_SPEED)
	//エフェクト瞬間を無効に
	setCreateProp(creates[name2pos["エフェクト瞬間する"]], "visible", false);
	setCreateProp(creates[name2pos["エフェクト瞬間しない"]], "visible", false);
	setCreateProp(creates[name2pos["演出スキップする"]], "upItems", "演出速度変更");
	setCreateProp(creates[name2pos["演出スキップしない"]], "upItems", "演出速度変更");
	setCreateProp(creates[name2pos["メッセージ"]], "downItems", "演出速度変更");
	setCreateProp(creates[name2pos["ショートカットキー"]], "downItems", "演出速度変更");
@endif
}

function CFopenSound(firsttime=false)
{
	if(!tf.cf_opened)
		return;
	CFplayTimeline(firsttime ? 7 : 17, CFsetSoundMenuItem, firsttime);

	CFsetFocusNext("BGMボリューム変更", "エフェクト瞬間する",, "エフェクト瞬間しない", "特殊効果表示する");

	//	追加のメニューアイテム
	var	delay	= 100;
	var	time	= firsttime ? 200 : 150;
	var	cont	= kag.transCount > 0;
	with(Menu_object)
	{
		var	item, items = [];
		var	baseabsolute= .getProp("サウンドエフェクト用背景", "absolute", PRIMARY);
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>141,
			"range"=>324,"min"=>0,"max"=>100,"storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>baseabsolute+50,"visible"=>1,
			"name"=>"BGMボリューム変更","targetprop"=>"value","opacity"=>0,
			"mousemove"=>"kag.bgmPropVolume=int(this.value+0.5);",
			"mouseup"=> "kag.bgmPropVolume=int(this.value+0.5);",
			"keydown"=>"kag.bgmPropVolume=int(this.value+0.5);",
			upItems:[ "システム" ], downItems:[ "BGMミュート" ], cont:cont,
			"hint"=>__("BGMボリュームを変更します")
		]));
		item.value	= kag.bgmPropVolume;
		var	lastabsolute= .getProp("BGMミュート", "absolute", PRIMARY);
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>267,
			"range"=>324,"min"=>0,"max"=>100,"storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>lastabsolute+50,"visible"=>1,
			"name"=>"SEボリューム変更","targetprop"=>"value","opacity"=>0,
			"mousemove"=>"kag.sePropVolume=int(this.value+0.5);",
			"mouseup"=> "kag.sePropVolume=int(this.value+0.5);",
			"keydown"=> "kag.sePropVolume=int(this.value+0.5);",
			upItems:[ "BGMミュート" ], downItems:[ "SEミュート" ], cont:cont,
			"hint"=>__("効果音ボリュームを変更します")
		]));
		item.value	= kag.sePropVolume;
		lastabsolute= .getProp("SE再生テスト", "absolute", PRIMARY);
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>269,"vcenter"=>410,
			"range"=>324,"min"=>0,"max"=>100,"storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>lastabsolute+50,"visible"=>1,
			"name"=>"SYSSEボリューム変更","targetprop"=>"value","opacity"=>0,
			"mousemove"=>"kag.systemSEVolume=int(this.value+0.5);",
			"mouseup"=> "kag.systemSEVolume=int(this.value+0.5);",
			"keydown"=> "kag.systemSEVolume=int(this.value+0.5);",
			upItems:["SE再生テスト"], downItems:[ "SYSSEミュート" ], cont:cont,
			"hint"=>__("システム効果音ボリュームを変更します")
		]));
		item.value	= kag.systemSEVolume;
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>141,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"BGMボリューム変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x - width / 2, "BGMボリューム変更") if button === mbLeft;
		} incontextof item;
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>267,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"SEボリューム変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x - width / 2, "SEボリューム変更") if button === mbLeft;
		} incontextof item;
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>269,"vcenter"=>410,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"SYSSEボリューム変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x - width / 2, "SYSSEボリューム変更") if button === mbLeft;
		} incontextof item;

@if(CONFIG_DRAW_SPEED)
		//演出速度倍率
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"SliderMenuItemLayer","center"=>751,"vcenter"=>184,
			"range"=>324,"min"=>0,"max"=>100,"storage"=>"c_バーカーソル","viewarea"=>"0/0/19/19",
			"viewareaNo"=>0,"itemMode"=>imImageButton,"absolute"=>baseabsolute+50,"visible"=>1,
			"name"=>"演出速度変更","targetprop"=>"value","opacity"=>0,
			"mousemove"=>"kag.drawSpeedProp=int(this.value+0.5);",
			"mouseup"=> "kag.drawSpeedProp=int(this.value+0.5);",
			upItems:[ "ショートカットキー" ], downItems:[ "演出スキップする" ], cont:cont,
			"hint"=>__("演出速度を変更します")
		]));
		item.value	= kag.drawSpeedProp;
		items.add(item = .addMenuItem(%[
			"page"=>PRIMARY,"class"=>"TmpMenuItemLayer","center"=>751,"vcenter"=>184,
			"storage"=>"c_バーカーソル透明部","absolute"=>baseabsolute+10,"visible"=>1,
			"name"=>"演出速度変更余白","opacity"=>0, "itemMode"=>imParts, cont:cont
		]));
		item.hitThreshold	= 0;
		item.onMouseDown	= function(x, y, button, shift)
		{
			CFsetValueBySpace(x - width / 2, "演出速度変更") if button === mbLeft;
		} incontextof item;
@endif

		for(var i=0; i<items.count; i++)
		{
			item	= items[i];
			item.ssact(time+delay, "top", item.top + 10);
			item.ssact(time, "opacity", 255, delay);
		}

		.setProp("SE再生テスト", "pressse", "", PRIMARY);
	}
}

function CFcloseSound(closeall=false)
{
	var	names	= [ "BGMボリューム変更", "SEボリューム変更", "SYSSEボリューム変更",
					"BGMボリューム変更余白", "SEボリューム変更余白", "SYSSEボリューム変更余白"
@if(CONFIG_DRAW_SPEED)
					,"演出速度変更", "演出速度変更余白"
@endif
				  ];
	var	item;
	var	time	= closeall ? 300 : 250;
	for(var i=0; i<names.count; i++)
	{
		item	= Menu_object.find(names[i], PRIMARY);
		if(item == void || !(item isvalid))
			continue;
		item.hint	= "";
		item.ssact(time, "top", item.top + 10,,, false);
		item.vanish(time);
	}

	//	pressse = "" を削除する(そのままだと、再利用されたときに押下時のシステム効果音が再生されないため)
	item	= Menu_object.find("SE再生テスト", PRIMARY);
	delete item.pressse if item != void;

	CFplayTimeline(closeall ? 8 : 18, CFsetSoundMenuItem,, true, closeall);
}

//	特殊効果を表示しない設定の確認
function onNoSPEffect()
{
//	Menu_object.setProp("特殊効果表示しない", "on", true, PRIMARY);
	global.cf.speffect	= false;
	global.sf.speffectChecked	= true;	//	確認するのは一度だけ
	Menu_object.setProp("特殊効果表示する", "on", false, PRIMARY);
}
function cancelNoSPEffect()
{
	Menu_object.setProp("特殊効果表示しない", "on", false, PRIMARY);
}

function configSeMouseUp(item)
{
	switch(item.name)
	{
	case "特殊効果表示しない":
		if(!sf.speffectChecked)
		{
			askYesNo(__("特殊効果を表示しない場合、一部演出がカットされることがあります。\n変更してもよろしいですか？"),
				"設定変更確認", onNoSPEffect, cancelNoSPEffect);
			item.on	= true;
			break;
		}
	case "特殊効果表示する":
		var	on	= item.name.substr(6, 2) == "する";
		item.on	= true;
		item.enter();
		Menu_object.setProp("特殊効果表示"+(on ? "しない" : "する"), "on", false, PRIMARY);
		cf.speffect	= on;
		break;

	case "画面切替時TXT消する":
	case "画面切替時TXT消しない":
		var	on	= item.name.substr(9, 2) == "する";
		item.on	= true;
		item.enter();
		Menu_object.setProp("画面切替時TXT消"+(on ? "しない" : "する"), "on", false, PRIMARY);
		cf.noTextOff	= !on;
		break;

	case "演出スキップする":
	case "演出スキップしない":
		var	on	= item.name.substr(6, 2) == "する";
		item.on	= true;
		item.enter();
		Menu_object.setProp("演出スキップ"+(on ? "しない" : "する"), "on", false, PRIMARY);
		cf.effectCut	= on;
		break;

@if(!CONFIG_DRAW_SPEED)
	case "エフェクト瞬間する":
	case "エフェクト瞬間しない":
		var	on	= item.name.substr(7, 2) == "する";
		item.on	= true;
		item.enter();
		Menu_object.setProp("エフェクト瞬間"+(on ? "しない" : "する"), "on", false, PRIMARY);
		cf.effectSkip	= on;
		kag.drawSpeedProp = on ? 100 : 0;
		break;
@endif

	case "BGMミュート":
	case "SEミュート":
	case "SYSSEミュート":
		var	propnames	= %[BG:"bgmPropMute", SE:"sePropMute", SY:"systemSEMute"];
		item.on	= !item.on;
		item.enter();
		kag[propnames[item.name.substr(0, 2)]]	= item.on;
		break;

	case "SE再生テスト":
		var	seTestFiles	= [
			"se01006.wav",
			"se01014.wav",
			"se01021.wav",
			"se01037.wav",
			"se01047a.wav",
			"se01047b.wav",
			"se01047c.wav"
		];
		var	storage;
		for(var i=0; i<100; i++)
		{
			storage	= seTestFiles[int(Math.random() * seTestFiles.count)];
			if(Storages.isExistentStorage(storage))
				break;
		}
		kag.tagHandlers.se(%[storage:storage]);
		item.enter();
		break;
	}
}

function CFopenShortcut(firsttime=false)
{
	if(!tf.cf_opened)
		return;
	CFplayTimeline(firsttime ? 9 : 19, , firsttime);

	CFsetFocusNext("Back", "Back", "Back",, "システム");
}

function CFcloseShortcut(closeall=false)
{
	CFplayTimeline(closeall ? 10 : 20, ,, true, closeall);
}

//	演出の速度等を推奨設定に戻す
/*
・推奨設定に戻す項目？

	System
		? テキスト表示演出、既読テキスト表示演出
	Message
		未読メッセージ表示間隔、既読メッセージ表示間隔
		オートモードのページ切り替え時間、オートモードのクリック待ち時間
		? オートモード時の左クリック、メッセージの早送り
	Sound/Effect
		エフェクト瞬間表示設定、演出のスキップ
		? 画像切り替え時にテキストを消去、特殊効果の表示
 */
function setConfigToDefault()
{
	dm("setConfigToDefault()");

	//	推奨設定に戻す
	with(RecommendedSettings)
	{
		kag.userChSpeed				= .userChSpeed;
		kag.chNonStopToPageBreak	= .chNonStopToPageBreak;
		kag.userCh2ndSpeed			= .userCh2ndSpeed;
		kag.ch2ndNonStopToPageBreak	= .ch2ndNonStopToPageBreak;
		kag.autoModePageWait		= .autoModePageWait;
		kag.autoModeLineWait		= .autoModeLineWait;
		cf.effectSkip				= .effectSkip;
		kag.drawSpeedProp			= .effectSkip ? 100 : 0;
		cf.effectCut				= .effectCut;
		cf.speffect					= .speffect;
	}

	//	コンフィグアイテムの表示を補正
	with(Menu_object)
	{
		if(.find("システム用背景", PRIMARY) != void)
		{
		}
		else if(.find("メッセージ用背景", PRIMARY) != void)
		{
			.find("未読メッセージ表示間隔変更", PRIMARY).value = .find("未読メッセージ表示間隔", PRIMARY).value = kag.userChSpeed;
			.setProp("未読ページ末一気", "on", kag.chNonStopToPageBreak, PRIMARY);
			.find("既読メッセージ表示間隔変更", PRIMARY).value = .find("既読メッセージ表示間隔", PRIMARY).value = kag.userCh2ndSpeed;
			.setProp("既読ページ末一気", "on", kag.ch2ndNonStopToPageBreak, PRIMARY);
			.find("オートページ切替時間変更", PRIMARY).value = kag.autoModePageWait \ 50;
			.find("オートページ切替時間", PRIMARY).value = kag.autoModePageWait;
			.find("オート改行切替時間変更", PRIMARY).value = kag.autoModeLineWait \ 10;
			.find("オート改行切替時間", PRIMARY).value = kag.autoModeLineWait;
		}
		else if(.find("サウンドエフェクト用背景", PRIMARY) != void)
		{
			.setProp("エフェクト瞬間する",	"on", cf.effectSkip, PRIMARY);
			.setProp("エフェクト瞬間しない","on", !cf.effectSkip, PRIMARY);
			.setProp("演出スキップする",	"on", cf.effectCut, PRIMARY);
			.setProp("演出スキップしない",	"on", !cf.effectCut, PRIMARY);
			.setProp("特殊効果表示する",	"on", cf.speffect, PRIMARY);
			.setProp("特殊効果表示しない",	"on", !cf.speffect, PRIMARY);
		}
		//	ショートカット画面は特に処理は必要ない
	}
}

@endif
