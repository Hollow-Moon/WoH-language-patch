
global.patch_hint_delay = 500;

global.Window_hint_original = global.Window;
class Window_hint_override extends global.Window_hint_original
{
	function Window_hint_override()
	{
		super.Window(...);

		this.patch_hint_set_timer();
	}

	function Window()
	{
		this.Window_hint_override(...);
	}

	var hintlayer = void;
	var hinttimer = void;

	var patch_hint_hintDelay = 500;
	property hintDelay
	{
		getter
		{
			return this.patch_hint_hintDelay;
		}
		setter (v)
		{
			this.patch_hint_hintDelay = v | 0;
			this.patch_hint_set_timer();
		}
	}

	var patch_hint_last_x = 0;
	var patch_hint_last_y = 0;
	function patch_hint_on_timer()
	{
		this.hinttimer.enabled = false;
		try
		{
			if (this instanceof "VideoOverlayOwnerWindow" || typeof(this.primaryLayer) !== "Object" || this.primaryLayer === null)
			{
				return;
			}
			var primary_layer = this.primaryLayer;
			var p = primary_layer.getLayerAt(primary_layer.cursorX, primary_layer.cursorY);
			if (p === void || p === null)
			{
				return;
			}
			if (p.patch_hint_ignoreHintSensing)
			{
				return;
			}
			while (p.patch_hint_showParentHint)
			{
				var parent = p.parent;
				if (parent === void || parent === null)
				{
					break;
				}
				p = parent;
			}
			if (p)
			{
				var hint = p.patch_hint_hint;
				if (hint !== "")
				{
					this.onHintChanged(hint, this.patch_hint_last_x, this.patch_hint_last_y, true);
				}
			}
			
		}
		catch (e)
		{

		}
	}

	function patch_hint_set_timer()
	{
		if (this.hinttimer === void)
		{
			this.hinttimer = new global.Timer(this, "patch_hint_on_timer");
			this.hinttimer.capacity = 1;
			this.hinttimer.mode = global.atmAtIdle;
		}
		this.hinttimer.enabled = false;
		this.hinttimer.interval = this.patch_hint_hintDelay;
	}

	function initHintLayer()
	{
		if (this instanceof "VideoOverlayOwnerWindow" || typeof(this.primaryLayer) !== "Object" || this.primaryLayer === null)
		{
			return;
		}

		this.hintlayer = new global.Layer(this, this.primaryLayer);
		{
			var l = this.hintlayer;
			l.visible = false;
			l.ignoreHintSensing = true;
			l.hitThreshold = 256;
			l.font.height = 9;
			l.font.face = global.__s("MS UI Gothic", "hint_font_face");
		}

		// hintDelay = 500; // default
		// hintDelay = 0; // immediate
		// hintDelay = -1; // never
		// hintDelay = 1000; // slow
	}

	var hintHorizontalPadding = 4;
	var hintVerticalPadding = 6;
	var hintLineSpacing = 6;
	var tooltipBorderColor = 0xffffe1;
	var mouseCursorSize = 20;

	function onMouseLeave()
	{
		this.hinttimer.enabled = false;
		try
		{
			this.onHintChanged("", 0, 0, false);
		}
		catch (e)
		{

		}
		return super.onMouseLeave(...);
	}

	function onMouseMove(x, y, shift)
	{
		this.hinttimer.enabled = false;
		try
		{
			this.onHintChanged("", x, y, false);
			this.patch_hint_last_x = x;
			this.patch_hint_last_y = y;
		}
		catch (e)
		{

		}
		this.hinttimer.enabled = true;
		return super.onMouseMove(...);
	}

	function onHintChanged(text, x, y, isshow)
	{
		if (this.hintlayer === void)
		{
			this.initHintLayer();
		}
		if (this.hintlayer === void)
		{
			return;
		}
		if (isshow) {
			if (global.Window.mainWindow.sflags["showHoverTips"] == 0)
				return;

			var lines = text.split("\n");
			var longestLineIndex = 0;
			for (var i = 1, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				if (lines[i].length > lines[longestLineIndex].length) {
					longestLineIndex = i;
				}
			}

			// -----------------------------------------------------------------------------------------------
			// Convert from screen space to base layer coordinates

			var clientRect;
			if (typeof(this.getClientRect) === "Object")
			{
				clientRect = this.getClientRect();
			}
			if (typeof(clientRect) !== "Object")
			{
				clientRect = %[];
				clientRect.w = this.width;
				clientRect.h = this.height;
			}
			
			if (typeof(this.fullScreened) === "Integer" && this.fullScreened)
			{
				clientRect.h = global.System.screenHeight;	// clientRect.h can be bigger than screenHeight when fullScreened, with some black border at the bottom, for unknown reasons.
			}

			var pxWidth = this.scWidth;
			if (typeof(this.pxWidth) === "Integer" || typeof(this.pxWidth) === "Real")
			{
				pxWidth = this.pxWidth;
			}
			var pxHeight = this.scHeight;
			if (typeof(this.pxHeight) === "Integer" || typeof(this.pxHeight) === "Real")
			{
				pxHeight = this.pxHeight;
			}
			var windowWideFactor = 1;
			if (["Integer", "Real"].find(typeof(this.wideFactor)) !== -1)
			{
				windowWideFactor = this.wideFactor;
			}

			// Calculate the actually used (absolute) width/height the game content uses (so without black borders in fullscreen/maximized)
			var pxWidth_abs = global.Math.floor(clientRect.h * pxWidth * windowWideFactor / pxHeight) | 0;
			var pxHeight_abs = clientRect.h;
			//var z = clientRect.h / this.pxHeight;
			
			// If neccessary, recalculate to fit from inside
			if (pxWidth_abs > clientRect.w)
				{
				pxWidth_abs = clientRect.w;
				pxHeight_abs = global.Math.floor(clientRect.w * pxHeight / (pxWidth * windowWideFactor)) | 0;
				//z = clientRect.w / global.Math.floor(pxWidth * windowWideFactor);
				}
			
			// Calculate the offset introduced by the black borders in maximized mode.
			var widthOffsetAbs = 0;
			var heightOffsetAbs = 0;
			
			if (typeof(this.maximized) === "Integer" && this.maximized)
			{
				widthOffsetAbs = (clientRect.w  - pxWidth_abs) / 2;
				heightOffsetAbs = (clientRect.h - pxHeight_abs) / 2;
			}

			var x = (x - widthOffsetAbs)  * pxWidth  / pxWidth_abs;
			var y = (y - heightOffsetAbs) * pxHeight / pxHeight_abs;

			// -----------------------------------------------------------------------------------------------
			// Recalculate size of font and tip box

			var fontSizeRatio = 1.0;
			var fontHeightBase = global.__si("9", "hint_fontHeightBase");

			fontSizeRatio /= global.Math.min(1, pxHeight_abs/pxHeight);	// If the absolute window size on screen gets small, the fontSizeRatio will increase, leading to a bigger font
			this.hintlayer.font.height = global.Math.ceil(fontHeightBase * fontSizeRatio);	// "Ceil" because erring on the side of a bigger font is preferable

			var fontHeight = this.hintlayer.font.height;						// Retrieve it again - it might have been modified while setting!

			var w = this.hintlayer.font.getTextWidth(lines[longestLineIndex]) + this.hintHorizontalPadding * 2;
			var h = fontHeight * lines.count + this.hintLineSpacing * (lines.count-1) + this.hintVerticalPadding * 2;
			this.hintlayer.setImageSize(w, h);
			this.hintlayer.setSizeToImageSize();

			// -----------------------------------------------------------------------------------------------
			// Position tip layer

			var mouseCursorSizeAdjusted = this.mouseCursorSize * pxHeight / pxHeight_abs;
			
			if ((x + w) > pxWidth)
				x = pxWidth - w;

			var yTest = y + mouseCursorSizeAdjusted + h;

			if ((y + mouseCursorSizeAdjusted + h) > pxHeight)
				y = pxHeight - h - mouseCursorSizeAdjusted;

			x = (x * windowWideFactor) * (pxWidth - w) / ((pxWidth * windowWideFactor) - w);	// Inverse discrete transform to compensate from offset that will be introduced during setPos()

			this.hintlayer.setPos(x, y + mouseCursorSizeAdjusted);

			// -----------------------------------------------------------------------------------------------

			this.hintlayer.fillRect(0, 0, w, h, 0);
			this.hintlayer.colorRect(0, 0, w, h, global.clInfoBk, 196);

			this.hintlayer.colorRect(0,   0,   1, h, this.tooltipBorderColor);
			this.hintlayer.colorRect(0,   0,   w, 1, this.tooltipBorderColor);
			this.hintlayer.colorRect(w-1, 0,   1, h, this.tooltipBorderColor);
			this.hintlayer.colorRect(0,   h-1, w, 1, this.tooltipBorderColor);

			var lineY = this.hintVerticalPadding;
			for (var i = 0, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				this.hintlayer.drawText(this.hintHorizontalPadding, lineY, lines[i], global.clInfoText, 220);
				lineY += fontHeight + this.hintLineSpacing;
			}
			this.hintlayer.visible = true;
			this.hintlayer.bringToFront();
		} else {
			this.hintlayer.visible = false;
		}
	}
}
global.Window = global.Window_hint_override;


global.Layer_hint_original = global.Layer;
class Layer_hint_override extends global.Layer_hint_original
{
	function Layer_hint_override()
	{
		super.Layer(...);
	}

	function Layer()
	{
		this.Layer_hint_override(...);
	}

	var patch_hint_hint = "";
	property hint
	{
		getter
		{
			return this.patch_hint_hint;
		}
		setter (v)
		{
			this.patch_hint_ignoreHintSensing = false;
			this.patch_hint_showParentHint = false;
			this.patch_hint_hint = "" + v;
		}
	}

	var patch_hint_ignoreHintSensing = false;
	property ignoreHintSensing
	{
		getter
		{
			return this.patch_hint_ignoreHintSensing;
		}
		setter (v)
		{
			this.patch_hint_ignoreHintSensing = !!v;
		}
	}

	var patch_hint_showParentHint = true;
	property showParentHint
	{
		getter
		{
			return this.patch_hint_showParentHint;
		}
		setter (v)
		{
			this.patch_hint_showParentHint = !!v;
		}
	}

}
global.Layer = global.Layer_hint_override;

